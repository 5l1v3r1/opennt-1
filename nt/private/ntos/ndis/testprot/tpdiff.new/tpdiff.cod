	TITLE	w:\nt\private\ntos\ndis\testprot\tpdiff.new\tpdiff.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BA@HFFJ@?9SECTION_START?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@LPKB@?9SECTION_END?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LAON@?9OPTIONALS?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NOCK@?9TOKEN_MATCH?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IBDI@?9SECTION_DESC?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GIBN@DIFF?4TXT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DH@PBDH@?6MAC?5NDIS?53?40?5Tester?5?9?5Comparato@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CEFE@?9f?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HGLE@?9F?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01LHO@r?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@DJPC@Could?5not?5open?5the?5primary?5log?5l@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@DPBH@The?5system?5has?5run?5out?5of?5memory@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EN@FLEA@An?5error?5occurred?5determining?5th@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02INOK@w?$CL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@EHOB@Unable?5to?5open?5the?5difference?5te@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JJJH@?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@LHCE@__________DETAILS_LOG__________?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@JHAI@Comparing?5files?5?$CFs?5and?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@NEAI@?6?6?$CK?$CKComparing?5?$CFs?5and?5?$CFs?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@BCNC@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@BFOO@TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@IBIK@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FMLE@?7Unable?5to?5open?5file?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@LFPA@TPDIFF?5?$CFs?0?5?$CFs?5resulted?5in?5a?5file@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@LOBF@?6__________END_DETAILS_LOG______@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@NEJO@?6?6__________SUMMARY_LOG_________@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@LCOP@?6__________END_SUMMARY_LOG______@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@EMG@?6?6__________CUMMALATIVE_RESULTS_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LJOK@COMPARED?5?$CFd?5FILE?5PAIR?$CIS?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@BCML@TOTAL?5NUMBER?5OF?5DIFFERENCES?5ENCO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@DFAD@TOTAL?5NUMBER?5OF?5FILE?5OPEN?5ERRORS@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@EHHI@?6__________END_CUMMALATIVE_RESUL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@LDEB@?6?7Usage?3?5TPDIFF?5LOG_FILE?5GOLDEN_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HCFM@?7Where?3?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@DMBI@?7LOG_FILE?5?5?5?5?5?5?5?9?5is?5the?5log?5fil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNO@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5for?5correctnes@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@GJFJ@?7KNOWN_LOG_FILE?5?9?5is?5the?5known?5g@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@NAKP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5used?5to?5verify@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@FCKK@?7DIFFS_FILE?5?5?5?5?5?9?5is?5the?5file?5th@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@NLIK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5lo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EB@HDHK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@JBKA@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diff@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@GJAD@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5D@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@ECIF@?7?7?9?5OR?5?9?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@CEID@?7TPDIFF?5?9F?5LOG_FILE_LIST?5?$FLDIFFS_@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JBOD@?7LOG_FILE_LIST?5?9?5is?5a?5file?5conta@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@LBMC@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5names?5and?5known@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@NKEL@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5pairs?5of?5file?5n@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@EMEE@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5in?5the?5file?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@LLIG@?7DIFFS_FILE?5?5?5?5?9?5is?5the?5file?5the@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@KLJP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5log@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@NJAK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5w@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@OBLF@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diffe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@INGM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5DI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IGFG@?5?0?7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GG@KFPJ@The?5first?5log?5file?5name?5is?3?7?$CFs?6H@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@BDDE@Unable?5to?5determine?5the?5first?5lo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@ODMB@?6A?5BAD?5SECTIONAL?5CONTROL?5SEGMENT@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DBNA@?6CHECK?5FOR?5A?5SYNTAX?5ERROR?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@EGAP@?6?6__SECTIONAL?5RESULTS?5FOR?5SECTIO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NEDE@MAY_DIFFER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CCOH@BETWEEN_VALUES?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KMAE@?0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MGBK@EQUAL_LAST?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JGGD@?0?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@BP@?6FOUND?5?5?5?5?$CICOMP?4FILE?5LINE?5CONTEN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@KOJI@EXPECTED?5?$CIGOLDEN?5FILE?5LINE?5CONTE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DM@IAKH@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EO@IECB@?6INDEX?5?5?5FOUND?$CICURRENT?5EXTRACTED@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FJJJ@?$CF5u?5?5?5?$CF32u?5?5?5?$CF32u?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EK@IIIG@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@IIIL@?6EXPECTED?5VALUES?5BETWEEN?5?$CIEXTRAC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@BCGB@?6FOUND?5RESULTS?5IN?5ERROR?$CIEXTRACTE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKBO@INDEX?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5RESULT?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KOPJ@?$CF5u?5?5?5?$CF23u?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FN@KAEO@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBBG@?6UNABLE?5TO?5LOCATE?5LINE?5IN?5THE?5CO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DL@GGNP@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@NOPM@?6EXTRA?5LINE?5DETECTED?5?$CICOMP?4?5FILE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@MBC@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DO@ECGD@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@CEIA@LINE?5ABSENT?5IN?5COMP?4?5FILE?5?$CIGOLDE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EO@IMCE@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@LNMH@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@OPAH@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@NCPN@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@DCBI@?6?6UNKNOWN?5COMPARISON?5RESULT?3?5?$CFu?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@BCAI@FILE?5NAME?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DLKF@SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@FNCM@SECTION?5OFFSET?5LINE?$CD?5?3?5?$CFu?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@KBIG@SECTION?5LINE?5CONTENTS?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@GHGD@The?5system?5has?5run?5out?5of?5memory@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08ILIP@?$FLTPCTL?3?$FN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KECI@SKIP_LINE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Usage@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetFilePair@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _OpenFiles@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CompareFiles@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CompareSections@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetNextLine@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _LineType@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ExtractResults@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ExtractBetweenValues@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CombinedVariation@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CompareLines@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InitializeSectionControl@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PrintComparisonResults@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PrintSectionInformation@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ExtractSectionIDFromLine@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CheckSectionIDFromCurrentLines@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CompareLinesAndPrintResults@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TokenInsertInSection@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MatchTopToken@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CompareTokensAndPrintResults@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MayDifferExistsInOneOrMoreLines@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DoNotSkipThisLine@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_Keywords
PUBLIC	??_C@_0BA@HFFJ@?9SECTION_START?9?$AA@		; `string'
PUBLIC	??_C@_0O@LPKB@?9SECTION_END?9?$AA@		; `string'
PUBLIC	??_C@_0M@LAON@?9OPTIONALS?9?$AA@		; `string'
PUBLIC	??_C@_0O@NOCK@?9TOKEN_MATCH?9?$AA@		; `string'
PUBLIC	??_C@_0P@IBDI@?9SECTION_DESC?9?$AA@		; `string'
_DATA	SEGMENT
COMM	_SummaryBuffer:DWORD
_Keywords DD	FLAT:??_C@_0BA@HFFJ@?9SECTION_START?9?$AA@
	DD	FLAT:??_C@_0O@LPKB@?9SECTION_END?9?$AA@
	DD	FLAT:??_C@_0M@LAON@?9OPTIONALS?9?$AA@
	DD	FLAT:??_C@_0O@NOCK@?9TOKEN_MATCH?9?$AA@
	DD	FLAT:??_C@_0P@IBDI@?9SECTION_DESC?9?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0BA@HFFJ@?9SECTION_START?9?$AA@
CONST	SEGMENT
??_C@_0BA@HFFJ@?9SECTION_START?9?$AA@ DB '-SECTION_START-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LPKB@?9SECTION_END?9?$AA@
CONST	SEGMENT
??_C@_0O@LPKB@?9SECTION_END?9?$AA@ DB '-SECTION_END-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LAON@?9OPTIONALS?9?$AA@
CONST	SEGMENT
??_C@_0M@LAON@?9OPTIONALS?9?$AA@ DB '-OPTIONALS-', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOCK@?9TOKEN_MATCH?9?$AA@
CONST	SEGMENT
??_C@_0O@NOCK@?9TOKEN_MATCH?9?$AA@ DB '-TOKEN_MATCH-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IBDI@?9SECTION_DESC?9?$AA@
CONST	SEGMENT
??_C@_0P@IBDI@?9SECTION_DESC?9?$AA@ DB '-SECTION_DESC-', 00H ; `string'
CONST	ENDS
PUBLIC	_main
PUBLIC	_Usage@0
PUBLIC	_GetFilePair@12
PUBLIC	_CompareFiles@16
PUBLIC	_OpenFiles@16
PUBLIC	??_C@_08GIBN@DIFF?4TXT?$AA@			; `string'
PUBLIC	??_C@_0DH@PBDH@?6MAC?5NDIS?53?40?5Tester?5?9?5Comparato@ ; `string'
PUBLIC	??_C@_02CEFE@?9f?$AA@				; `string'
PUBLIC	??_C@_02HGLE@?9F?$AA@				; `string'
PUBLIC	??_C@_01LHO@r?$AA@				; `string'
PUBLIC	??_C@_0CO@DJPC@Could?5not?5open?5the?5primary?5log?5l@ ; `string'
PUBLIC	??_C@_0EJ@DPBH@The?5system?5has?5run?5out?5of?5memory@ ; `string'
PUBLIC	??_C@_0EN@FLEA@An?5error?5occurred?5determining?5th@ ; `string'
PUBLIC	??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
PUBLIC	??_C@_02INOK@w?$CL?$AA@				; `string'
PUBLIC	??_C@_0EF@EHOB@Unable?5to?5open?5the?5difference?5te@ ; `string'
PUBLIC	??_C@_02JJJH@?6?6?$AA@				; `string'
PUBLIC	??_C@_0CC@LHCE@__________DETAILS_LOG__________?6@ ; `string'
PUBLIC	??_C@_0BL@JHAI@Comparing?5files?5?$CFs?5and?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@NEAI@?6?6?$CK?$CKComparing?5?$CFs?5and?5?$CFs?6?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@BCNC@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@BFOO@TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@IBIK@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BJ@FMLE@?7Unable?5to?5open?5file?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@LFPA@TPDIFF?5?$CFs?0?5?$CFs?5resulted?5in?5a?5file@ ; `string'
PUBLIC	??_C@_0CH@LOBF@?6__________END_DETAILS_LOG______@ ; `string'
PUBLIC	??_C@_0CE@NEJO@?6?6__________SUMMARY_LOG_________@ ; `string'
PUBLIC	??_C@_0CH@LCOP@?6__________END_SUMMARY_LOG______@ ; `string'
PUBLIC	??_C@_0DA@EMG@?6?6__________CUMMALATIVE_RESULTS_@ ; `string'
PUBLIC	??_C@_0BK@LJOK@COMPARED?5?$CFd?5FILE?5PAIR?$CIS?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@BCML@TOTAL?5NUMBER?5OF?5DIFFERENCES?5ENCO@ ; `string'
PUBLIC	??_C@_0CN@DFAD@TOTAL?5NUMBER?5OF?5FILE?5OPEN?5ERRORS@ ; `string'
PUBLIC	??_C@_0DD@EHHI@?6__________END_CUMMALATIVE_RESUL@ ; `string'
EXTRN	_memset:NEAR
EXTRN	_strlen:NEAR
EXTRN	_strchr:NEAR
EXTRN	_strncmp:NEAR
EXTRN	__iob:BYTE
EXTRN	_fclose:NEAR
EXTRN	_fgets:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fprintf:NEAR
EXTRN	_fseek:NEAR
EXTRN	_printf:NEAR
EXTRN	_sprintf:NEAR
EXTRN	_exit:NEAR
EXTRN	_calloc:NEAR
EXTRN	_free:NEAR
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_08GIBN@DIFF?4TXT?$AA@
CONST	SEGMENT
??_C@_08GIBN@DIFF?4TXT?$AA@ DB 'DIFF.TXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PBDH@?6MAC?5NDIS?53?40?5Tester?5?9?5Comparato@
CONST	SEGMENT
??_C@_0DH@PBDH@?6MAC?5NDIS?53?40?5Tester?5?9?5Comparato@ DB 0aH, 'MAC NDI'
	DB	'S 3.0 Tester - Comparator Tool Version 1.0.2', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEFE@?9f?$AA@
CONST	SEGMENT
??_C@_02CEFE@?9f?$AA@ DB '-f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HGLE@?9F?$AA@
CONST	SEGMENT
??_C@_02HGLE@?9F?$AA@ DB '-F', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LHO@r?$AA@
CONST	SEGMENT
??_C@_01LHO@r?$AA@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DJPC@Could?5not?5open?5the?5primary?5log?5l@
CONST	SEGMENT
??_C@_0CO@DJPC@Could?5not?5open?5the?5primary?5log?5l@ DB 'Could not open'
	DB	' the primary log list file: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@DPBH@The?5system?5has?5run?5out?5of?5memory@
CONST	SEGMENT
??_C@_0EJ@DPBH@The?5system?5has?5run?5out?5of?5memory@ DB 'The system has'
	DB	' run out of memory resources. Unable to run this program.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@FLEA@An?5error?5occurred?5determining?5th@
CONST	SEGMENT
??_C@_0EN@FLEA@An?5error?5occurred?5determining?5th@ DB 'An error occurre'
	DB	'd determining the file pair at line %d in the file list: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@
CONST	SEGMENT
??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ DB 'The system has'
	DB	' run out of memory resources for this program', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02INOK@w?$CL?$AA@
CONST	SEGMENT
??_C@_02INOK@w?$CL?$AA@ DB 'w+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@EHOB@Unable?5to?5open?5the?5difference?5te@
CONST	SEGMENT
??_C@_0EF@EHOB@Unable?5to?5open?5the?5difference?5te@ DB 'Unable to open '
	DB	'the difference text file %s for logging the results.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JJJH@?6?6?$AA@
CONST	SEGMENT
??_C@_02JJJH@?6?6?$AA@ DB 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LHCE@__________DETAILS_LOG__________?6@
CONST	SEGMENT
??_C@_0CC@LHCE@__________DETAILS_LOG__________?6@ DB '__________DETAILS_L'
	DB	'OG__________', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JHAI@Comparing?5files?5?$CFs?5and?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@JHAI@Comparing?5files?5?$CFs?5and?5?$CFs?6?$AA@ DB 'Comparing f'
	DB	'iles %s and %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NEAI@?6?6?$CK?$CKComparing?5?$CFs?5and?5?$CFs?6?6?$AA@
CONST	SEGMENT
??_C@_0BK@NEAI@?6?6?$CK?$CKComparing?5?$CFs?5and?5?$CFs?6?6?$AA@ DB 0aH, 0aH
	DB	'**Comparing %s and %s', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BCNC@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@
CONST	SEGMENT
??_C@_0CA@BCNC@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@ DB 
	DB	0aH, 0aH, '--TPDIFF %s, %s ERROR(S): %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BFOO@TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@
CONST	SEGMENT
??_C@_0BM@BFOO@TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@ DB 
	DB	'TPDIFF %s, %s ERROR(S): %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IBIK@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BC@IBIK@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?$AA@ DB 0aH, 0aH, '--TPDIFF'
	DB	' %s, %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FMLE@?7Unable?5to?5open?5file?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BJ@FMLE@?7Unable?5to?5open?5file?5?$CFs?6?$AA@ DB 09H, 'Unable to '
	DB	'open file %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LFPA@TPDIFF?5?$CFs?0?5?$CFs?5resulted?5in?5a?5file@
CONST	SEGMENT
??_C@_0CN@LFPA@TPDIFF?5?$CFs?0?5?$CFs?5resulted?5in?5a?5file@ DB 'TPDIFF '
	DB	'%s, %s resulted in a file open error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LOBF@?6__________END_DETAILS_LOG______@
CONST	SEGMENT
??_C@_0CH@LOBF@?6__________END_DETAILS_LOG______@ DB 0aH, '__________END_'
	DB	'DETAILS_LOG__________', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NEJO@?6?6__________SUMMARY_LOG_________@
CONST	SEGMENT
??_C@_0CE@NEJO@?6?6__________SUMMARY_LOG_________@ DB 0aH, 0aH, '________'
	DB	'__SUMMARY_LOG__________', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LCOP@?6__________END_SUMMARY_LOG______@
CONST	SEGMENT
??_C@_0CH@LCOP@?6__________END_SUMMARY_LOG______@ DB 0aH, '__________END_'
	DB	'SUMMARY_LOG__________', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EMG@?6?6__________CUMMALATIVE_RESULTS_@
CONST	SEGMENT
??_C@_0DA@EMG@?6?6__________CUMMALATIVE_RESULTS_@ DB 0aH, 0aH, '_________'
	DB	'_CUMMALATIVE_RESULTS_LOG__________', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LJOK@COMPARED?5?$CFd?5FILE?5PAIR?$CIS?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BK@LJOK@COMPARED?5?$CFd?5FILE?5PAIR?$CIS?$CJ?6?$AA@ DB 'COMPARED %'
	DB	'd FILE PAIR(S)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BCML@TOTAL?5NUMBER?5OF?5DIFFERENCES?5ENCO@
CONST	SEGMENT
??_C@_0CN@BCML@TOTAL?5NUMBER?5OF?5DIFFERENCES?5ENCO@ DB 'TOTAL NUMBER OF '
	DB	'DIFFERENCES ENCOUNTERED: %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DFAD@TOTAL?5NUMBER?5OF?5FILE?5OPEN?5ERRORS@
CONST	SEGMENT
??_C@_0CN@DFAD@TOTAL?5NUMBER?5OF?5FILE?5OPEN?5ERRORS@ DB 'TOTAL NUMBER OF'
	DB	' FILE OPEN ERRORS       : %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EHHI@?6__________END_CUMMALATIVE_RESUL@
CONST	SEGMENT
??_C@_0DD@EHHI@?6__________END_CUMMALATIVE_RESUL@ DB 0aH, '__________END_'
	DB	'CUMMALATIVE_RESULTS_LOG__________', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_argc$ = 8
_argv$ = 12
_IoFile$ = -20
_DiffTxtFile$ = -16
_FileList$ = -4
_Difference_FileName$ = -12
_TmpSummaryBuffer$ = -52
_FirstFile$ = -72
_SecondFile$ = -44
_NumberOfComparisons$ = -28
_NumberOfFilesCompared$ = -56
_i$ = -32
_j$ = -48
_TotalDifferenceCount$ = -60
_InputFromFile$ = -24
_FileOpenErrors$ = -8
_Buffer$8347 = -584
_OldDifferenceCount$8380 = -588
_main	PROC NEAR					; COMDAT

; 75   : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	81 ec 50 02 00
	00		sub	esp, 592		; 00000250H
  00009	53		push	ebx
  0000a	56		push	esi
  0000b	57		push	edi

; 76   : 
; 77   :     FILE         *IoFile;
; 78   :     FILE         *DiffTxtFile;
; 79   :     PCHAR        *FileList = &argv[1];

  0000c	8b 45 0c	mov	eax, DWORD PTR _argv$[ebp]
  0000f	83 c0 04	add	eax, 4
  00012	89 45 fc	mov	DWORD PTR _FileList$[ebp], eax

; 80   :     PCHAR        Difference_FileName = ( argc == 4 ) ? argv[3] : "DIFF.TXT" ;

  00015	83 7d 08 04	cmp	DWORD PTR _argc$[ebp], 4
  00019	0f 85 0e 00 00
	00		jne	$L8922
  0001f	8b 45 0c	mov	eax, DWORD PTR _argv$[ebp]
  00022	8b 40 0c	mov	eax, DWORD PTR [eax+12]
  00025	89 45 f4	mov	DWORD PTR _Difference_FileName$[ebp], eax
  00028	e9 07 00 00 00	jmp	$L8923
$L8922:
  0002d	c7 45 f4 00 00
	00 00		mov	DWORD PTR _Difference_FileName$[ebp], OFFSET FLAT:??_C@_08GIBN@DIFF?4TXT?$AA@ ; `string'
$L8923:

; 81   :     PCHAR        TmpSummaryBuffer;
; 82   :     MFILE        FirstFile, SecondFile;
; 83   :     UINT         NumberOfComparisons = 0      ;

  00034	c7 45 e4 00 00
	00 00		mov	DWORD PTR _NumberOfComparisons$[ebp], 0

; 84   :     UINT         NumberOfFilesCompared = 0;

  0003b	c7 45 c8 00 00
	00 00		mov	DWORD PTR _NumberOfFilesCompared$[ebp], 0

; 85   :     UINT         i,j;
; 86   :     ULONG        TotalDifferenceCount = 0;

  00042	c7 45 c4 00 00
	00 00		mov	DWORD PTR _TotalDifferenceCount$[ebp], 0

; 87   :     BOOL         InputFromFile = FALSE;

  00049	c7 45 e8 00 00
	00 00		mov	DWORD PTR _InputFromFile$[ebp], 0

; 88   :     ULONG        FileOpenErrors = 0;

  00050	c7 45 f8 00 00
	00 00		mov	DWORD PTR _FileOpenErrors$[ebp], 0

; 89   : 
; 90   : 
; 91   :     //
; 92   :     // 1. CHECK INCOMING ARGUMENT SYNTAX
; 93   :     //
; 94   : 
; 95   :     if ( ( argc < 3 ) || ( argc > 4 ) ) {

  00057	83 7d 08 03	cmp	DWORD PTR _argc$[ebp], 3
  0005b	0f 8c 0a 00 00
	00		jl	$L8340
  00061	83 7d 08 04	cmp	DWORD PTR _argc$[ebp], 4
  00065	0f 8e 14 00 00
	00		jle	$L8339
$L8340:

; 96   : 
; 97   :         Usage();

  0006b	e8 00 00 00 00	call	_Usage@0

; 98   :         exit( -1 );

  00070	6a ff		push	-1
  00072	e8 00 00 00 00	call	_exit
  00077	83 c4 04	add	esp, 4

; 99   : 
; 100  :     } else {

  0007a	e9 0d 00 00 00	jmp	$L8341
$L8339:

; 101  : 
; 102  :         printf( "\nMAC NDIS 3.0 Tester - Comparator Tool Version 1.0.2\n\n" );

  0007f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DH@PBDH@?6MAC?5NDIS?53?40?5Tester?5?9?5Comparato@ ; `string'
  00084	e8 00 00 00 00	call	_printf
  00089	83 c4 04	add	esp, 4
$L8341:

; 103  : 
; 104  :     }
; 105  : 
; 106  : 
; 107  :     //
; 108  :     // 2. CHECK IF THE FILE LIST TO BE GENERATED IS TO BE EXTRACTED FROM THE COMMAND
; 109  :     //    LINE OR FROM A FILE
; 110  :     //
; 111  : 
; 112  :     if ( !strncmp( argv[1], "-f", 2 ) ||
; 113  :          !strncmp( argv[1], "-F", 2 )    ) {

  0008c	6a 02		push	2
  0008e	68 00 00 00 00	push	OFFSET FLAT:??_C@_02CEFE@?9f?$AA@ ; `string'
  00093	8b 45 0c	mov	eax, DWORD PTR _argv$[ebp]
  00096	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00099	50		push	eax
  0009a	e8 00 00 00 00	call	_strncmp
  0009f	83 c4 0c	add	esp, 12			; 0000000cH
  000a2	85 c0		test	eax, eax
  000a4	0f 84 1e 00 00
	00		je	$L8344
  000aa	6a 02		push	2
  000ac	68 00 00 00 00	push	OFFSET FLAT:??_C@_02HGLE@?9F?$AA@ ; `string'
  000b1	8b 45 0c	mov	eax, DWORD PTR _argv$[ebp]
  000b4	8b 40 04	mov	eax, DWORD PTR [eax+4]
  000b7	50		push	eax
  000b8	e8 00 00 00 00	call	_strncmp
  000bd	83 c4 0c	add	esp, 12			; 0000000cH
  000c0	85 c0		test	eax, eax
  000c2	0f 85 07 02 00
	00		jne	$L8343
$L8344:

; 114  : 
; 115  :         CHAR    Buffer[2*MAX_LINE_SIZE];
; 116  : 
; 117  :         //
; 118  :         // 2.A INDICATE THE LIST IS TO BE GENERATED FROM A FILE
; 119  :         //
; 120  :         InputFromFile = TRUE;

  000c8	c7 45 e8 01 00
	00 00		mov	DWORD PTR _InputFromFile$[ebp], 1

; 121  : 
; 122  : 
; 123  :         //
; 124  :         // 2.B OPEN THE FILE
; 125  :         //
; 126  : 
; 127  :         if ( (IoFile = fopen( argv[2], "r" )) == NULL ) {

  000cf	68 00 00 00 00	push	OFFSET FLAT:??_C@_01LHO@r?$AA@ ; `string'
  000d4	8b 45 0c	mov	eax, DWORD PTR _argv$[ebp]
  000d7	8b 40 08	mov	eax, DWORD PTR [eax+8]
  000da	50		push	eax
  000db	e8 00 00 00 00	call	_fopen
  000e0	83 c4 08	add	esp, 8
  000e3	89 45 ec	mov	DWORD PTR _IoFile$[ebp], eax
  000e6	83 7d ec 00	cmp	DWORD PTR _IoFile$[ebp], 0
  000ea	0f 85 23 00 00
	00		jne	$L8348

; 128  : 
; 129  :             printf( "Could not open the primary log list file: %s\n", argv[2] );

  000f0	8b 45 0c	mov	eax, DWORD PTR _argv$[ebp]
  000f3	8b 40 08	mov	eax, DWORD PTR [eax+8]
  000f6	50		push	eax
  000f7	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CO@DJPC@Could?5not?5open?5the?5primary?5log?5l@ ; `string'
  000fc	e8 00 00 00 00	call	_printf
  00101	83 c4 08	add	esp, 8

; 130  :             Usage();

  00104	e8 00 00 00 00	call	_Usage@0

; 131  :             exit( -1 );

  00109	6a ff		push	-1
  0010b	e8 00 00 00 00	call	_exit
  00110	83 c4 04	add	esp, 4
$L8348:
$L8352:

; 132  : 
; 133  :         }
; 134  : 
; 135  : 
; 136  :         //
; 137  :         // 2.C GENERATE THE FILE PAIRS TO BE ANALYZED
; 138  :         //
; 139  : 
; 140  :         //
; 141  :         // 2.C.1 DETERMINE THE NUMBER OF VALID FILE PAIRS
; 142  :         //
; 143  : 
; 144  :         while( !feof( IoFile ) ) {

  00113	8b 45 ec	mov	eax, DWORD PTR _IoFile$[ebp]
  00116	f6 40 0c 10	test	BYTE PTR [eax+12], 16	; 00000010H
  0011a	0f 85 56 00 00
	00		jne	$L8353

; 145  : 
; 146  :             memset( Buffer, 0, sizeof(Buffer) );

  00120	68 00 02 00 00	push	512			; 00000200H
  00125	6a 00		push	0
  00127	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  0012d	50		push	eax
  0012e	e8 00 00 00 00	call	_memset
  00133	83 c4 0c	add	esp, 12			; 0000000cH

; 147  :             if ( ( fgets( Buffer, sizeof( Buffer ), IoFile ) != NULL ) &&
; 148  :                  ( strlen( Buffer ) > 2 ) ) {

  00136	8b 45 ec	mov	eax, DWORD PTR _IoFile$[ebp]
  00139	50		push	eax
  0013a	68 00 02 00 00	push	512			; 00000200H
  0013f	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  00145	50		push	eax
  00146	e8 00 00 00 00	call	_fgets
  0014b	83 c4 0c	add	esp, 12			; 0000000cH
  0014e	85 c0		test	eax, eax
  00150	0f 84 1b 00 00
	00		je	$L8354
  00156	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  0015c	50		push	eax
  0015d	e8 00 00 00 00	call	_strlen
  00162	83 c4 04	add	esp, 4
  00165	83 f8 02	cmp	eax, 2
  00168	0f 86 03 00 00
	00		jbe	$L8354

; 149  :                 NumberOfComparisons++;

  0016e	ff 45 e4	inc	DWORD PTR _NumberOfComparisons$[ebp]
$L8354:

; 150  :             }
; 151  : 
; 152  :         }

  00171	e9 9d ff ff ff	jmp	$L8352
$L8353:

; 153  : 
; 154  : 
; 155  :         //
; 156  :         // 2.C.2 ALLOCATE THE APPROPRIATE SIZED BLOCK
; 157  :         //
; 158  : 
; 159  :         FileList = (PCHAR *)malloc( (NumberOfComparisons*2)*sizeof( PCHAR ) );

  00176	8b 45 e4	mov	eax, DWORD PTR _NumberOfComparisons$[ebp]
  00179	c1 e0 03	shl	eax, 3
  0017c	50		push	eax
  0017d	e8 00 00 00 00	call	_malloc
  00182	83 c4 04	add	esp, 4
  00185	89 45 fc	mov	DWORD PTR _FileList$[ebp], eax

; 160  :         if ( FileList == (PCHAR *)NULL ) {

  00188	83 7d fc 00	cmp	DWORD PTR _FileList$[ebp], 0
  0018c	0f 85 1c 00 00
	00		jne	$L8355

; 161  :             printf("The system has run out of memory resources. Unable to run this program.\n");

  00192	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EJ@DPBH@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  00197	e8 00 00 00 00	call	_printf
  0019c	83 c4 04	add	esp, 4

; 162  :             exit( -1 );

  0019f	6a ff		push	-1
  001a1	e8 00 00 00 00	call	_exit
  001a6	83 c4 04	add	esp, 4

; 163  :         } else {

  001a9	e9 15 00 00 00	jmp	$L8357
$L8355:

; 164  :             memset( FileList, 0, (NumberOfComparisons*2)*sizeof( PCHAR ) );

  001ae	8b 45 e4	mov	eax, DWORD PTR _NumberOfComparisons$[ebp]
  001b1	c1 e0 03	shl	eax, 3
  001b4	50		push	eax
  001b5	6a 00		push	0
  001b7	8b 45 fc	mov	eax, DWORD PTR _FileList$[ebp]
  001ba	50		push	eax
  001bb	e8 00 00 00 00	call	_memset
  001c0	83 c4 0c	add	esp, 12			; 0000000cH
$L8357:

; 165  :         }
; 166  : 
; 167  : 
; 168  :         //
; 169  :         // 2.C.2 AND BUILD THE FILE ARRAY LIST
; 170  :         //
; 171  : 
; 172  :         i = j = 0;

  001c3	c7 45 d0 00 00
	00 00		mov	DWORD PTR _j$[ebp], 0
  001ca	8b 45 d0	mov	eax, DWORD PTR _j$[ebp]
  001cd	89 45 e0	mov	DWORD PTR _i$[ebp], eax

; 173  :         fseek( IoFile, 0, SEEK_SET );

  001d0	6a 00		push	0
  001d2	6a 00		push	0
  001d4	8b 45 ec	mov	eax, DWORD PTR _IoFile$[ebp]
  001d7	50		push	eax
  001d8	e8 00 00 00 00	call	_fseek
  001dd	83 c4 0c	add	esp, 12			; 0000000cH
$L8359:

; 174  :         while ( !feof( IoFile ) ) {

  001e0	8b 45 ec	mov	eax, DWORD PTR _IoFile$[ebp]
  001e3	f6 40 0c 10	test	BYTE PTR [eax+12], 16	; 00000010H
  001e7	0f 85 d1 00 00
	00		jne	$L8360

; 175  : 
; 176  :             //
; 177  :             // Get the next line out of the file list file
; 178  :             //
; 179  :             memset( Buffer, 0, sizeof(Buffer) );

  001ed	68 00 02 00 00	push	512			; 00000200H
  001f2	6a 00		push	0
  001f4	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  001fa	50		push	eax
  001fb	e8 00 00 00 00	call	_memset
  00200	83 c4 0c	add	esp, 12			; 0000000cH

; 180  :             if ( ( fgets( Buffer, sizeof( Buffer ), IoFile ) != NULL ) &&
; 181  :                  ( strlen( Buffer ) > 2 ) ) {

  00203	8b 45 ec	mov	eax, DWORD PTR _IoFile$[ebp]
  00206	50		push	eax
  00207	68 00 02 00 00	push	512			; 00000200H
  0020c	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  00212	50		push	eax
  00213	e8 00 00 00 00	call	_fgets
  00218	83 c4 0c	add	esp, 12			; 0000000cH
  0021b	85 c0		test	eax, eax
  0021d	0f 84 93 00 00
	00		je	$L8361
  00223	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  00229	50		push	eax
  0022a	e8 00 00 00 00	call	_strlen
  0022f	83 c4 04	add	esp, 4
  00232	83 f8 02	cmp	eax, 2
  00235	0f 86 7b 00 00
	00		jbe	$L8361

; 182  : 
; 183  :                 //
; 184  :                 // Replace the newline Character with a NULL Character
; 185  :                 //
; 186  :                 *(strchr( Buffer, '\n')) = '\0';

  0023b	6a 0a		push	10			; 0000000aH
  0023d	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  00243	50		push	eax
  00244	e8 00 00 00 00	call	_strchr
  00249	83 c4 08	add	esp, 8
  0024c	89 85 b0 fd ff
	ff		mov	DWORD PTR -592+[ebp], eax
  00252	8b 85 b0 fd ff
	ff		mov	eax, DWORD PTR -592+[ebp]
  00258	c6 00 00	mov	BYTE PTR [eax], 0

; 187  : 
; 188  :                 //
; 189  :                 // Extract the log file name pairs
; 190  :                 //
; 191  :                 if ( !GetFilePair( &FileList[j*2], &FileList[(j*2)+1], Buffer ) ) {

  0025b	8d 85 b8 fd ff
	ff		lea	eax, DWORD PTR _Buffer$8347[ebp]
  00261	50		push	eax
  00262	8b 45 d0	mov	eax, DWORD PTR _j$[ebp]
  00265	8d 04 c5 04 00
	00 00		lea	eax, DWORD PTR [eax*8+4]
  0026c	03 45 fc	add	eax, DWORD PTR _FileList$[ebp]
  0026f	50		push	eax
  00270	8b 45 d0	mov	eax, DWORD PTR _j$[ebp]
  00273	c1 e0 03	shl	eax, 3
  00276	03 45 fc	add	eax, DWORD PTR _FileList$[ebp]
  00279	50		push	eax
  0027a	e8 00 00 00 00	call	_GetFilePair@12
  0027f	33 c9		xor	ecx, ecx
  00281	8a c8		mov	cl, al
  00283	85 c9		test	ecx, ecx
  00285	0f 85 28 00 00
	00		jne	$L8362

; 192  : 
; 193  :                     printf("An error occurred determining the file pair at line %d in the file list: %s\n",
; 194  :                            (i+1), argv[2] );

  0028b	8b 45 0c	mov	eax, DWORD PTR _argv$[ebp]
  0028e	8b 40 08	mov	eax, DWORD PTR [eax+8]
  00291	50		push	eax
  00292	8b 45 e0	mov	eax, DWORD PTR _i$[ebp]
  00295	40		inc	eax
  00296	50		push	eax
  00297	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EN@FLEA@An?5error?5occurred?5determining?5th@ ; `string'
  0029c	e8 00 00 00 00	call	_printf
  002a1	83 c4 0c	add	esp, 12			; 0000000cH

; 195  :                     exit( -1 );

  002a4	6a ff		push	-1
  002a6	e8 00 00 00 00	call	_exit
  002ab	83 c4 04	add	esp, 4

; 196  : 
; 197  :                 } else {

  002ae	e9 03 00 00 00	jmp	$L8364
$L8362:

; 198  : 
; 199  :                     //
; 200  :                     // Increment the file list array counter
; 201  :                     //
; 202  :                     j++;

  002b3	ff 45 d0	inc	DWORD PTR _j$[ebp]
$L8364:
$L8361:

; 203  : 
; 204  :                 }
; 205  : 
; 206  :             }
; 207  : 
; 208  :             //
; 209  :             // Increment the file line counter
; 210  :             //
; 211  :             i++;

  002b6	ff 45 e0	inc	DWORD PTR _i$[ebp]

; 212  : 
; 213  :         }

  002b9	e9 22 ff ff ff	jmp	$L8359
$L8360:

; 214  : 
; 215  : 
; 216  :         //
; 217  :         // 2.C.3 CLOSE THE FILE
; 218  :         //
; 219  :         fclose( IoFile );

  002be	8b 45 ec	mov	eax, DWORD PTR _IoFile$[ebp]
  002c1	50		push	eax
  002c2	e8 00 00 00 00	call	_fclose
  002c7	83 c4 04	add	esp, 4

; 220  : 
; 221  : 
; 222  :     } else {

  002ca	e9 07 00 00 00	jmp	$L8365
$L8343:

; 223  : 
; 224  :         NumberOfComparisons = 1;

  002cf	c7 45 e4 01 00
	00 00		mov	DWORD PTR _NumberOfComparisons$[ebp], 1
$L8365:

; 225  : 
; 226  :         //
; 227  :         // The FileList is pre-initialized to the command line arguments and thus we
; 228  :         // simply need to set the file pair comparison count
; 229  :         //
; 230  : 
; 231  :     }
; 232  : 
; 233  : 
; 234  :     //
; 235  :     // 3. INITIALIZE THE SUMMARY BUFFER
; 236  :     //
; 237  :     SummaryBuffer = calloc( NumberOfComparisons, MAX_LINE_SIZE );

  002d6	68 00 01 00 00	push	256			; 00000100H
  002db	8b 45 e4	mov	eax, DWORD PTR _NumberOfComparisons$[ebp]
  002de	50		push	eax
  002df	e8 00 00 00 00	call	_calloc
  002e4	83 c4 08	add	esp, 8
  002e7	a3 00 00 00 00	mov	DWORD PTR _SummaryBuffer, eax

; 238  :     if ( SummaryBuffer == (PCHAR)NULL ) {

  002ec	83 3d 00 00 00
	00 00		cmp	DWORD PTR _SummaryBuffer, 0
  002f3	0f 85 1c 00 00
	00		jne	$L8366

; 239  : 
; 240  :         printf("The system has run out of memory resources for this program\n");

  002f9	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  002fe	e8 00 00 00 00	call	_printf
  00303	83 c4 04	add	esp, 4

; 241  :         exit( -1 );

  00306	6a ff		push	-1
  00308	e8 00 00 00 00	call	_exit
  0030d	83 c4 04	add	esp, 4

; 242  : 
; 243  :     } else {

  00310	e9 08 00 00 00	jmp	$L8368
$L8366:

; 244  : 
; 245  :         TmpSummaryBuffer = SummaryBuffer ;

  00315	a1 00 00 00 00	mov	eax, DWORD PTR _SummaryBuffer
  0031a	89 45 cc	mov	DWORD PTR _TmpSummaryBuffer$[ebp], eax
$L8368:

; 246  : 
; 247  :     }
; 248  : 
; 249  :     //
; 250  :     // 4. OBTAIN THE DIFFERENCE FILE NAME INTO WHICH THE RESULTS WILL BE LOGGED
; 251  :     //    OR USE THE DEFAULT DIFF.TXT.
; 252  :     //
; 253  : 
; 254  :     DiffTxtFile    = fopen( Difference_FileName, "w+" );

  0031d	68 00 00 00 00	push	OFFSET FLAT:??_C@_02INOK@w?$CL?$AA@ ; `string'
  00322	8b 45 f4	mov	eax, DWORD PTR _Difference_FileName$[ebp]
  00325	50		push	eax
  00326	e8 00 00 00 00	call	_fopen
  0032b	83 c4 08	add	esp, 8
  0032e	89 45 f0	mov	DWORD PTR _DiffTxtFile$[ebp], eax

; 255  : 
; 256  :     if ( DiffTxtFile == (FILE *)NULL ) {

  00331	83 7d f0 00	cmp	DWORD PTR _DiffTxtFile$[ebp], 0
  00335	0f 85 20 00 00
	00		jne	$L8370

; 257  : 
; 258  :         printf( "Unable to open the difference text file %s for logging the results.\n", Difference_FileName );

  0033b	8b 45 f4	mov	eax, DWORD PTR _Difference_FileName$[ebp]
  0033e	50		push	eax
  0033f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EF@EHOB@Unable?5to?5open?5the?5difference?5te@ ; `string'
  00344	e8 00 00 00 00	call	_printf
  00349	83 c4 08	add	esp, 8

; 259  :         exit( -1 );

  0034c	6a ff		push	-1
  0034e	e8 00 00 00 00	call	_exit
  00353	83 c4 04	add	esp, 4

; 260  : 
; 261  :     } else {

  00356	e9 11 00 00 00	jmp	$L8372
$L8370:

; 262  : 
; 263  :         fprintf( DiffTxtFile, "\n\n" );

  0035b	68 00 00 00 00	push	OFFSET FLAT:??_C@_02JJJH@?6?6?$AA@ ; `string'
  00360	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  00363	50		push	eax
  00364	e8 00 00 00 00	call	_fprintf
  00369	83 c4 08	add	esp, 8
$L8372:

; 264  : 
; 265  :     }
; 266  : 
; 267  : 
; 268  :     //
; 269  :     // 5. COMPARE THE FILE PAIRS
; 270  :     //
; 271  : 
; 272  :     fprintf( DiffTxtFile, "__________DETAILS_LOG__________\n\n" );

  0036c	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CC@LHCE@__________DETAILS_LOG__________?6@ ; `string'
  00371	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  00374	50		push	eax
  00375	e8 00 00 00 00	call	_fprintf
  0037a	83 c4 08	add	esp, 8

; 273  :     fprintf( stdout, "__________DETAILS_LOG__________\n\n" );

  0037d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CC@LHCE@__________DETAILS_LOG__________?6@ ; `string'
  00382	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  00387	83 c0 20	add	eax, 32			; 00000020H
  0038a	50		push	eax
  0038b	e8 00 00 00 00	call	_fprintf
  00390	83 c4 08	add	esp, 8

; 274  :     for( i = 0; i < NumberOfComparisons; i++ ) {

  00393	c7 45 e0 00 00
	00 00		mov	DWORD PTR _i$[ebp], 0
  0039a	e9 03 00 00 00	jmp	$L8375
$L8376:
  0039f	ff 45 e0	inc	DWORD PTR _i$[ebp]
$L8375:
  003a2	8b 45 e4	mov	eax, DWORD PTR _NumberOfComparisons$[ebp]
  003a5	39 45 e0	cmp	DWORD PTR _i$[ebp], eax
  003a8	0f 83 0d 02 00
	00		jae	$L8377

; 275  : 
; 276  :         memset( &FirstFile , 0, sizeof( MFILE ) );

  003ae	6a 0c		push	12			; 0000000cH
  003b0	6a 00		push	0
  003b2	8d 45 b8	lea	eax, DWORD PTR _FirstFile$[ebp]
  003b5	50		push	eax
  003b6	e8 00 00 00 00	call	_memset
  003bb	83 c4 0c	add	esp, 12			; 0000000cH

; 277  :         memset( &SecondFile, 0, sizeof( MFILE ) );

  003be	6a 0c		push	12			; 0000000cH
  003c0	6a 00		push	0
  003c2	8d 45 d4	lea	eax, DWORD PTR _SecondFile$[ebp]
  003c5	50		push	eax
  003c6	e8 00 00 00 00	call	_memset
  003cb	83 c4 0c	add	esp, 12			; 0000000cH

; 278  : 
; 279  :         FirstFile.FileName  = FileList[2*i];

  003ce	8b 45 e0	mov	eax, DWORD PTR _i$[ebp]
  003d1	8b 4d fc	mov	ecx, DWORD PTR _FileList$[ebp]
  003d4	8b 04 c1	mov	eax, DWORD PTR [ecx+eax*8]
  003d7	89 45 bc	mov	DWORD PTR _FirstFile$[ebp+4], eax

; 280  :         SecondFile.FileName = FileList[(2*i)+1];

  003da	8b 45 e0	mov	eax, DWORD PTR _i$[ebp]
  003dd	8b 4d fc	mov	ecx, DWORD PTR _FileList$[ebp]
  003e0	8b 44 c1 04	mov	eax, DWORD PTR [ecx+eax*8+4]
  003e4	89 45 d8	mov	DWORD PTR _SecondFile$[ebp+4], eax

; 281  : 
; 282  :         fprintf( stdout, "Comparing files %s and %s\n",  FirstFile.FileName, SecondFile.FileName );

  003e7	8b 45 d8	mov	eax, DWORD PTR _SecondFile$[ebp+4]
  003ea	50		push	eax
  003eb	8b 45 bc	mov	eax, DWORD PTR _FirstFile$[ebp+4]
  003ee	50		push	eax
  003ef	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BL@JHAI@Comparing?5files?5?$CFs?5and?5?$CFs?6?$AA@ ; `string'
  003f4	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  003f9	83 c0 20	add	eax, 32			; 00000020H
  003fc	50		push	eax
  003fd	e8 00 00 00 00	call	_fprintf
  00402	83 c4 10	add	esp, 16			; 00000010H

; 283  : 
; 284  :         //
; 285  :         // 5.A OPEN THE FILE PAIR
; 286  :         //
; 287  :         if ( OpenFiles( &FirstFile, FileList[2*i], &SecondFile, FileList[(2*i)+1] ) ) {

  00405	8b 45 e0	mov	eax, DWORD PTR _i$[ebp]
  00408	8b 4d fc	mov	ecx, DWORD PTR _FileList$[ebp]
  0040b	8b 44 c1 04	mov	eax, DWORD PTR [ecx+eax*8+4]
  0040f	50		push	eax
  00410	8d 45 d4	lea	eax, DWORD PTR _SecondFile$[ebp]
  00413	50		push	eax
  00414	8b 45 e0	mov	eax, DWORD PTR _i$[ebp]
  00417	8b 4d fc	mov	ecx, DWORD PTR _FileList$[ebp]
  0041a	8b 04 c1	mov	eax, DWORD PTR [ecx+eax*8]
  0041d	50		push	eax
  0041e	8d 45 b8	lea	eax, DWORD PTR _FirstFile$[ebp]
  00421	50		push	eax
  00422	e8 00 00 00 00	call	_OpenFiles@16
  00427	33 c9		xor	ecx, ecx
  00429	8a c8		mov	cl, al
  0042b	85 c9		test	ecx, ecx
  0042d	0f 84 94 00 00
	00		je	$L8379

; 288  : 
; 289  :             ULONG OldDifferenceCount = TotalDifferenceCount;

  00433	8b 45 c4	mov	eax, DWORD PTR _TotalDifferenceCount$[ebp]
  00436	89 85 b4 fd ff
	ff		mov	DWORD PTR _OldDifferenceCount$8380[ebp], eax

; 290  : 
; 291  :             fprintf( DiffTxtFile, "\n\n**Comparing %s and %s\n\n", FirstFile.FileName, SecondFile.FileName );

  0043c	8b 45 d8	mov	eax, DWORD PTR _SecondFile$[ebp+4]
  0043f	50		push	eax
  00440	8b 45 bc	mov	eax, DWORD PTR _FirstFile$[ebp+4]
  00443	50		push	eax
  00444	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BK@NEAI@?6?6?$CK?$CKComparing?5?$CFs?5and?5?$CFs?6?6?$AA@ ; `string'
  00449	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  0044c	50		push	eax
  0044d	e8 00 00 00 00	call	_fprintf
  00452	83 c4 10	add	esp, 16			; 00000010H

; 292  : 
; 293  :             NumberOfFilesCompared++;

  00455	ff 45 c8	inc	DWORD PTR _NumberOfFilesCompared$[ebp]

; 294  : 
; 295  : 
; 296  :             //
; 297  :             // 5.B COMPARE THEM
; 298  :             //
; 299  :             CompareFiles( &FirstFile, &SecondFile, DiffTxtFile, &TotalDifferenceCount );

  00458	8d 45 c4	lea	eax, DWORD PTR _TotalDifferenceCount$[ebp]
  0045b	50		push	eax
  0045c	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  0045f	50		push	eax
  00460	8d 45 d4	lea	eax, DWORD PTR _SecondFile$[ebp]
  00463	50		push	eax
  00464	8d 45 b8	lea	eax, DWORD PTR _FirstFile$[ebp]
  00467	50		push	eax
  00468	e8 00 00 00 00	call	_CompareFiles@16

; 300  : 
; 301  : 
; 302  :             //
; 303  :             // 5.C LOG THE RESULTS OF THE COMPARISON INTO THE DIFFERENCE FILE
; 304  :             //
; 305  :             fprintf( DiffTxtFile, "\n\n--TPDIFF %s, %s ERROR(S): %u\n",
; 306  :                      FirstFile.FileName, SecondFile.FileName, (TotalDifferenceCount-OldDifferenceCount) );

  0046d	8b 45 c4	mov	eax, DWORD PTR _TotalDifferenceCount$[ebp]
  00470	2b 85 b4 fd ff
	ff		sub	eax, DWORD PTR _OldDifferenceCount$8380[ebp]
  00476	50		push	eax
  00477	8b 45 d8	mov	eax, DWORD PTR _SecondFile$[ebp+4]
  0047a	50		push	eax
  0047b	8b 45 bc	mov	eax, DWORD PTR _FirstFile$[ebp+4]
  0047e	50		push	eax
  0047f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CA@BCNC@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@ ; `string'
  00484	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  00487	50		push	eax
  00488	e8 00 00 00 00	call	_fprintf
  0048d	83 c4 14	add	esp, 20			; 00000014H

; 307  : 
; 308  :             sprintf( TmpSummaryBuffer, "TPDIFF %s, %s ERROR(S): %u\n",
; 309  :                      FirstFile.FileName, SecondFile.FileName, (TotalDifferenceCount-OldDifferenceCount) );

  00490	8b 45 c4	mov	eax, DWORD PTR _TotalDifferenceCount$[ebp]
  00493	2b 85 b4 fd ff
	ff		sub	eax, DWORD PTR _OldDifferenceCount$8380[ebp]
  00499	50		push	eax
  0049a	8b 45 d8	mov	eax, DWORD PTR _SecondFile$[ebp+4]
  0049d	50		push	eax
  0049e	8b 45 bc	mov	eax, DWORD PTR _FirstFile$[ebp+4]
  004a1	50		push	eax
  004a2	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BM@BFOO@TPDIFF?5?$CFs?0?5?$CFs?5ERROR?$CIS?$CJ?3?5?$CFu?6?$AA@ ; `string'
  004a7	8b 45 cc	mov	eax, DWORD PTR _TmpSummaryBuffer$[ebp]
  004aa	50		push	eax
  004ab	e8 00 00 00 00	call	_sprintf
  004b0	83 c4 14	add	esp, 20			; 00000014H

; 310  :             TmpSummaryBuffer += strlen( TmpSummaryBuffer );

  004b3	8b 45 cc	mov	eax, DWORD PTR _TmpSummaryBuffer$[ebp]
  004b6	50		push	eax
  004b7	e8 00 00 00 00	call	_strlen
  004bc	83 c4 04	add	esp, 4
  004bf	01 45 cc	add	DWORD PTR _TmpSummaryBuffer$[ebp], eax

; 311  : 
; 312  : 
; 313  :         } else {

  004c2	e9 82 00 00 00	jmp	$L8384
$L8379:

; 314  : 
; 315  : 
; 316  :             fprintf( DiffTxtFile, "\n\n--TPDIFF %s, %s", FirstFile.FileName, SecondFile.FileName );

  004c7	8b 45 d8	mov	eax, DWORD PTR _SecondFile$[ebp+4]
  004ca	50		push	eax
  004cb	8b 45 bc	mov	eax, DWORD PTR _FirstFile$[ebp+4]
  004ce	50		push	eax
  004cf	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BC@IBIK@?6?6?9?9TPDIFF?5?$CFs?0?5?$CFs?$AA@ ; `string'
  004d4	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  004d7	50		push	eax
  004d8	e8 00 00 00 00	call	_fprintf
  004dd	83 c4 10	add	esp, 16			; 00000010H

; 317  : 
; 318  :             if ( FirstFile.FileP  == (FILE *)NULL ) {

  004e0	83 7d c0 00	cmp	DWORD PTR _FirstFile$[ebp+8], 0
  004e4	0f 85 15 00 00
	00		jne	$L8386

; 319  : 
; 320  :                 fprintf( DiffTxtFile, "\tUnable to open file %s\n", FirstFile.FileName );

  004ea	8b 45 bc	mov	eax, DWORD PTR _FirstFile$[ebp+4]
  004ed	50		push	eax
  004ee	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BJ@FMLE@?7Unable?5to?5open?5file?5?$CFs?6?$AA@ ; `string'
  004f3	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  004f6	50		push	eax
  004f7	e8 00 00 00 00	call	_fprintf
  004fc	83 c4 0c	add	esp, 12			; 0000000cH
$L8386:

; 321  : 
; 322  :             }
; 323  : 
; 324  :             if ( SecondFile.FileP == (FILE *)NULL ) {

  004ff	83 7d dc 00	cmp	DWORD PTR _SecondFile$[ebp+8], 0
  00503	0f 85 15 00 00
	00		jne	$L8388

; 325  : 
; 326  :                 fprintf( DiffTxtFile, "\tUnable to open file %s\n", SecondFile.FileName );

  00509	8b 45 d8	mov	eax, DWORD PTR _SecondFile$[ebp+4]
  0050c	50		push	eax
  0050d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BJ@FMLE@?7Unable?5to?5open?5file?5?$CFs?6?$AA@ ; `string'
  00512	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  00515	50		push	eax
  00516	e8 00 00 00 00	call	_fprintf
  0051b	83 c4 0c	add	esp, 12			; 0000000cH
$L8388:

; 327  : 
; 328  :             }
; 329  : 
; 330  : 
; 331  :             sprintf( TmpSummaryBuffer, "TPDIFF %s, %s resulted in a file open error\n",
; 332  :                      FirstFile.FileName, SecondFile.FileName );

  0051e	8b 45 d8	mov	eax, DWORD PTR _SecondFile$[ebp+4]
  00521	50		push	eax
  00522	8b 45 bc	mov	eax, DWORD PTR _FirstFile$[ebp+4]
  00525	50		push	eax
  00526	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CN@LFPA@TPDIFF?5?$CFs?0?5?$CFs?5resulted?5in?5a?5file@ ; `string'
  0052b	8b 45 cc	mov	eax, DWORD PTR _TmpSummaryBuffer$[ebp]
  0052e	50		push	eax
  0052f	e8 00 00 00 00	call	_sprintf
  00534	83 c4 10	add	esp, 16			; 00000010H

; 333  : 
; 334  :             FileOpenErrors++;

  00537	ff 45 f8	inc	DWORD PTR _FileOpenErrors$[ebp]

; 335  : 
; 336  :             TmpSummaryBuffer += strlen( TmpSummaryBuffer );

  0053a	8b 45 cc	mov	eax, DWORD PTR _TmpSummaryBuffer$[ebp]
  0053d	50		push	eax
  0053e	e8 00 00 00 00	call	_strlen
  00543	83 c4 04	add	esp, 4
  00546	01 45 cc	add	DWORD PTR _TmpSummaryBuffer$[ebp], eax
$L8384:

; 337  : 
; 338  :         }
; 339  : 
; 340  :         //
; 341  :         // 5.D CLOSE THE FILE PAIR
; 342  :         //
; 343  :         CloseFiles( FirstFile, SecondFile );

  00549	83 7d c0 00	cmp	DWORD PTR _FirstFile$[ebp+8], 0
  0054d	0f 84 0c 00 00
	00		je	$L8390
  00553	8b 45 c0	mov	eax, DWORD PTR _FirstFile$[ebp+8]
  00556	50		push	eax
  00557	e8 00 00 00 00	call	_fclose
  0055c	83 c4 04	add	esp, 4
$L8390:
  0055f	83 7d dc 00	cmp	DWORD PTR _SecondFile$[ebp+8], 0
  00563	0f 84 0c 00 00
	00		je	$L8391
  00569	8b 45 dc	mov	eax, DWORD PTR _SecondFile$[ebp+8]
  0056c	50		push	eax
  0056d	e8 00 00 00 00	call	_fclose
  00572	83 c4 04	add	esp, 4
$L8391:

; 344  :         FirstFile.FileName  = (PCHAR)NULL;

  00575	c7 45 bc 00 00
	00 00		mov	DWORD PTR _FirstFile$[ebp+4], 0

; 345  :         SecondFile.FileName = (PCHAR)NULL;

  0057c	c7 45 d8 00 00
	00 00		mov	DWORD PTR _SecondFile$[ebp+4], 0

; 346  :         FirstFile.FileP     = (FILE *)NULL;

  00583	c7 45 c0 00 00
	00 00		mov	DWORD PTR _FirstFile$[ebp+8], 0

; 347  :         SecondFile.FileP    = (FILE *)NULL;

  0058a	c7 45 dc 00 00
	00 00		mov	DWORD PTR _SecondFile$[ebp+8], 0

; 348  : 
; 349  :         //
; 350  :         // 5.E FREE THE FILE PAIR FROM THE LIST
; 351  :         //
; 352  :         free( FileList[2*i]     );

  00591	8b 45 e0	mov	eax, DWORD PTR _i$[ebp]
  00594	8b 4d fc	mov	ecx, DWORD PTR _FileList$[ebp]
  00597	8b 04 c1	mov	eax, DWORD PTR [ecx+eax*8]
  0059a	50		push	eax
  0059b	e8 00 00 00 00	call	_free
  005a0	83 c4 04	add	esp, 4

; 353  :         free( FileList[(2*i)+1] );

  005a3	8b 45 e0	mov	eax, DWORD PTR _i$[ebp]
  005a6	8b 4d fc	mov	ecx, DWORD PTR _FileList$[ebp]
  005a9	8b 44 c1 04	mov	eax, DWORD PTR [ecx+eax*8+4]
  005ad	50		push	eax
  005ae	e8 00 00 00 00	call	_free
  005b3	83 c4 04	add	esp, 4

; 354  : 
; 355  : 
; 356  :     }

  005b6	e9 e4 fd ff ff	jmp	$L8376
$L8377:

; 357  :     fprintf( DiffTxtFile, "\n__________END_DETAILS_LOG__________\n\n" );

  005bb	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CH@LOBF@?6__________END_DETAILS_LOG______@ ; `string'
  005c0	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  005c3	50		push	eax
  005c4	e8 00 00 00 00	call	_fprintf
  005c9	83 c4 08	add	esp, 8

; 358  :     fprintf( stdout, "\n__________END_DETAILS_LOG__________\n\n" );

  005cc	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CH@LOBF@?6__________END_DETAILS_LOG______@ ; `string'
  005d1	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  005d6	83 c0 20	add	eax, 32			; 00000020H
  005d9	50		push	eax
  005da	e8 00 00 00 00	call	_fprintf
  005df	83 c4 08	add	esp, 8

; 359  : 
; 360  :     //
; 361  :     // 6. LOG THE CUMMULATIVE RESULTS AND SUMMARY INTO THE DIFFERENCE FILE AND STDOUT
; 362  :     //
; 363  : 
; 364  :     fprintf( DiffTxtFile, "\n\n__________SUMMARY_LOG__________\n\n" );

  005e2	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CE@NEJO@?6?6__________SUMMARY_LOG_________@ ; `string'
  005e7	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  005ea	50		push	eax
  005eb	e8 00 00 00 00	call	_fprintf
  005f0	83 c4 08	add	esp, 8

; 365  :     fprintf( DiffTxtFile, SummaryBuffer );

  005f3	a1 00 00 00 00	mov	eax, DWORD PTR _SummaryBuffer
  005f8	50		push	eax
  005f9	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  005fc	50		push	eax
  005fd	e8 00 00 00 00	call	_fprintf
  00602	83 c4 08	add	esp, 8

; 366  :     fprintf( DiffTxtFile, "\n__________END_SUMMARY_LOG__________\n\n" );

  00605	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CH@LCOP@?6__________END_SUMMARY_LOG______@ ; `string'
  0060a	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  0060d	50		push	eax
  0060e	e8 00 00 00 00	call	_fprintf
  00613	83 c4 08	add	esp, 8

; 367  :     fprintf( DiffTxtFile, "\n\n__________CUMMALATIVE_RESULTS_LOG__________\n\n" );

  00616	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DA@EMG@?6?6__________CUMMALATIVE_RESULTS_@ ; `string'
  0061b	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  0061e	50		push	eax
  0061f	e8 00 00 00 00	call	_fprintf
  00624	83 c4 08	add	esp, 8

; 368  :     fprintf( DiffTxtFile, "COMPARED %d FILE PAIR(S)\n" , NumberOfFilesCompared );

  00627	8b 45 c8	mov	eax, DWORD PTR _NumberOfFilesCompared$[ebp]
  0062a	50		push	eax
  0062b	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BK@LJOK@COMPARED?5?$CFd?5FILE?5PAIR?$CIS?$CJ?6?$AA@ ; `string'
  00630	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  00633	50		push	eax
  00634	e8 00 00 00 00	call	_fprintf
  00639	83 c4 0c	add	esp, 12			; 0000000cH

; 369  :     fprintf( DiffTxtFile, "TOTAL NUMBER OF DIFFERENCES ENCOUNTERED: %u\n", TotalDifferenceCount );

  0063c	8b 45 c4	mov	eax, DWORD PTR _TotalDifferenceCount$[ebp]
  0063f	50		push	eax
  00640	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CN@BCML@TOTAL?5NUMBER?5OF?5DIFFERENCES?5ENCO@ ; `string'
  00645	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  00648	50		push	eax
  00649	e8 00 00 00 00	call	_fprintf
  0064e	83 c4 0c	add	esp, 12			; 0000000cH

; 370  :     fprintf( DiffTxtFile, "TOTAL NUMBER OF FILE OPEN ERRORS       : %u\n", FileOpenErrors );

  00651	8b 45 f8	mov	eax, DWORD PTR _FileOpenErrors$[ebp]
  00654	50		push	eax
  00655	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CN@DFAD@TOTAL?5NUMBER?5OF?5FILE?5OPEN?5ERRORS@ ; `string'
  0065a	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  0065d	50		push	eax
  0065e	e8 00 00 00 00	call	_fprintf
  00663	83 c4 0c	add	esp, 12			; 0000000cH

; 371  :     fprintf( DiffTxtFile, "\n__________END_CUMMALATIVE_RESULTS_LOG__________\n\n" );

  00666	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DD@EHHI@?6__________END_CUMMALATIVE_RESUL@ ; `string'
  0066b	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  0066e	50		push	eax
  0066f	e8 00 00 00 00	call	_fprintf
  00674	83 c4 08	add	esp, 8

; 372  : 
; 373  :     fprintf( stdout, "\n\n__________SUMMARY_LOG__________\n\n" );

  00677	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CE@NEJO@?6?6__________SUMMARY_LOG_________@ ; `string'
  0067c	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  00681	83 c0 20	add	eax, 32			; 00000020H
  00684	50		push	eax
  00685	e8 00 00 00 00	call	_fprintf
  0068a	83 c4 08	add	esp, 8

; 374  :     fprintf( stdout, SummaryBuffer );

  0068d	a1 00 00 00 00	mov	eax, DWORD PTR _SummaryBuffer
  00692	50		push	eax
  00693	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  00698	83 c0 20	add	eax, 32			; 00000020H
  0069b	50		push	eax
  0069c	e8 00 00 00 00	call	_fprintf
  006a1	83 c4 08	add	esp, 8

; 375  :     fprintf( stdout, "\n__________END_SUMMARY_LOG__________\n\n" );

  006a4	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CH@LCOP@?6__________END_SUMMARY_LOG______@ ; `string'
  006a9	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  006ae	83 c0 20	add	eax, 32			; 00000020H
  006b1	50		push	eax
  006b2	e8 00 00 00 00	call	_fprintf
  006b7	83 c4 08	add	esp, 8

; 376  :     fprintf( stdout, "\n\n__________CUMMALATIVE_RESULTS_LOG__________\n\n" );

  006ba	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DA@EMG@?6?6__________CUMMALATIVE_RESULTS_@ ; `string'
  006bf	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  006c4	83 c0 20	add	eax, 32			; 00000020H
  006c7	50		push	eax
  006c8	e8 00 00 00 00	call	_fprintf
  006cd	83 c4 08	add	esp, 8

; 377  :     fprintf( stdout, "COMPARED %d FILE PAIR(S)\n" , NumberOfFilesCompared );

  006d0	8b 45 c8	mov	eax, DWORD PTR _NumberOfFilesCompared$[ebp]
  006d3	50		push	eax
  006d4	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BK@LJOK@COMPARED?5?$CFd?5FILE?5PAIR?$CIS?$CJ?6?$AA@ ; `string'
  006d9	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  006de	83 c0 20	add	eax, 32			; 00000020H
  006e1	50		push	eax
  006e2	e8 00 00 00 00	call	_fprintf
  006e7	83 c4 0c	add	esp, 12			; 0000000cH

; 378  :     fprintf( stdout, "TOTAL NUMBER OF DIFFERENCES ENCOUNTERED: %u\n", TotalDifferenceCount );

  006ea	8b 45 c4	mov	eax, DWORD PTR _TotalDifferenceCount$[ebp]
  006ed	50		push	eax
  006ee	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CN@BCML@TOTAL?5NUMBER?5OF?5DIFFERENCES?5ENCO@ ; `string'
  006f3	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  006f8	83 c0 20	add	eax, 32			; 00000020H
  006fb	50		push	eax
  006fc	e8 00 00 00 00	call	_fprintf
  00701	83 c4 0c	add	esp, 12			; 0000000cH

; 379  :     fprintf( stdout, "TOTAL NUMBER OF FILE OPEN ERRORS       : %u\n", FileOpenErrors );

  00704	8b 45 f8	mov	eax, DWORD PTR _FileOpenErrors$[ebp]
  00707	50		push	eax
  00708	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CN@DFAD@TOTAL?5NUMBER?5OF?5FILE?5OPEN?5ERRORS@ ; `string'
  0070d	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  00712	83 c0 20	add	eax, 32			; 00000020H
  00715	50		push	eax
  00716	e8 00 00 00 00	call	_fprintf
  0071b	83 c4 0c	add	esp, 12			; 0000000cH

; 380  :     fprintf( stdout, "\n__________END_CUMMALATIVE_RESULTS_LOG__________\n\n" );

  0071e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DD@EHHI@?6__________END_CUMMALATIVE_RESUL@ ; `string'
  00723	b8 00 00 00 00	mov	eax, OFFSET FLAT:__iob
  00728	83 c0 20	add	eax, 32			; 00000020H
  0072b	50		push	eax
  0072c	e8 00 00 00 00	call	_fprintf
  00731	83 c4 08	add	esp, 8

; 381  : 
; 382  : 
; 383  :     //
; 384  :     // 7. CLOSE THE DIFFERENCE FILE AND PERFORM ANY REMAINING CLEANUP
; 385  :     //
; 386  : 
; 387  :     fclose( DiffTxtFile );

  00734	8b 45 f0	mov	eax, DWORD PTR _DiffTxtFile$[ebp]
  00737	50		push	eax
  00738	e8 00 00 00 00	call	_fclose
  0073d	83 c4 04	add	esp, 4

; 388  :     free( SummaryBuffer );

  00740	a1 00 00 00 00	mov	eax, DWORD PTR _SummaryBuffer
  00745	50		push	eax
  00746	e8 00 00 00 00	call	_free
  0074b	83 c4 04	add	esp, 4

; 389  :     if ( InputFromFile ) {

  0074e	83 7d e8 00	cmp	DWORD PTR _InputFromFile$[ebp], 0
  00752	0f 84 0c 00 00
	00		je	$L8400

; 390  : 
; 391  :         free( FileList );

  00758	8b 45 fc	mov	eax, DWORD PTR _FileList$[ebp]
  0075b	50		push	eax
  0075c	e8 00 00 00 00	call	_free
  00761	83 c4 04	add	esp, 4
$L8400:
$L8323:

; 392  : 
; 393  :     }
; 394  : 
; 395  : }

  00764	5f		pop	edi
  00765	5e		pop	esi
  00766	5b		pop	ebx
  00767	c9		leave
  00768	c3		ret	0
_main	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@LDEB@?6?7Usage?3?5TPDIFF?5LOG_FILE?5GOLDEN_@ ; `string'
PUBLIC	??_C@_09HCFM@?7Where?3?6?6?$AA@			; `string'
PUBLIC	??_C@_0DK@DMBI@?7LOG_FILE?5?5?5?5?5?5?5?9?5is?5the?5log?5fil@ ; `string'
PUBLIC	??_C@_0CE@NNO@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5for?5correctnes@ ; `string'
PUBLIC	??_C@_0DL@GJFJ@?7KNOWN_LOG_FILE?5?9?5is?5the?5known?5g@ ; `string'
PUBLIC	??_C@_0DA@NAKP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5used?5to?5verify@ ; `string'
PUBLIC	??_C@_0DO@FCKK@?7DIFFS_FILE?5?5?5?5?5?9?5is?5the?5file?5th@ ; `string'
PUBLIC	??_C@_0EA@NLIK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5lo@ ; `string'
PUBLIC	??_C@_0EB@HDHK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5@ ; `string'
PUBLIC	??_C@_0EA@JBKA@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diff@ ; `string'
PUBLIC	??_C@_0DK@GJAD@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5D@ ; `string'
PUBLIC	??_C@_0L@ECIF@?7?7?9?5OR?5?9?6?6?$AA@		; `string'
PUBLIC	??_C@_0CI@CEID@?7TPDIFF?5?9F?5LOG_FILE_LIST?5?$FLDIFFS_@ ; `string'
PUBLIC	??_C@_0DJ@JBOD@?7LOG_FILE_LIST?5?9?5is?5a?5file?5conta@ ; `string'
PUBLIC	??_C@_0DM@LBMC@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5names?5and?5known@ ; `string'
PUBLIC	??_C@_0DP@NKEL@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5pairs?5of?5file?5n@ ; `string'
PUBLIC	??_C@_0BO@EMEE@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5in?5the?5file?6?$AA@ ; `string'
PUBLIC	??_C@_0DN@LLIG@?7DIFFS_FILE?5?5?5?5?9?5is?5the?5file?5the@ ; `string'
PUBLIC	??_C@_0DP@KLJP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5log@ ; `string'
PUBLIC	??_C@_0EA@NJAK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5w@ ; `string'
PUBLIC	??_C@_0DP@OBLF@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diffe@ ; `string'
PUBLIC	??_C@_0DJ@INGM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5DI@ ; `string'
;	COMDAT ??_C@_0DI@LDEB@?6?7Usage?3?5TPDIFF?5LOG_FILE?5GOLDEN_@
CONST	SEGMENT
??_C@_0DI@LDEB@?6?7Usage?3?5TPDIFF?5LOG_FILE?5GOLDEN_@ DB 0aH, 09H, 'Usag'
	DB	'e: TPDIFF LOG_FILE GOLDEN_LOG_FILE [DIFFS_FILE]', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HCFM@?7Where?3?6?6?$AA@
CONST	SEGMENT
??_C@_09HCFM@?7Where?3?6?6?$AA@ DB 09H, 'Where:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DMBI@?7LOG_FILE?5?5?5?5?5?5?5?9?5is?5the?5log?5fil@
CONST	SEGMENT
??_C@_0DK@DMBI@?7LOG_FILE?5?5?5?5?5?5?5?9?5is?5the?5log?5fil@ DB 09H, 'LO'
	DB	'G_FILE       - is the log file that is to be verified', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNO@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5for?5correctnes@
CONST	SEGMENT
??_C@_0CE@NNO@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5for?5correctnes@ DB 09H
	DB	'                 for correctness.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GJFJ@?7KNOWN_LOG_FILE?5?9?5is?5the?5known?5g@
CONST	SEGMENT
??_C@_0DL@GJFJ@?7KNOWN_LOG_FILE?5?9?5is?5the?5known?5g@ DB 09H, 'KNOWN_LO'
	DB	'G_FILE - is the known good log file that will be', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NAKP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5used?5to?5verify@
CONST	SEGMENT
??_C@_0DA@NAKP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5used?5to?5verify@ DB 09H
	DB	'                 used to verify the log file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@FCKK@?7DIFFS_FILE?5?5?5?5?5?9?5is?5the?5file?5th@
CONST	SEGMENT
??_C@_0DO@FCKK@?7DIFFS_FILE?5?5?5?5?5?9?5is?5the?5file?5th@ DB 09H, 'DIFF'
	DB	'S_FILE     - is the file the differences, if any exist,', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NLIK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5lo@
CONST	SEGMENT
??_C@_0EA@NLIK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5lo@ DB 09H
	DB	'                 between the log files and the known good log'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HDHK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5@
CONST	SEGMENT
??_C@_0EB@HDHK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5@ DB 
	DB	09H, '                 files will be written to.  If no file n'
	DB	'ame is', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JBKA@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diff@
CONST	SEGMENT
??_C@_0EA@JBKA@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diff@ DB 09H
	DB	'                 given the differences will be printed to the'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@GJAD@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5D@
CONST	SEGMENT
??_C@_0DK@GJAD@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5D@ DB 09H
	DB	'                 default file DIFF.TXT and the console.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECIF@?7?7?9?5OR?5?9?6?6?$AA@
CONST	SEGMENT
??_C@_0L@ECIF@?7?7?9?5OR?5?9?6?6?$AA@ DB 09H, 09H, '- OR -', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CEID@?7TPDIFF?5?9F?5LOG_FILE_LIST?5?$FLDIFFS_@
CONST	SEGMENT
??_C@_0CI@CEID@?7TPDIFF?5?9F?5LOG_FILE_LIST?5?$FLDIFFS_@ DB 09H, 'TPDIFF '
	DB	'-F LOG_FILE_LIST [DIFFS_FILE]', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JBOD@?7LOG_FILE_LIST?5?9?5is?5a?5file?5conta@
CONST	SEGMENT
??_C@_0DJ@JBOD@?7LOG_FILE_LIST?5?9?5is?5a?5file?5conta@ DB 09H, 'LOG_FILE'
	DB	'_LIST - is a file containing pairs of log file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LBMC@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5names?5and?5known@
CONST	SEGMENT
??_C@_0DM@LBMC@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5names?5and?5known@ DB 09H
	DB	'                names and known good log file names.  The', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@NKEL@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5pairs?5of?5file?5n@
CONST	SEGMENT
??_C@_0DP@NKEL@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5pairs?5of?5file?5n@ DB 09H
	DB	'                pairs of file names must be on the same line', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EMEE@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5in?5the?5file?6?$AA@
CONST	SEGMENT
??_C@_0BO@EMEE@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5in?5the?5file?6?$AA@ DB 
	DB	09H, '                in the file', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@LLIG@?7DIFFS_FILE?5?5?5?5?9?5is?5the?5file?5the@
CONST	SEGMENT
??_C@_0DN@LLIG@?7DIFFS_FILE?5?5?5?5?9?5is?5the?5file?5the@ DB 09H, 'DIFFS'
	DB	'_FILE    - is the file the differences, if any exist,', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KLJP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5log@
CONST	SEGMENT
??_C@_0DP@KLJP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5log@ DB 09H
	DB	'                between the log files and the known good log', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NJAK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5w@
CONST	SEGMENT
??_C@_0EA@NJAK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5w@ DB 09H
	DB	'                files will be written to.  If no file name is'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@OBLF@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diffe@
CONST	SEGMENT
??_C@_0DP@OBLF@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diffe@ DB 09H
	DB	'                given the differences will be printed to the', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@INGM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5DI@
CONST	SEGMENT
??_C@_0DJ@INGM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5DI@ DB 09H
	DB	'                default file DIFF.TXT and the console.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT _Usage@0
_TEXT	SEGMENT
_Usage@0 PROC NEAR					; COMDAT

; 405  : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	53		push	ebx
  00004	56		push	esi
  00005	57		push	edi

; 406  : 
; 407  :     printf( "\n\tUsage: TPDIFF LOG_FILE GOLDEN_LOG_FILE [DIFFS_FILE]\n\n" );

  00006	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DI@LDEB@?6?7Usage?3?5TPDIFF?5LOG_FILE?5GOLDEN_@ ; `string'
  0000b	e8 00 00 00 00	call	_printf
  00010	83 c4 04	add	esp, 4

; 408  : 
; 409  : 
; 410  :     printf( "\tWhere:\n\n");

  00013	68 00 00 00 00	push	OFFSET FLAT:??_C@_09HCFM@?7Where?3?6?6?$AA@ ; `string'
  00018	e8 00 00 00 00	call	_printf
  0001d	83 c4 04	add	esp, 4

; 411  : 
; 412  : 
; 413  :     printf( "\tLOG_FILE       - is the log file that is to be verified\n"        );

  00020	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DK@DMBI@?7LOG_FILE?5?5?5?5?5?5?5?9?5is?5the?5log?5fil@ ; `string'
  00025	e8 00 00 00 00	call	_printf
  0002a	83 c4 04	add	esp, 4

; 414  :     printf( "\t                 for correctness.\n"                              );

  0002d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CE@NNO@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5for?5correctnes@ ; `string'
  00032	e8 00 00 00 00	call	_printf
  00037	83 c4 04	add	esp, 4

; 415  :     printf( "\tKNOWN_LOG_FILE - is the known good log file that will be\n"       );

  0003a	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DL@GJFJ@?7KNOWN_LOG_FILE?5?9?5is?5the?5known?5g@ ; `string'
  0003f	e8 00 00 00 00	call	_printf
  00044	83 c4 04	add	esp, 4

; 416  :     printf( "\t                 used to verify the log file.\n"                  );

  00047	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DA@NAKP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5used?5to?5verify@ ; `string'
  0004c	e8 00 00 00 00	call	_printf
  00051	83 c4 04	add	esp, 4

; 417  :     printf( "\tDIFFS_FILE     - is the file the differences, if any exist,\n"    );

  00054	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DO@FCKK@?7DIFFS_FILE?5?5?5?5?5?9?5is?5the?5file?5th@ ; `string'
  00059	e8 00 00 00 00	call	_printf
  0005e	83 c4 04	add	esp, 4

; 418  :     printf( "\t                 between the log files and the known good log\n"  );

  00061	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EA@NLIK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5lo@ ; `string'
  00066	e8 00 00 00 00	call	_printf
  0006b	83 c4 04	add	esp, 4

; 419  :     printf( "\t                 files will be written to.  If no file name is\n" );

  0006e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EB@HDHK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5@ ; `string'
  00073	e8 00 00 00 00	call	_printf
  00078	83 c4 04	add	esp, 4

; 420  :     printf( "\t                 given the differences will be printed to the\n"  );

  0007b	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EA@JBKA@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diff@ ; `string'
  00080	e8 00 00 00 00	call	_printf
  00085	83 c4 04	add	esp, 4

; 421  :     printf( "\t                 default file DIFF.TXT and the console.\n"        );

  00088	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DK@GJAD@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5D@ ; `string'
  0008d	e8 00 00 00 00	call	_printf
  00092	83 c4 04	add	esp, 4

; 422  :     printf( "\t\t- OR -\n\n" );

  00095	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@ECIF@?7?7?9?5OR?5?9?6?6?$AA@ ; `string'
  0009a	e8 00 00 00 00	call	_printf
  0009f	83 c4 04	add	esp, 4

; 423  : 
; 424  : 
; 425  :     printf( "\tTPDIFF -F LOG_FILE_LIST [DIFFS_FILE]\n\n" );

  000a2	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CI@CEID@?7TPDIFF?5?9F?5LOG_FILE_LIST?5?$FLDIFFS_@ ; `string'
  000a7	e8 00 00 00 00	call	_printf
  000ac	83 c4 04	add	esp, 4

; 426  : 
; 427  : 
; 428  :     printf( "\tWhere:\n\n" );

  000af	68 00 00 00 00	push	OFFSET FLAT:??_C@_09HCFM@?7Where?3?6?6?$AA@ ; `string'
  000b4	e8 00 00 00 00	call	_printf
  000b9	83 c4 04	add	esp, 4

; 429  : 
; 430  : 
; 431  :     printf( "\tLOG_FILE_LIST - is a file containing pairs of log file\n"       );

  000bc	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DJ@JBOD@?7LOG_FILE_LIST?5?9?5is?5a?5file?5conta@ ; `string'
  000c1	e8 00 00 00 00	call	_printf
  000c6	83 c4 04	add	esp, 4

; 432  :     printf( "\t                names and known good log file names.  The\n"    );

  000c9	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DM@LBMC@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5names?5and?5known@ ; `string'
  000ce	e8 00 00 00 00	call	_printf
  000d3	83 c4 04	add	esp, 4

; 433  :     printf( "\t                pairs of file names must be on the same line\n" );

  000d6	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DP@NKEL@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5pairs?5of?5file?5n@ ; `string'
  000db	e8 00 00 00 00	call	_printf
  000e0	83 c4 04	add	esp, 4

; 434  :     printf( "\t                in the file\n"                                  );

  000e3	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BO@EMEE@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5in?5the?5file?6?$AA@ ; `string'
  000e8	e8 00 00 00 00	call	_printf
  000ed	83 c4 04	add	esp, 4

; 435  :     printf( "\tDIFFS_FILE    - is the file the differences, if any exist,\n"    );

  000f0	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@LLIG@?7DIFFS_FILE?5?5?5?5?9?5is?5the?5file?5the@ ; `string'
  000f5	e8 00 00 00 00	call	_printf
  000fa	83 c4 04	add	esp, 4

; 436  :     printf( "\t                between the log files and the known good log\n"  );

  000fd	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DP@KLJP@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5between?5the?5log@ ; `string'
  00102	e8 00 00 00 00	call	_printf
  00107	83 c4 04	add	esp, 4

; 437  :     printf( "\t                files will be written to.  If no file name is\n" );

  0010a	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EA@NJAK@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5files?5will?5be?5w@ ; `string'
  0010f	e8 00 00 00 00	call	_printf
  00114	83 c4 04	add	esp, 4

; 438  :     printf( "\t                given the differences will be printed to the\n"  );

  00117	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DP@OBLF@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5given?5the?5diffe@ ; `string'
  0011c	e8 00 00 00 00	call	_printf
  00121	83 c4 04	add	esp, 4

; 439  :     printf( "\t                default file DIFF.TXT and the console.\n"        );

  00124	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DJ@INGM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5default?5file?5DI@ ; `string'
  00129	e8 00 00 00 00	call	_printf
  0012e	83 c4 04	add	esp, 4
$L8401:

; 440  : 
; 441  : }

  00131	5f		pop	edi
  00132	5e		pop	esi
  00133	5b		pop	ebx
  00134	c9		leave
  00135	c3		ret	0
_Usage@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IGFG@?5?0?7?$AA@			; `string'
PUBLIC	??_C@_0GG@KFPJ@The?5first?5log?5file?5name?5is?3?7?$CFs?6H@ ; `string'
PUBLIC	??_C@_0CO@BDDE@Unable?5to?5determine?5the?5first?5lo@ ; `string'
EXTRN	_strncpy:NEAR
EXTRN	_strtok:NEAR
;	COMDAT ??_C@_03IGFG@?5?0?7?$AA@
CONST	SEGMENT
??_C@_03IGFG@?5?0?7?$AA@ DB ' ,', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@KFPJ@The?5first?5log?5file?5name?5is?3?7?$CFs?6H@
CONST	SEGMENT
??_C@_0GG@KFPJ@The?5first?5log?5file?5name?5is?3?7?$CFs?6H@ DB 'The first'
	DB	' log file name is:', 09H, '%s', 0aH, 'However the program was'
	DB	' unable to determine the second log file name.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BDDE@Unable?5to?5determine?5the?5first?5lo@
CONST	SEGMENT
??_C@_0CO@BDDE@Unable?5to?5determine?5the?5first?5lo@ DB 'Unable to deter'
	DB	'mine the first log file name.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT _GetFilePair@12
_TEXT	SEGMENT
_FirstFile$ = 8
_SecondFile$ = 12
_Buffer$ = 16
_Token$ = -20
_Seperators$ = -12
_TokenLength$ = -8
_GetFilePair@12 PROC NEAR				; COMDAT

; 450  : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 14	sub	esp, 20			; 00000014H
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 451  : 
; 452  :     PCHAR   Token[2]            ;
; 453  :     PCHAR   Seperators = " ,\t" ;

  00009	c7 45 f4 00 00
	00 00		mov	DWORD PTR _Seperators$[ebp], OFFSET FLAT:??_C@_03IGFG@?5?0?7?$AA@ ; `string'

; 454  :     UINT    TokenLength[2]      ;
; 455  : 
; 456  : 
; 457  :     //
; 458  :     // Extract the log file names from the string buffer
; 459  :     //
; 460  :     Token[0]  = strtok( Buffer, Seperators );

  00010	8b 45 f4	mov	eax, DWORD PTR _Seperators$[ebp]
  00013	50		push	eax
  00014	8b 45 10	mov	eax, DWORD PTR _Buffer$[ebp]
  00017	50		push	eax
  00018	e8 00 00 00 00	call	_strtok
  0001d	83 c4 08	add	esp, 8
  00020	89 45 ec	mov	DWORD PTR _Token$[ebp], eax

; 461  : 
; 462  :     if ( Token[0] != (PCHAR)NULL ) {

  00023	83 7d ec 00	cmp	DWORD PTR _Token$[ebp], 0
  00027	0f 84 5b 00 00
	00		je	$L8432

; 463  : 
; 464  :         Token[1]  = strtok( NULL, Seperators   );

  0002d	8b 45 f4	mov	eax, DWORD PTR _Seperators$[ebp]
  00030	50		push	eax
  00031	6a 00		push	0
  00033	e8 00 00 00 00	call	_strtok
  00038	83 c4 08	add	esp, 8
  0003b	89 45 f0	mov	DWORD PTR _Token$[ebp+4], eax

; 465  : 
; 466  :         if ( Token[1] == (PCHAR)NULL ) {

  0003e	83 7d f0 00	cmp	DWORD PTR _Token$[ebp+4], 0
  00042	0f 85 1d 00 00
	00		jne	$L8433

; 467  : 
; 468  :             printf("The first log file name is:\t%s\nHowever the program was unable to determine the second log file name.\n",
; 469  :                     Token[0]);

  00048	8b 45 ec	mov	eax, DWORD PTR _Token$[ebp]
  0004b	50		push	eax
  0004c	68 00 00 00 00	push	OFFSET FLAT:??_C@_0GG@KFPJ@The?5first?5log?5file?5name?5is?3?7?$CFs?6H@ ; `string'
  00051	e8 00 00 00 00	call	_printf
  00056	83 c4 08	add	esp, 8

; 470  :             return FALSE;

  00059	32 c0		xor	al, al
  0005b	e9 08 01 00 00	jmp	$L8427

; 471  : 
; 472  :         } else {

  00060	e9 1e 00 00 00	jmp	$L8435
$L8433:

; 473  : 
; 474  :             TokenLength[0] = strlen( Token[0] );

  00065	8b 45 ec	mov	eax, DWORD PTR _Token$[ebp]
  00068	50		push	eax
  00069	e8 00 00 00 00	call	_strlen
  0006e	83 c4 04	add	esp, 4
  00071	89 45 f8	mov	DWORD PTR _TokenLength$[ebp], eax

; 475  :             TokenLength[1] = strlen( Token[1] );

  00074	8b 45 f0	mov	eax, DWORD PTR _Token$[ebp+4]
  00077	50		push	eax
  00078	e8 00 00 00 00	call	_strlen
  0007d	83 c4 04	add	esp, 4
  00080	89 45 fc	mov	DWORD PTR _TokenLength$[ebp+4], eax
$L8435:

; 476  : 
; 477  :         }
; 478  : 
; 479  :     } else {

  00083	e9 14 00 00 00	jmp	$L8436
$L8432:

; 480  : 
; 481  :         printf("Unable to determine the first log file name.\n");

  00088	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CO@BDDE@Unable?5to?5determine?5the?5first?5lo@ ; `string'
  0008d	e8 00 00 00 00	call	_printf
  00092	83 c4 04	add	esp, 4

; 482  :         return FALSE;

  00095	32 c0		xor	al, al
  00097	e9 cc 00 00 00	jmp	$L8427
$L8436:

; 483  : 
; 484  :     }
; 485  : 
; 486  : 
; 487  :     //
; 488  :     // Create storage on the file list for the file names
; 489  :     //
; 490  :     *FirstFile  = malloc( (TokenLength[0]+1)*sizeof(CHAR) );

  0009c	8b 45 f8	mov	eax, DWORD PTR _TokenLength$[ebp]
  0009f	40		inc	eax
  000a0	50		push	eax
  000a1	e8 00 00 00 00	call	_malloc
  000a6	83 c4 04	add	esp, 4
  000a9	8b 4d 08	mov	ecx, DWORD PTR _FirstFile$[ebp]
  000ac	89 01		mov	DWORD PTR [ecx], eax

; 491  :     *SecondFile = malloc( (TokenLength[1]+1)*sizeof(CHAR) );

  000ae	8b 45 fc	mov	eax, DWORD PTR _TokenLength$[ebp+4]
  000b1	40		inc	eax
  000b2	50		push	eax
  000b3	e8 00 00 00 00	call	_malloc
  000b8	83 c4 04	add	esp, 4
  000bb	8b 4d 0c	mov	ecx, DWORD PTR _SecondFile$[ebp]
  000be	89 01		mov	DWORD PTR [ecx], eax

; 492  : 
; 493  :     if ( *FirstFile == (PCHAR)NULL || *SecondFile == (PCHAR)NULL ) {

  000c0	8b 45 08	mov	eax, DWORD PTR _FirstFile$[ebp]
  000c3	83 38 00	cmp	DWORD PTR [eax], 0
  000c6	0f 84 0c 00 00
	00		je	$L8439
  000cc	8b 45 0c	mov	eax, DWORD PTR _SecondFile$[ebp]
  000cf	83 38 00	cmp	DWORD PTR [eax], 0
  000d2	0f 85 33 00 00
	00		jne	$L8438
$L8439:

; 494  : 
; 495  :         printf("The system has run out of memory resources for this program\n");

  000d8	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  000dd	e8 00 00 00 00	call	_printf
  000e2	83 c4 04	add	esp, 4

; 496  :         free( *FirstFile  );

  000e5	8b 45 08	mov	eax, DWORD PTR _FirstFile$[ebp]
  000e8	8b 00		mov	eax, DWORD PTR [eax]
  000ea	50		push	eax
  000eb	e8 00 00 00 00	call	_free
  000f0	83 c4 04	add	esp, 4

; 497  :         free( *SecondFile );

  000f3	8b 45 0c	mov	eax, DWORD PTR _SecondFile$[ebp]
  000f6	8b 00		mov	eax, DWORD PTR [eax]
  000f8	50		push	eax
  000f9	e8 00 00 00 00	call	_free
  000fe	83 c4 04	add	esp, 4

; 498  :         exit( -1 );

  00101	6a ff		push	-1
  00103	e8 00 00 00 00	call	_exit
  00108	83 c4 04	add	esp, 4
$L8438:

; 499  : 
; 500  :     }
; 501  : 
; 502  :     //
; 503  :     // Copy the file names into the allocated storage
; 504  :     //
; 505  :     memset( *FirstFile,  0, TokenLength[0]+1 );

  0010b	8b 45 f8	mov	eax, DWORD PTR _TokenLength$[ebp]
  0010e	40		inc	eax
  0010f	50		push	eax
  00110	6a 00		push	0
  00112	8b 45 08	mov	eax, DWORD PTR _FirstFile$[ebp]
  00115	8b 00		mov	eax, DWORD PTR [eax]
  00117	50		push	eax
  00118	e8 00 00 00 00	call	_memset
  0011d	83 c4 0c	add	esp, 12			; 0000000cH

; 506  :     memset( *SecondFile, 0, TokenLength[1]+1 );

  00120	8b 45 fc	mov	eax, DWORD PTR _TokenLength$[ebp+4]
  00123	40		inc	eax
  00124	50		push	eax
  00125	6a 00		push	0
  00127	8b 45 0c	mov	eax, DWORD PTR _SecondFile$[ebp]
  0012a	8b 00		mov	eax, DWORD PTR [eax]
  0012c	50		push	eax
  0012d	e8 00 00 00 00	call	_memset
  00132	83 c4 0c	add	esp, 12			; 0000000cH

; 507  :     strncpy( *FirstFile,  Token[0], TokenLength[0] );

  00135	8b 45 f8	mov	eax, DWORD PTR _TokenLength$[ebp]
  00138	50		push	eax
  00139	8b 45 ec	mov	eax, DWORD PTR _Token$[ebp]
  0013c	50		push	eax
  0013d	8b 45 08	mov	eax, DWORD PTR _FirstFile$[ebp]
  00140	8b 00		mov	eax, DWORD PTR [eax]
  00142	50		push	eax
  00143	e8 00 00 00 00	call	_strncpy
  00148	83 c4 0c	add	esp, 12			; 0000000cH

; 508  :     strncpy( *SecondFile, Token[1], TokenLength[1] );

  0014b	8b 45 fc	mov	eax, DWORD PTR _TokenLength$[ebp+4]
  0014e	50		push	eax
  0014f	8b 45 f0	mov	eax, DWORD PTR _Token$[ebp+4]
  00152	50		push	eax
  00153	8b 45 0c	mov	eax, DWORD PTR _SecondFile$[ebp]
  00156	8b 00		mov	eax, DWORD PTR [eax]
  00158	50		push	eax
  00159	e8 00 00 00 00	call	_strncpy
  0015e	83 c4 0c	add	esp, 12			; 0000000cH

; 509  : 
; 510  :     //
; 511  :     // And return success
; 512  :     //
; 513  :     return TRUE;

  00161	b0 01		mov	al, 1
  00163	e9 00 00 00 00	jmp	$L8427
$L8427:

; 514  : 
; 515  : }

  00168	5f		pop	edi
  00169	5e		pop	esi
  0016a	5b		pop	ebx
  0016b	c9		leave
  0016c	c2 0c 00	ret	12			; 0000000cH
_GetFilePair@12 ENDP
_TEXT	ENDS
;	COMDAT _OpenFiles@16
_TEXT	SEGMENT
_FirstFile$ = 8
_FirstFileName$ = 12
_SecondFile$ = 16
_SecondFileName$ = 20
_OpenFiles@16 PROC NEAR					; COMDAT

; 526  : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	53		push	ebx
  00004	56		push	esi
  00005	57		push	edi

; 527  :     //
; 528  :     // Open the two files
; 529  :     //
; 530  :     FirstFile->FileP  = fopen( FirstFileName,  "r" );

  00006	68 00 00 00 00	push	OFFSET FLAT:??_C@_01LHO@r?$AA@ ; `string'
  0000b	8b 45 0c	mov	eax, DWORD PTR _FirstFileName$[ebp]
  0000e	50		push	eax
  0000f	e8 00 00 00 00	call	_fopen
  00014	83 c4 08	add	esp, 8
  00017	8b 4d 08	mov	ecx, DWORD PTR _FirstFile$[ebp]
  0001a	89 41 08	mov	DWORD PTR [ecx+8], eax

; 531  :     SecondFile->FileP = fopen( SecondFileName, "r" );

  0001d	68 00 00 00 00	push	OFFSET FLAT:??_C@_01LHO@r?$AA@ ; `string'
  00022	8b 45 14	mov	eax, DWORD PTR _SecondFileName$[ebp]
  00025	50		push	eax
  00026	e8 00 00 00 00	call	_fopen
  0002b	83 c4 08	add	esp, 8
  0002e	8b 4d 10	mov	ecx, DWORD PTR _SecondFile$[ebp]
  00031	89 41 08	mov	DWORD PTR [ecx+8], eax

; 532  : 
; 533  :     //
; 534  :     // If there was an error while opening functionally report it
; 535  :     //
; 536  :     if ( ( FirstFile->FileP == (FILE *)NULL  ) ||
; 537  :          ( SecondFile->FileP == (FILE *)NULL )    ) {

  00034	8b 45 08	mov	eax, DWORD PTR _FirstFile$[ebp]
  00037	83 78 08 00	cmp	DWORD PTR [eax+8], 0
  0003b	0f 84 0d 00 00
	00		je	$L8446
  00041	8b 45 10	mov	eax, DWORD PTR _SecondFile$[ebp]
  00044	83 78 08 00	cmp	DWORD PTR [eax+8], 0
  00048	0f 85 07 00 00
	00		jne	$L8445
$L8446:

; 538  : 
; 539  :         return FALSE;

  0004e	32 c0		xor	al, al
  00050	e9 07 00 00 00	jmp	$L8444
$L8445:

; 540  : 
; 541  :     }
; 542  : 
; 543  :     return TRUE;

  00055	b0 01		mov	al, 1
  00057	e9 00 00 00 00	jmp	$L8444
$L8444:

; 544  : 
; 545  : }

  0005c	5f		pop	edi
  0005d	5e		pop	esi
  0005e	5b		pop	ebx
  0005f	c9		leave
  00060	c2 10 00	ret	16			; 00000010H
_OpenFiles@16 ENDP
_TEXT	ENDS
PUBLIC	_CompareSections@16
EXTRN	_strcpy:NEAR
;	COMDAT _CompareFiles@16
_TEXT	SEGMENT
_FirstFile$ = 8
_SecondFile$ = 12
_DifferenceFile$ = 16
_TotalDifferenceCounter$ = 20
_SectionZero_FirstFile$ = -12
_SectionZero_SecondFile$ = -8
_FileComparisonDifferences$ = -4
_CompareFiles@16 PROC NEAR				; COMDAT

; 556  : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 0c	sub	esp, 12			; 0000000cH
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 557  : 
; 558  :     PSECTION SectionZero_FirstFile;
; 559  :     PSECTION SectionZero_SecondFile;
; 560  :     ULONG    FileComparisonDifferences = 0 ;

  00009	c7 45 fc 00 00
	00 00		mov	DWORD PTR _FileComparisonDifferences$[ebp], 0

; 561  : 
; 562  : 
; 563  :     //
; 564  :     // Create the two special sections.
; 565  :     // These sections indicate the beggining of the two files being compared
; 566  :     //
; 567  :     SectionZero_FirstFile  = CreateSection();

  00010	68 54 02 00 00	push	596			; 00000254H
  00015	6a 01		push	1
  00017	e8 00 00 00 00	call	_calloc
  0001c	83 c4 08	add	esp, 8
  0001f	89 45 f4	mov	DWORD PTR _SectionZero_FirstFile$[ebp], eax

; 568  :     SectionZero_SecondFile = CreateSection();

  00022	68 54 02 00 00	push	596			; 00000254H
  00027	6a 01		push	1
  00029	e8 00 00 00 00	call	_calloc
  0002e	83 c4 08	add	esp, 8
  00031	89 45 f8	mov	DWORD PTR _SectionZero_SecondFile$[ebp], eax

; 569  : 
; 570  :     if ( SectionZero_FirstFile == (PSECTION)NULL) {

  00034	83 7d f4 00	cmp	DWORD PTR _SectionZero_FirstFile$[ebp], 0
  00038	0f 85 32 00 00
	00		jne	$L8455

; 571  :         printf("The system has run out of memory resources for this program\n");

  0003e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  00043	e8 00 00 00 00	call	_printf
  00048	83 c4 04	add	esp, 4

; 572  :         if ( SectionZero_SecondFile != (PSECTION)NULL) {

  0004b	83 7d f8 00	cmp	DWORD PTR _SectionZero_SecondFile$[ebp], 0
  0004f	0f 84 0c 00 00
	00		je	$L8456

; 573  :             DestroySection( SectionZero_SecondFile );

  00055	8b 45 f8	mov	eax, DWORD PTR _SectionZero_SecondFile$[ebp]
  00058	50		push	eax
  00059	e8 00 00 00 00	call	_free
  0005e	83 c4 04	add	esp, 4
$L8456:

; 574  :         }
; 575  :         exit( -1 );

  00061	6a ff		push	-1
  00063	e8 00 00 00 00	call	_exit
  00068	83 c4 04	add	esp, 4

; 576  :     } else if ( SectionZero_SecondFile == (PSECTION)NULL) {

  0006b	e9 2d 00 00 00	jmp	$L8457
$L8455:
  00070	83 7d f8 00	cmp	DWORD PTR _SectionZero_SecondFile$[ebp], 0
  00074	0f 85 23 00 00
	00		jne	$L8458

; 577  :         printf("The system has run out of memory resources for this program\n");

  0007a	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  0007f	e8 00 00 00 00	call	_printf
  00084	83 c4 04	add	esp, 4

; 578  :         DestroySection( SectionZero_FirstFile );

  00087	8b 45 f4	mov	eax, DWORD PTR _SectionZero_FirstFile$[ebp]
  0008a	50		push	eax
  0008b	e8 00 00 00 00	call	_free
  00090	83 c4 04	add	esp, 4

; 579  :         exit( -1 );

  00093	6a ff		push	-1
  00095	e8 00 00 00 00	call	_exit
  0009a	83 c4 04	add	esp, 4
$L8458:
$L8457:

; 580  :     }
; 581  : 
; 582  : 
; 583  : 
; 584  :     //
; 585  :     //  Initialize the two sections
; 586  :     //
; 587  :     SectionZero_FirstFile->File  = FirstFile ;

  0009d	8b 45 08	mov	eax, DWORD PTR _FirstFile$[ebp]
  000a0	8b 4d f4	mov	ecx, DWORD PTR _SectionZero_FirstFile$[ebp]
  000a3	89 81 30 01 00
	00		mov	DWORD PTR [ecx+304], eax

; 588  :     SectionZero_SecondFile->File = SecondFile;

  000a9	8b 45 0c	mov	eax, DWORD PTR _SecondFile$[ebp]
  000ac	8b 4d f8	mov	ecx, DWORD PTR _SectionZero_SecondFile$[ebp]
  000af	89 81 30 01 00
	00		mov	DWORD PTR [ecx+304], eax

; 589  :     strcpy( SectionZero_FirstFile->SectionDescription,  FirstFile->FileName  );

  000b5	8b 45 08	mov	eax, DWORD PTR _FirstFile$[ebp]
  000b8	8b 40 04	mov	eax, DWORD PTR [eax+4]
  000bb	50		push	eax
  000bc	8b 45 f4	mov	eax, DWORD PTR _SectionZero_FirstFile$[ebp]
  000bf	05 54 01 00 00	add	eax, 340		; 00000154H
  000c4	50		push	eax
  000c5	e8 00 00 00 00	call	_strcpy
  000ca	83 c4 08	add	esp, 8

; 590  :     strcpy( SectionZero_SecondFile->SectionDescription, SecondFile->FileName );

  000cd	8b 45 0c	mov	eax, DWORD PTR _SecondFile$[ebp]
  000d0	8b 40 04	mov	eax, DWORD PTR [eax+4]
  000d3	50		push	eax
  000d4	8b 45 f8	mov	eax, DWORD PTR _SectionZero_SecondFile$[ebp]
  000d7	05 54 01 00 00	add	eax, 340		; 00000154H
  000dc	50		push	eax
  000dd	e8 00 00 00 00	call	_strcpy
  000e2	83 c4 08	add	esp, 8

; 591  : 
; 592  : 
; 593  :     //
; 594  :     // Now since the second file is also the GOLDEN file, set that as the
; 595  :     // base control section. Lines, sections will be compared AGAINST this control
; 596  :     // section. In the generic case however, this would not be true since either
; 597  :     // one can be marked as the base section. That requires this line to be remarked
; 598  :     // and changes made to the -TOKEN_MATCH-() keyword syntax to accept the variable
; 599  :     // BASE.
; 600  :     //
; 601  :     SectionZero_SecondFile->Control.BaseControlSection = TRUE;

  000e5	8b 45 f8	mov	eax, DWORD PTR _SectionZero_SecondFile$[ebp]
  000e8	c6 80 52 01 00
	00 01		mov	BYTE PTR [eax+338], 1

; 602  : 
; 603  : 
; 604  :     //
; 605  :     // Proceed with the comparisons
; 606  :     //
; 607  :     CompareSections( SectionZero_FirstFile, SectionZero_SecondFile,
; 608  :                      DifferenceFile, &FileComparisonDifferences );

  000ef	8d 45 fc	lea	eax, DWORD PTR _FileComparisonDifferences$[ebp]
  000f2	50		push	eax
  000f3	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  000f6	50		push	eax
  000f7	8b 45 f8	mov	eax, DWORD PTR _SectionZero_SecondFile$[ebp]
  000fa	50		push	eax
  000fb	8b 45 f4	mov	eax, DWORD PTR _SectionZero_FirstFile$[ebp]
  000fe	50		push	eax
  000ff	e8 00 00 00 00	call	_CompareSections@16

; 609  : 
; 610  : 
; 611  :     //
; 612  :     // And indicate the completion of a successful comparison
; 613  :     //
; 614  :     *TotalDifferenceCounter += FileComparisonDifferences;

  00104	8b 45 fc	mov	eax, DWORD PTR _FileComparisonDifferences$[ebp]
  00107	8b 4d 14	mov	ecx, DWORD PTR _TotalDifferenceCounter$[ebp]
  0010a	01 01		add	DWORD PTR [ecx], eax

; 615  :     return TRUE;

  0010c	b0 01		mov	al, 1
  0010e	e9 00 00 00 00	jmp	$L8451
$L8451:

; 616  : 
; 617  : }

  00113	5f		pop	edi
  00114	5e		pop	esi
  00115	5b		pop	ebx
  00116	c9		leave
  00117	c2 10 00	ret	16			; 00000010H
_CompareFiles@16 ENDP
_TEXT	ENDS
PUBLIC	_GetNextLine@4
PUBLIC	_DoNotSkipThisLine@4
PUBLIC	_LineType@4
PUBLIC	_ExtractResults@4
PUBLIC	_ExtractBetweenValues@4
PUBLIC	_CombinedVariation@12
PUBLIC	_InitializeSectionControl@8
PUBLIC	_PrintSectionInformation@8
PUBLIC	_ExtractSectionIDFromLine@4
PUBLIC	_CheckSectionIDFromCurrentLines@8
PUBLIC	_CompareLinesAndPrintResults@16
PUBLIC	_CompareTokensAndPrintResults@16
PUBLIC	??_C@_0DE@ODMB@?6A?5BAD?5SECTIONAL?5CONTROL?5SEGMENT@ ; `string'
PUBLIC	??_C@_0BL@DBNA@?6CHECK?5FOR?5A?5SYNTAX?5ERROR?6?$AA@ ; `string'
PUBLIC	??_C@_0DI@EGAP@?6?6__SECTIONAL?5RESULTS?5FOR?5SECTIO@ ; `string'
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0DE@ODMB@?6A?5BAD?5SECTIONAL?5CONTROL?5SEGMENT@
CONST	SEGMENT
??_C@_0DE@ODMB@?6A?5BAD?5SECTIONAL?5CONTROL?5SEGMENT@ DB 0aH, 'A BAD SECT'
	DB	'IONAL CONTROL SEGMENT HAS BEEN DETECTED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DBNA@?6CHECK?5FOR?5A?5SYNTAX?5ERROR?6?$AA@
CONST	SEGMENT
??_C@_0BL@DBNA@?6CHECK?5FOR?5A?5SYNTAX?5ERROR?6?$AA@ DB 0aH, 'CHECK FOR A'
	DB	' SYNTAX ERROR', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EGAP@?6?6__SECTIONAL?5RESULTS?5FOR?5SECTIO@
CONST	SEGMENT
??_C@_0DI@EGAP@?6?6__SECTIONAL?5RESULTS?5FOR?5SECTIO@ DB 0aH, 0aH, '__SEC'
	DB	'TIONAL RESULTS FOR SECTION ID : %f ERROR(S): %u', 0aH, 00H ; `string'
CONST	ENDS
CONST	SEGMENT
$T8934	DQ	00000000000000000r		; 0
CONST	ENDS
;	COMDAT _CompareSections@16
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_DifferenceFile$ = 16
_FileDifferenceCounter$ = 20
_FunctionElements$ = -4
_CompareSections@16 PROC NEAR				; COMDAT

; 627  : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 08	sub	esp, 8
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 628  : 
; 629  :     PFUNCTION_ELEMENTS FunctionElements;
; 630  : 
; 631  :     //
; 632  :     // Initialize the lines used to store information extracted from the files
; 633  :     //
; 634  :     FunctionElements = CreateFunctionElements();

  00009	68 3c 04 00 00	push	1084			; 0000043cH
  0000e	6a 01		push	1
  00010	e8 00 00 00 00	call	_calloc
  00015	83 c4 08	add	esp, 8
  00018	89 45 fc	mov	DWORD PTR _FunctionElements$[ebp], eax

; 635  :     if ( FunctionElements == (PFUNCTION_ELEMENTS)NULL ) {

  0001b	83 7d fc 00	cmp	DWORD PTR _FunctionElements$[ebp], 0
  0001f	0f 85 1c 00 00
	00		jne	$L8465

; 636  :         printf("The system has run out of memory resources for this program\n");

  00025	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  0002a	e8 00 00 00 00	call	_printf
  0002f	83 c4 04	add	esp, 4

; 637  :         exit( -1 );

  00032	6a ff		push	-1
  00034	e8 00 00 00 00	call	_exit
  00039	83 c4 04	add	esp, 4

; 638  :     } else {

  0003c	e9 07 00 00 00	jmp	$L8466
$L8465:

; 639  :         FunctionElements->SectionEndsNotSynchronized = TRUE;

  00041	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00044	c6 40 1e 01	mov	BYTE PTR [eax+30], 1
$L8466:
$L8468:

; 640  :     }
; 641  : 
; 642  : 
; 643  :     //
; 644  :     // Indicate a sectional compare IF the section is not the base section 0.0
; 645  :     //
; 646  :     // fprintf( DifferenceFile, "\n\n__PERFORMING SECTIONAL ANALYSIS ON SECTION ID: %f__\n",
; 647  :     //          SecondSection->Control.SectionIdentifier );
; 648  : 
; 649  :     //
; 650  :     // Repeat until the section ends from the two files match
; 651  :     // and the section comparison completes
; 652  :     //
; 653  :     while ( FunctionElements->SectionEndsNotSynchronized ) {

  00048	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0004b	33 c9		xor	ecx, ecx
  0004d	8a 48 1e	mov	cl, BYTE PTR [eax+30]
  00050	85 c9		test	ecx, ecx
  00052	0f 84 f3 06 00
	00		je	$L8469

; 654  : 
; 655  :         //
; 656  :         // Get the next line from first section IFF sectional synchronization is not
; 657  :         // required
; 658  :         //
; 659  :         if ( FunctionElements->FirstSectionSynchronize == FALSE ) {

  00058	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0005b	33 c9		xor	ecx, ecx
  0005d	8a 48 1c	mov	cl, BYTE PTR [eax+28]
  00060	85 c9		test	ecx, ecx
  00062	0f 85 ab 00 00
	00		jne	$L8470

; 660  : 
; 661  :             //
; 662  :             // Keep attempting to access the next line till we do not have to skip lines
; 663  :             //
; 664  :             FunctionElements->SkipLine = TRUE;

  00068	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0006b	c6 40 1f 01	mov	BYTE PTR [eax+31], 1
$L8472:

; 665  :             while ( FunctionElements->SkipLine ) {

  0006f	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00072	33 c9		xor	ecx, ecx
  00074	8a 48 1f	mov	cl, BYTE PTR [eax+31]
  00077	85 c9		test	ecx, ecx
  00079	0f 84 94 00 00
	00		je	$L8473

; 666  : 
; 667  :                 ClearAndSetLine(  FirstSection , &FunctionElements->FirstSectionCurrentLine  );

  0007f	68 0c 02 00 00	push	524			; 0000020cH
  00084	6a 00		push	0
  00086	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00089	83 c0 20	add	eax, 32			; 00000020H
  0008c	50		push	eax
  0008d	e8 00 00 00 00	call	_memset
  00092	83 c4 0c	add	esp, 12			; 0000000cH
  00095	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00098	83 c0 20	add	eax, 32			; 00000020H
  0009b	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  0009e	89 81 34 01 00
	00		mov	DWORD PTR [ecx+308], eax

; 668  :                 if ( GetNextLine( FirstSection  ) ) {

  000a4	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000a7	50		push	eax
  000a8	e8 00 00 00 00	call	_GetNextLine@4
  000ad	33 c9		xor	ecx, ecx
  000af	8a c8		mov	cl, al
  000b1	85 c9		test	ecx, ecx
  000b3	0f 84 3e 00 00
	00		je	$L8474

; 669  : 
; 670  :                     if ( DoNotSkipThisLine( FirstSection ) ) {

  000b9	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000bc	50		push	eax
  000bd	e8 00 00 00 00	call	_DoNotSkipThisLine@4
  000c2	33 c9		xor	ecx, ecx
  000c4	8a c8		mov	cl, al
  000c6	85 c9		test	ecx, ecx
  000c8	0f 84 10 00 00
	00		je	$L8475

; 671  : 
; 672  :                         ExtractResults( FirstSection );

  000ce	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000d1	50		push	eax
  000d2	e8 00 00 00 00	call	_ExtractResults@4

; 673  :                         FunctionElements->SkipLine = FALSE;

  000d7	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  000da	c6 40 1f 00	mov	BYTE PTR [eax+31], 0
$L8475:

; 674  : 
; 675  :                     }
; 676  :                     FirstSection->Control.SectionLineCount++;

  000de	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000e1	ff 80 38 01 00
	00		inc	DWORD PTR [eax+312]

; 677  :                     FirstSection->File->CurrentFileLine++;

  000e7	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000ea	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  000f0	ff 00		inc	DWORD PTR [eax]

; 678  : 
; 679  :                 }  else {

  000f2	e9 17 00 00 00	jmp	$L8476
$L8474:

; 680  : 
; 681  :                     //
; 682  :                     // Mark this line as type SECTION_END. This is actually the EOF which
; 683  :                     // is also the end of section 0.0(the file)
; 684  :                     //
; 685  :                     FirstSection->CurrentLine->LineType = LINE_TYPE_SECTION_END;

  000f7	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000fa	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00100	c6 80 08 02 00
	00 02		mov	BYTE PTR [eax+520], 2

; 686  :                     FunctionElements->SkipLine          = FALSE                ;

  00107	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0010a	c6 40 1f 00	mov	BYTE PTR [eax+31], 0
$L8476:

; 687  : 
; 688  :                 }
; 689  : 
; 690  :             }

  0010e	e9 5c ff ff ff	jmp	$L8472
$L8473:
$L8470:

; 691  : 
; 692  : 
; 693  :         }
; 694  : 
; 695  :         //
; 696  :         // Get the next line from second section IFF sectional synchronization is not
; 697  :         // required
; 698  :         //
; 699  :         if ( FunctionElements->SecondSectionSynchronize == FALSE ) {

  00113	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00116	33 c9		xor	ecx, ecx
  00118	8a 48 1d	mov	cl, BYTE PTR [eax+29]
  0011b	85 c9		test	ecx, ecx
  0011d	0f 85 af 00 00
	00		jne	$L8477

; 700  : 
; 701  :             //
; 702  :             // Keep attempting to access the next line till we do not have to skip lines
; 703  :             //
; 704  :             FunctionElements->SkipLine = TRUE;

  00123	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00126	c6 40 1f 01	mov	BYTE PTR [eax+31], 1
$L8479:

; 705  :             while ( FunctionElements->SkipLine ) {

  0012a	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0012d	33 c9		xor	ecx, ecx
  0012f	8a 48 1f	mov	cl, BYTE PTR [eax+31]
  00132	85 c9		test	ecx, ecx
  00134	0f 84 98 00 00
	00		je	$L8480

; 706  : 
; 707  :                 ClearAndSetLine(  SecondSection, &FunctionElements->SecondSectionCurrentLine );

  0013a	68 0c 02 00 00	push	524			; 0000020cH
  0013f	6a 00		push	0
  00141	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00144	05 2c 02 00 00	add	eax, 556		; 0000022cH
  00149	50		push	eax
  0014a	e8 00 00 00 00	call	_memset
  0014f	83 c4 0c	add	esp, 12			; 0000000cH
  00152	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00155	05 2c 02 00 00	add	eax, 556		; 0000022cH
  0015a	8b 4d 0c	mov	ecx, DWORD PTR _SecondSection$[ebp]
  0015d	89 81 34 01 00
	00		mov	DWORD PTR [ecx+308], eax

; 708  :                 if ( GetNextLine( SecondSection ) ) {

  00163	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00166	50		push	eax
  00167	e8 00 00 00 00	call	_GetNextLine@4
  0016c	33 c9		xor	ecx, ecx
  0016e	8a c8		mov	cl, al
  00170	85 c9		test	ecx, ecx
  00172	0f 84 3e 00 00
	00		je	$L8481

; 709  : 
; 710  :                     if ( DoNotSkipThisLine( SecondSection ) ) {

  00178	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0017b	50		push	eax
  0017c	e8 00 00 00 00	call	_DoNotSkipThisLine@4
  00181	33 c9		xor	ecx, ecx
  00183	8a c8		mov	cl, al
  00185	85 c9		test	ecx, ecx
  00187	0f 84 10 00 00
	00		je	$L8482

; 711  : 
; 712  :                         //
; 713  :                         // Since the second file section is the golden section
; 714  :                         // we do not need to extract results from the line.
; 715  :                         // However, if the program is changed for generic control
; 716  :                         // the line should be included
; 717  :                         //
; 718  :                         // ExtractResults( FirstSection );
; 719  :                         //
; 720  :                         ExtractBetweenValues( SecondSection );

  0018d	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00190	50		push	eax
  00191	e8 00 00 00 00	call	_ExtractBetweenValues@4

; 721  :                         FunctionElements->SkipLine = FALSE;

  00196	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00199	c6 40 1f 00	mov	BYTE PTR [eax+31], 0
$L8482:

; 722  : 
; 723  :                     }
; 724  :                     SecondSection->Control.SectionLineCount++;

  0019d	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  001a0	ff 80 38 01 00
	00		inc	DWORD PTR [eax+312]

; 725  :                     SecondSection->File->CurrentFileLine++;

  001a6	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  001a9	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  001af	ff 00		inc	DWORD PTR [eax]

; 726  : 
; 727  :                 }  else {

  001b1	e9 17 00 00 00	jmp	$L8483
$L8481:

; 728  : 
; 729  :                     //
; 730  :                     // Mark this line as type SECTION_END. This is actually the EOF which
; 731  :                     // is also the end of section 0.0(the file)
; 732  :                     //
; 733  :                     SecondSection->CurrentLine->LineType = LINE_TYPE_SECTION_END;

  001b6	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  001b9	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  001bf	c6 80 08 02 00
	00 02		mov	BYTE PTR [eax+520], 2

; 734  :                     FunctionElements->SkipLine           = FALSE                ;

  001c6	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  001c9	c6 40 1f 00	mov	BYTE PTR [eax+31], 0
$L8483:

; 735  : 
; 736  :                 }
; 737  : 
; 738  :             }

  001cd	e9 58 ff ff ff	jmp	$L8479
$L8480:
$L8477:

; 739  : 
; 740  :         }
; 741  : 
; 742  : 
; 743  :         //
; 744  :         // Determine the line types of both sections.
; 745  :         // The line type indicate the beggining of a section, ending of a section,
; 746  :         // or a regular line
; 747  :         //
; 748  :         LineType( FirstSection  );

  001d2	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  001d5	50		push	eax
  001d6	e8 00 00 00 00	call	_LineType@4

; 749  :         LineType( SecondSection );

  001db	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  001de	50		push	eax
  001df	e8 00 00 00 00	call	_LineType@4

; 750  : 
; 751  : 
; 752  :         //
; 753  :         // Determine the variation to be examined. The variation is simply a combination
; 754  :         // of the two line types to indicate common behavior. e.g. if the first line was
; 755  :         // a section ending and the second line was a regular line, the behaviour of
; 756  :         // the program would be the same if the line types were reversed
; 757  :         //
; 758  :         CombinedVariation( FirstSection, SecondSection, &FunctionElements->CombinedLineVariation );

  001e4	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  001e7	05 38 04 00 00	add	eax, 1080		; 00000438H
  001ec	50		push	eax
  001ed	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  001f0	50		push	eax
  001f1	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  001f4	50		push	eax
  001f5	e8 00 00 00 00	call	_CombinedVariation@12

; 759  : 
; 760  :         //
; 761  :         // And now operate on the deduced variation
; 762  :         //
; 763  :         switch( FunctionElements->CombinedLineVariation ) {

  001fa	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  001fd	33 c9		xor	ecx, ecx
  001ff	8a 88 38 04 00
	00		mov	cl, BYTE PTR [eax+1080]
  00205	89 4d f8	mov	DWORD PTR -8+[ebp], ecx
  00208	e9 0a 05 00 00	jmp	$L8484
$L8488:

; 764  : 
; 765  :             //
; 766  :             // If both lines are the beginning of new sections
; 767  :             //
; 768  :             case SECTIONHDR_SECTIONHDR:
; 769  : 
; 770  :                 //
; 771  :                 // Examine both section ID's specified in the current lines match the
; 772  :                 // following conditions
; 773  :                 // 1. The two ID's are the same
; 774  :                 // 2. The two ID do NOT match the current section ID's
; 775  :                 //
; 776  :                 if ( CheckSectionIDFromCurrentLines( FirstSection, SecondSection ) ) {

  0020d	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00210	50		push	eax
  00211	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00214	50		push	eax
  00215	e8 00 00 00 00	call	_CheckSectionIDFromCurrentLines@8
  0021a	33 c9		xor	ecx, ecx
  0021c	8a c8		mov	cl, al
  0021e	85 c9		test	ecx, ecx
  00220	0f 84 e4 01 00
	00		je	$L8489

; 777  : 
; 778  : 
; 779  :                     //
; 780  :                     // Sections have been synchronized
; 781  :                     //
; 782  :                     FunctionElements->FirstSectionSynchronize  = FALSE;

  00226	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00229	c6 40 1c 00	mov	BYTE PTR [eax+28], 0

; 783  :                     FunctionElements->SecondSectionSynchronize = FALSE;

  0022d	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00230	c6 40 1d 00	mov	BYTE PTR [eax+29], 0

; 784  : 
; 785  : 
; 786  :                     //
; 787  :                     // Create two new sections
; 788  :                     //
; 789  :                     FunctionElements->NewFirstSection  = CreateSection();

  00234	68 54 02 00 00	push	596			; 00000254H
  00239	6a 01		push	1
  0023b	e8 00 00 00 00	call	_calloc
  00240	83 c4 08	add	esp, 8
  00243	8b 4d fc	mov	ecx, DWORD PTR _FunctionElements$[ebp]
  00246	89 41 04	mov	DWORD PTR [ecx+4], eax

; 790  :                     FunctionElements->NewSecondSection = CreateSection();

  00249	68 54 02 00 00	push	596			; 00000254H
  0024e	6a 01		push	1
  00250	e8 00 00 00 00	call	_calloc
  00255	83 c4 08	add	esp, 8
  00258	8b 4d fc	mov	ecx, DWORD PTR _FunctionElements$[ebp]
  0025b	89 41 08	mov	DWORD PTR [ecx+8], eax

; 791  :                     if ( FunctionElements->NewFirstSection == (PSECTION)NULL ) {

  0025e	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00261	83 78 04 00	cmp	DWORD PTR [eax+4], 0
  00265	0f 85 38 00 00
	00		jne	$L8490

; 792  :                         printf("The system has run out of memory resources for this program\n");

  0026b	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  00270	e8 00 00 00 00	call	_printf
  00275	83 c4 04	add	esp, 4

; 793  :                         if ( FunctionElements->NewSecondSection != (PSECTION)NULL ) {

  00278	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0027b	83 78 08 00	cmp	DWORD PTR [eax+8], 0
  0027f	0f 84 0f 00 00
	00		je	$L8491

; 794  :                             DestroySection( FunctionElements->NewSecondSection );

  00285	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00288	8b 40 08	mov	eax, DWORD PTR [eax+8]
  0028b	50		push	eax
  0028c	e8 00 00 00 00	call	_free
  00291	83 c4 04	add	esp, 4
$L8491:

; 795  :                         }
; 796  :                         exit( -1 );

  00294	6a ff		push	-1
  00296	e8 00 00 00 00	call	_exit
  0029b	83 c4 04	add	esp, 4

; 797  :                     } else if ( FunctionElements->NewSecondSection == (PSECTION)NULL ) {

  0029e	e9 33 00 00 00	jmp	$L8492
$L8490:
  002a3	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  002a6	83 78 08 00	cmp	DWORD PTR [eax+8], 0
  002aa	0f 85 26 00 00
	00		jne	$L8493

; 798  :                         printf("The system has run out of memory resources for this program\n");

  002b0	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@PBJN@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  002b5	e8 00 00 00 00	call	_printf
  002ba	83 c4 04	add	esp, 4

; 799  :                         DestroySection( FunctionElements->NewFirstSection );

  002bd	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  002c0	8b 40 04	mov	eax, DWORD PTR [eax+4]
  002c3	50		push	eax
  002c4	e8 00 00 00 00	call	_free
  002c9	83 c4 04	add	esp, 4

; 800  :                         exit( -1 );

  002cc	6a ff		push	-1
  002ce	e8 00 00 00 00	call	_exit
  002d3	83 c4 04	add	esp, 4
$L8493:
$L8492:

; 801  :                     }
; 802  : 
; 803  :                     //
; 804  :                     // Initialize section control
; 805  :                     //
; 806  :                     if ( !InitializeSectionControl( FunctionElements->NewFirstSection,  FirstSection  ) ||
; 807  :                          !InitializeSectionControl( FunctionElements->NewSecondSection, SecondSection ) ) {

  002d6	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  002d9	50		push	eax
  002da	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  002dd	8b 40 04	mov	eax, DWORD PTR [eax+4]
  002e0	50		push	eax
  002e1	e8 00 00 00 00	call	_InitializeSectionControl@8
  002e6	33 c9		xor	ecx, ecx
  002e8	8a c8		mov	cl, al
  002ea	85 c9		test	ecx, ecx
  002ec	0f 84 1c 00 00
	00		je	$L8495
  002f2	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  002f5	50		push	eax
  002f6	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  002f9	8b 40 08	mov	eax, DWORD PTR [eax+8]
  002fc	50		push	eax
  002fd	e8 00 00 00 00	call	_InitializeSectionControl@8
  00302	33 c9		xor	ecx, ecx
  00304	8a c8		mov	cl, al
  00306	85 c9		test	ecx, ecx
  00308	0f 85 94 00 00
	00		jne	$L8494
$L8495:

; 808  : 
; 809  :                         //
; 810  :                         // Once again this should not occur
; 811  :                         //
; 812  :                         fprintf( DifferenceFile, "\nA BAD SECTIONAL CONTROL SEGMENT HAS BEEN DETECTED\n");

  0030e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DE@ODMB@?6A?5BAD?5SECTIONAL?5CONTROL?5SEGMENT@ ; `string'
  00313	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00316	50		push	eax
  00317	e8 00 00 00 00	call	_fprintf
  0031c	83 c4 08	add	esp, 8

; 813  :                         fprintf( DifferenceFile, "\nCHECK FOR A SYNTAX ERROR\n" );

  0031f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BL@DBNA@?6CHECK?5FOR?5A?5SYNTAX?5ERROR?6?$AA@ ; `string'
  00324	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00327	50		push	eax
  00328	e8 00 00 00 00	call	_fprintf
  0032d	83 c4 08	add	esp, 8

; 814  :                         PrintSectionInformation( FirstSection,  DifferenceFile );

  00330	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00333	50		push	eax
  00334	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00337	50		push	eax
  00338	e8 00 00 00 00	call	_PrintSectionInformation@8

; 815  :                         PrintSectionInformation( SecondSection, DifferenceFile );

  0033d	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00340	50		push	eax
  00341	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00344	50		push	eax
  00345	e8 00 00 00 00	call	_PrintSectionInformation@8

; 816  :                         //
; 817  :                         // Free up the resources allocates
; 818  :                         //
; 819  :                         DestroySection( FunctionElements->NewFirstSection  );

  0034a	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0034d	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00350	50		push	eax
  00351	e8 00 00 00 00	call	_free
  00356	83 c4 04	add	esp, 4

; 820  :                         DestroySection( FunctionElements->NewSecondSection );

  00359	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0035c	8b 40 08	mov	eax, DWORD PTR [eax+8]
  0035f	50		push	eax
  00360	e8 00 00 00 00	call	_free
  00365	83 c4 04	add	esp, 4

; 821  : 
; 822  :                         //
; 823  :                         // Reset and compare as regular lines
; 824  :                         //
; 825  :                         FirstSection->CurrentLine->LineType    = LINE_TYPE_REGULAR;

  00368	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0036b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00371	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 826  :                         SecondSection->CurrentLine->LineType   = LINE_TYPE_REGULAR;

  00378	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0037b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00381	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 827  : 
; 828  :                         CompareLinesAndPrintResults( FirstSection,
; 829  :                                                      SecondSection,
; 830  :                                                      &FunctionElements->ErrorCount,
; 831  :                                                      DifferenceFile );

  00388	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0038b	50		push	eax
  0038c	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0038f	50		push	eax
  00390	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00393	50		push	eax
  00394	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00397	50		push	eax
  00398	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16

; 832  :                     } else {

  0039d	e9 63 00 00 00	jmp	$L8498
$L8494:

; 833  : 
; 834  : 
; 835  :                         //
; 836  :                         // Compare the two new sections
; 837  :                         //
; 838  :                         CompareSections( FunctionElements->NewFirstSection,
; 839  :                                          FunctionElements->NewSecondSection,
; 840  :                                          DifferenceFile,
; 841  :                                          FileDifferenceCounter );

  003a2	8b 45 14	mov	eax, DWORD PTR _FileDifferenceCounter$[ebp]
  003a5	50		push	eax
  003a6	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  003a9	50		push	eax
  003aa	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  003ad	8b 40 08	mov	eax, DWORD PTR [eax+8]
  003b0	50		push	eax
  003b1	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  003b4	8b 40 04	mov	eax, DWORD PTR [eax+4]
  003b7	50		push	eax
  003b8	e8 00 00 00 00	call	_CompareSections@16

; 842  : 
; 843  :                         //
; 844  :                         // Readjust the current line counters for the First and Second
; 845  :                         // Sections
; 846  :                         //
; 847  :                         FirstSection->Control.SectionLineCount  +=
; 848  :                         FunctionElements->NewFirstSection->Control.SectionLineCount;

  003bd	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  003c0	8b 40 04	mov	eax, DWORD PTR [eax+4]
  003c3	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  003c9	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  003cc	01 81 38 01 00
	00		add	DWORD PTR [ecx+312], eax

; 849  : 
; 850  :                         SecondSection->Control.SectionLineCount +=
; 851  :                         FunctionElements->NewSecondSection->Control.SectionLineCount;

  003d2	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  003d5	8b 40 08	mov	eax, DWORD PTR [eax+8]
  003d8	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  003de	8b 4d 0c	mov	ecx, DWORD PTR _SecondSection$[ebp]
  003e1	01 81 38 01 00
	00		add	DWORD PTR [ecx+312], eax

; 852  : 
; 853  :                         //
; 854  :                         // Free up the resources allocates
; 855  :                         //
; 856  :                         DestroySection( FunctionElements->NewFirstSection  );

  003e7	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  003ea	8b 40 04	mov	eax, DWORD PTR [eax+4]
  003ed	50		push	eax
  003ee	e8 00 00 00 00	call	_free
  003f3	83 c4 04	add	esp, 4

; 857  :                         DestroySection( FunctionElements->NewSecondSection );

  003f6	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  003f9	8b 40 08	mov	eax, DWORD PTR [eax+8]
  003fc	50		push	eax
  003fd	e8 00 00 00 00	call	_free
  00402	83 c4 04	add	esp, 4
$L8498:

; 858  : 
; 859  :                     }
; 860  : 
; 861  :                 } else {

  00405	e9 43 00 00 00	jmp	$L8499
$L8489:

; 862  : 
; 863  :                     //
; 864  :                     // Force  synchronize the sections
; 865  :                     //
; 866  :                     FunctionElements->FirstSectionSynchronize  = FALSE;

  0040a	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0040d	c6 40 1c 00	mov	BYTE PTR [eax+28], 0

; 867  :                     FunctionElements->SecondSectionSynchronize = FALSE;

  00411	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00414	c6 40 1d 00	mov	BYTE PTR [eax+29], 0

; 868  : 
; 869  :                     //
; 870  :                     // switch them to regular lines.
; 871  :                     // This condition should never be reached and if so treat these
; 872  :                     // lines as regular lines
; 873  :                     //
; 874  :                     FirstSection->CurrentLine->LineType    = LINE_TYPE_REGULAR;

  00418	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0041b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00421	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 875  :                     SecondSection->CurrentLine->LineType   = LINE_TYPE_REGULAR;

  00428	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0042b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00431	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 876  : 
; 877  :                     CompareLinesAndPrintResults( FirstSection,
; 878  :                                                  SecondSection,
; 879  :                                                  &FunctionElements->ErrorCount,
; 880  :                                                  DifferenceFile );

  00438	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0043b	50		push	eax
  0043c	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0043f	50		push	eax
  00440	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00443	50		push	eax
  00444	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00447	50		push	eax
  00448	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16
$L8499:

; 881  :                 }
; 882  :                 break;

  0044d	e9 f4 02 00 00	jmp	$L8485
$L8500:

; 883  : 
; 884  : 
; 885  :              //
; 886  :              // If both lines are ends of sections
; 887  :              //
; 888  :              case SECTIONEND_SECTIONEND:
; 889  : 
; 890  :                 FunctionElements->FirstSectionID   = ExtractSectionIDFromLine( FirstSection  );

  00452	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00455	50		push	eax
  00456	e8 00 00 00 00	call	_ExtractSectionIDFromLine@4
  0045b	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0045e	dd 58 0c	fstp	QWORD PTR [eax+12]

; 891  :                 FunctionElements->SecondSectionID  = ExtractSectionIDFromLine( SecondSection );

  00461	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00464	50		push	eax
  00465	e8 00 00 00 00	call	_ExtractSectionIDFromLine@4
  0046a	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0046d	dd 58 14	fstp	QWORD PTR [eax+20]

; 892  : 
; 893  :                 //
; 894  :                 // Global section control. Ends section comparisons.
; 895  :                 //
; 896  :                 if ( FunctionElements->FirstSectionID > FunctionElements->SecondSectionID ) {

  00470	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00473	dd 40 14	fld	QWORD PTR [eax+20]
  00476	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00479	dc 58 0c	fcomp	QWORD PTR [eax+12]
  0047c	df e0		fnstsw	ax
  0047e	f6 c4 01	test	ah, 1
  00481	0f 84 38 00 00
	00		je	$L8501

; 897  : 
; 898  :                     FunctionElements->FirstSectionSynchronize  = FALSE;

  00487	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0048a	c6 40 1c 00	mov	BYTE PTR [eax+28], 0

; 899  :                     FunctionElements->SecondSectionSynchronize = TRUE;

  0048e	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00491	c6 40 1d 01	mov	BYTE PTR [eax+29], 1

; 900  : 
; 901  :                     FirstSection->CurrentLine->LineType        = LINE_TYPE_REGULAR;

  00495	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00498	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0049e	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 902  : 
; 903  :                     CompareLinesAndPrintResults( FirstSection,
; 904  :                                                  SecondSection,
; 905  :                                                  &FunctionElements->ErrorCount,
; 906  :                                                  DifferenceFile );

  004a5	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  004a8	50		push	eax
  004a9	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  004ac	50		push	eax
  004ad	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  004b0	50		push	eax
  004b1	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  004b4	50		push	eax
  004b5	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16

; 907  : 
; 908  :                 } else if ( FunctionElements->FirstSectionID < FunctionElements->SecondSectionID ) {

  004ba	e9 e1 00 00 00	jmp	$L8502
$L8501:
  004bf	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  004c2	dd 40 14	fld	QWORD PTR [eax+20]
  004c5	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  004c8	dc 58 0c	fcomp	QWORD PTR [eax+12]
  004cb	df e0		fnstsw	ax
  004cd	f6 c4 41	test	ah, 65			; 00000041H
  004d0	0f 85 38 00 00
	00		jne	$L8503

; 909  : 
; 910  :                     FunctionElements->FirstSectionSynchronize  = TRUE;

  004d6	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  004d9	c6 40 1c 01	mov	BYTE PTR [eax+28], 1

; 911  :                     FunctionElements->SecondSectionSynchronize = FALSE;

  004dd	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  004e0	c6 40 1d 00	mov	BYTE PTR [eax+29], 0

; 912  : 
; 913  :                     SecondSection->CurrentLine->LineType       = LINE_TYPE_REGULAR;

  004e4	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  004e7	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  004ed	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 914  : 
; 915  :                     CompareLinesAndPrintResults( FirstSection,
; 916  :                                                  SecondSection,
; 917  :                                                  &FunctionElements->ErrorCount,
; 918  :                                                  DifferenceFile );

  004f4	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  004f7	50		push	eax
  004f8	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  004fb	50		push	eax
  004fc	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  004ff	50		push	eax
  00500	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00503	50		push	eax
  00504	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16

; 919  :                 } else {

  00509	e9 92 00 00 00	jmp	$L8504
$L8503:

; 920  : 
; 921  :                     //
; 922  :                     // Sections are synchronized
; 923  :                     //
; 924  :                     FunctionElements->FirstSectionSynchronize  = FALSE;

  0050e	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00511	c6 40 1c 00	mov	BYTE PTR [eax+28], 0

; 925  :                     FunctionElements->SecondSectionSynchronize = FALSE;

  00515	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00518	c6 40 1d 00	mov	BYTE PTR [eax+29], 0

; 926  : 
; 927  : 
; 928  :                     //
; 929  :                     // Now make sure that the extracted section IDs match the
; 930  :                     // current section ID
; 931  :                     //
; 932  :                     if ( FunctionElements->FirstSectionID == FirstSection->Control.SectionIdentifier ) {

  0051c	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0051f	dd 80 48 01 00
	00		fld	QWORD PTR [eax+328]
  00525	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00528	dc 58 0c	fcomp	QWORD PTR [eax+12]
  0052b	df e0		fnstsw	ax
  0052d	f6 c4 40	test	ah, 64			; 00000040H
  00530	0f 84 35 00 00
	00		je	$L8505

; 933  : 
; 934  :                         //
; 935  :                         // ALL TOKEN MATCHING IS DONE AT THE ENDS OF SECTIONS
; 936  :                         //
; 937  :                         if ( SecondSection->Control.TokenMatching == TRUE ) {

  00536	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00539	33 c9		xor	ecx, ecx
  0053b	8a 88 51 01 00
	00		mov	cl, BYTE PTR [eax+337]
  00541	83 f9 01	cmp	ecx, 1
  00544	0f 85 15 00 00
	00		jne	$L8506

; 938  : 
; 939  :                             CompareTokensAndPrintResults( FirstSection,
; 940  :                                                           SecondSection,
; 941  :                                                           &FunctionElements->ErrorCount,
; 942  :                                                           DifferenceFile );

  0054a	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0054d	50		push	eax
  0054e	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00551	50		push	eax
  00552	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00555	50		push	eax
  00556	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00559	50		push	eax
  0055a	e8 00 00 00 00	call	_CompareTokensAndPrintResults@16
$L8506:

; 943  :                         }
; 944  : 
; 945  :                         FunctionElements->SectionEndsNotSynchronized      = FALSE;

  0055f	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00562	c6 40 1e 00	mov	BYTE PTR [eax+30], 0

; 946  : 
; 947  :                     } else {

  00566	e9 35 00 00 00	jmp	$L8507
$L8505:

; 948  : 
; 949  :                         //
; 950  :                         // Switch them to regular lines
; 951  :                         //
; 952  :                         FirstSection->CurrentLine->LineType        = LINE_TYPE_REGULAR;

  0056b	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0056e	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00574	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 953  :                         SecondSection->CurrentLine->LineType       = LINE_TYPE_REGULAR;

  0057b	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0057e	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00584	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 954  : 
; 955  :                         CompareLinesAndPrintResults( FirstSection,
; 956  :                                                      SecondSection,
; 957  :                                                      &FunctionElements->ErrorCount,
; 958  :                                                      DifferenceFile );

  0058b	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0058e	50		push	eax
  0058f	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00592	50		push	eax
  00593	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00596	50		push	eax
  00597	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0059a	50		push	eax
  0059b	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16
$L8507:
$L8504:
$L8502:

; 959  : 
; 960  :                     }
; 961  : 
; 962  :                 }
; 963  : 
; 964  :                 break;

  005a0	e9 a1 01 00 00	jmp	$L8485
$L8508:

; 965  : 
; 966  : 
; 967  :             //
; 968  :             // If one line is the beggining of a section
; 969  :             // and the other is the end of a section
; 970  :             //
; 971  :             case SECTIONHDR_SECTIONEND:
; 972  : 
; 973  :                 //
; 974  :                 // We have come across the case where another section has been detected
; 975  :                 // while another was ending.
; 976  :                 //
; 977  :                 if ( FirstSection->CurrentLine->LineType == LINE_TYPE_SECTION_END ) {

  005a5	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  005a8	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  005ae	33 c9		xor	ecx, ecx
  005b0	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  005b6	83 f9 02	cmp	ecx, 2
  005b9	0f 85 1c 00 00
	00		jne	$L8509

; 978  : 
; 979  :                     FunctionElements->FirstSectionSynchronize = TRUE;

  005bf	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  005c2	c6 40 1c 01	mov	BYTE PTR [eax+28], 1

; 980  :                     SecondSection->CurrentLine->LineType     = LINE_TYPE_REGULAR;

  005c6	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  005c9	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  005cf	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 981  : 
; 982  :                 } else {

  005d6	e9 17 00 00 00	jmp	$L8510
$L8509:

; 983  : 
; 984  :                     FunctionElements->SecondSectionSynchronize = TRUE;

  005db	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  005de	c6 40 1d 01	mov	BYTE PTR [eax+29], 1

; 985  :                     FirstSection->CurrentLine->LineType       = LINE_TYPE_REGULAR;

  005e2	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  005e5	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  005eb	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3
$L8510:

; 986  : 
; 987  :                 }
; 988  : 
; 989  :                 CompareLinesAndPrintResults( FirstSection,
; 990  :                                              SecondSection,
; 991  :                                              &FunctionElements->ErrorCount,
; 992  :                                              DifferenceFile );

  005f2	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  005f5	50		push	eax
  005f6	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  005f9	50		push	eax
  005fa	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  005fd	50		push	eax
  005fe	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00601	50		push	eax
  00602	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16

; 993  :                 break;

  00607	e9 3a 01 00 00	jmp	$L8485
$L8511:

; 994  : 
; 995  : 
; 996  :             //
; 997  :             // If one line is the beggining of a section and the other
; 998  :             // is  a regular line
; 999  :             //
; 1000 :             case SECTIONHDR_REGLINE   :
; 1001 : 
; 1002 :                 //
; 1003 :                 // We have come to a point where a section header has been detected
; 1004 :                 // in one section and a regular line in another
; 1005 :                 // This forces us to now attempt to re-synchronize the sections
; 1006 :                 //
; 1007 :                 if ( FirstSection->CurrentLine->LineType == LINE_TYPE_SECTION_START ) {

  0060c	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0060f	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00615	33 c9		xor	ecx, ecx
  00617	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0061d	83 f9 01	cmp	ecx, 1
  00620	0f 85 3b 00 00
	00		jne	$L8512

; 1008 : 
; 1009 :                     if ( ExtractSectionIDFromLine( FirstSection ) != (DOUBLE)0 ) {

  00626	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00629	50		push	eax
  0062a	e8 00 00 00 00	call	_ExtractSectionIDFromLine@4
  0062f	dc 1d 00 00 00
	00		fcomp	QWORD PTR $T8934
  00635	df e0		fnstsw	ax
  00637	f6 c4 40	test	ah, 64			; 00000040H
  0063a	0f 85 0c 00 00
	00		jne	$L8513

; 1010 : 
; 1011 :                         FunctionElements->FirstSectionSynchronize = TRUE;

  00640	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00643	c6 40 1c 01	mov	BYTE PTR [eax+28], 1

; 1012 : 
; 1013 :                     }  else {

  00647	e9 10 00 00 00	jmp	$L8514
$L8513:

; 1014 : 
; 1015 :                         //
; 1016 :                         // Simply RESET this line as a regular line and compare
; 1017 :                         //
; 1018 :                         FirstSection->CurrentLine->LineType = LINE_TYPE_REGULAR;

  0064c	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0064f	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00655	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3
$L8514:

; 1019 : 
; 1020 :                     }
; 1021 : 
; 1022 :                 } else {

  0065c	e9 36 00 00 00	jmp	$L8515
$L8512:

; 1023 : 
; 1024 :                     if ( ExtractSectionIDFromLine( SecondSection ) != (DOUBLE)0 ) {

  00661	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00664	50		push	eax
  00665	e8 00 00 00 00	call	_ExtractSectionIDFromLine@4
  0066a	dc 1d 00 00 00
	00		fcomp	QWORD PTR $T8934
  00670	df e0		fnstsw	ax
  00672	f6 c4 40	test	ah, 64			; 00000040H
  00675	0f 85 0c 00 00
	00		jne	$L8516

; 1025 : 
; 1026 :                         FunctionElements->SecondSectionSynchronize = TRUE;

  0067b	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0067e	c6 40 1d 01	mov	BYTE PTR [eax+29], 1

; 1027 : 
; 1028 :                     } else {

  00682	e9 10 00 00 00	jmp	$L8517
$L8516:

; 1029 : 
; 1030 :                         //
; 1031 :                         // Simply RESET this line as a regular line and compare
; 1032 :                         //
; 1033 :                         SecondSection->CurrentLine->LineType = LINE_TYPE_REGULAR;

  00687	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0068a	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00690	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3
$L8517:
$L8515:

; 1034 : 
; 1035 :                     }
; 1036 : 
; 1037 : 
; 1038 :                 }
; 1039 : 
; 1040 :                 CompareLinesAndPrintResults( FirstSection,
; 1041 :                                              SecondSection,
; 1042 :                                              &FunctionElements->ErrorCount,
; 1043 :                                              DifferenceFile );

  00697	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0069a	50		push	eax
  0069b	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0069e	50		push	eax
  0069f	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  006a2	50		push	eax
  006a3	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  006a6	50		push	eax
  006a7	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16

; 1044 :                 break;

  006ac	e9 95 00 00 00	jmp	$L8485
$L8518:

; 1045 : 
; 1046 : 
; 1047 :             //
; 1048 :             // If one line is the end of a section and
; 1049 :             // the other is a regular line
; 1050 :             //
; 1051 :             case SECTIONEND_REGLINE   :
; 1052 : 
; 1053 :                 //
; 1054 :                 // We have come to a point where a section end has been detected
; 1055 :                 // in one section and a regular line in another
; 1056 :                 // This forces us to now attempt to re-synchronize the sections
; 1057 :                 //
; 1058 :                 if ( FirstSection->CurrentLine->LineType == LINE_TYPE_SECTION_END ) {

  006b1	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  006b4	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  006ba	33 c9		xor	ecx, ecx
  006bc	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  006c2	83 f9 02	cmp	ecx, 2
  006c5	0f 85 0c 00 00
	00		jne	$L8519

; 1059 : 
; 1060 :                     FunctionElements->FirstSectionSynchronize = TRUE;

  006cb	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  006ce	c6 40 1c 01	mov	BYTE PTR [eax+28], 1

; 1061 : 
; 1062 :                 } else {

  006d2	e9 07 00 00 00	jmp	$L8520
$L8519:

; 1063 : 
; 1064 :                     FunctionElements->SecondSectionSynchronize = TRUE;

  006d7	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  006da	c6 40 1d 01	mov	BYTE PTR [eax+29], 1
$L8520:

; 1065 : 
; 1066 :                 }
; 1067 : 
; 1068 :                 CompareLinesAndPrintResults( FirstSection,
; 1069 :                                              SecondSection,
; 1070 :                                              &FunctionElements->ErrorCount,
; 1071 :                                              DifferenceFile );

  006de	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  006e1	50		push	eax
  006e2	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  006e5	50		push	eax
  006e6	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  006e9	50		push	eax
  006ea	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  006ed	50		push	eax
  006ee	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16

; 1072 :                 break;

  006f3	e9 4e 00 00 00	jmp	$L8485
$L8521:

; 1073 : 
; 1074 :             //
; 1075 :             // If both lines are regular lines
; 1076 :             //
; 1077 :             case REGLINE_REGLINE      :
; 1078 : 
; 1079 :                 CompareLinesAndPrintResults( FirstSection,
; 1080 :                                              SecondSection,
; 1081 :                                              &FunctionElements->ErrorCount,
; 1082 :                                              DifferenceFile );

  006f8	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  006fb	50		push	eax
  006fc	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  006ff	50		push	eax
  00700	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00703	50		push	eax
  00704	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00707	50		push	eax
  00708	e8 00 00 00 00	call	_CompareLinesAndPrintResults@16

; 1083 : 
; 1084 :                 break;

  0070d	e9 34 00 00 00	jmp	$L8485

; 1085 : 
; 1086 : 
; 1087 :         } // !switch{}

  00712	e9 2f 00 00 00	jmp	$L8485
$L8484:
  00717	ff 4d f8	dec	DWORD PTR -8+[ebp]
  0071a	83 7d f8 05	cmp	DWORD PTR -8+[ebp], 5
  0071e	0f 87 22 00 00
	00		ja	$L8485
  00724	8b 45 f8	mov	eax, DWORD PTR -8+[ebp]
  00727	ff 24 85 00 00
	00 00		jmp	DWORD PTR $L8935[eax*4]
$L8935:
  0072e	00 00 00 00	DD	OFFSET FLAT:$L8488
  00732	00 00 00 00	DD	OFFSET FLAT:$L8508
  00736	00 00 00 00	DD	OFFSET FLAT:$L8511
  0073a	00 00 00 00	DD	OFFSET FLAT:$L8500
  0073e	00 00 00 00	DD	OFFSET FLAT:$L8518
  00742	00 00 00 00	DD	OFFSET FLAT:$L8521
$L8485:

; 1088 : 
; 1089 : 
; 1090 :     }  // !while( FunctionElements->SectionEndsNotSynchronized )

  00746	e9 fd f8 ff ff	jmp	$L8468
$L8469:

; 1091 : 
; 1092 : 
; 1093 :     //
; 1094 :     // Print out the section comparison results
; 1095 :     //
; 1096 :     if ( FunctionElements->ErrorCount ) {

  0074b	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0074e	83 38 00	cmp	DWORD PTR [eax], 0
  00751	0f 84 28 00 00
	00		je	$L8522

; 1097 : 
; 1098 :         fprintf( DifferenceFile, "\n\n__SECTIONAL RESULTS FOR SECTION ID : %f ERROR(S): %u\n",
; 1099 :                  SecondSection->Control.SectionIdentifier,
; 1100 :                  FunctionElements->ErrorCount );

  00757	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0075a	8b 00		mov	eax, DWORD PTR [eax]
  0075c	50		push	eax
  0075d	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00760	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  00766	51		push	ecx
  00767	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  0076d	50		push	eax
  0076e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DI@EGAP@?6?6__SECTIONAL?5RESULTS?5FOR?5SECTIO@ ; `string'
  00773	8b 45 10	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00776	50		push	eax
  00777	e8 00 00 00 00	call	_fprintf
  0077c	83 c4 14	add	esp, 20			; 00000014H
$L8522:

; 1101 : 
; 1102 :     }
; 1103 : 
; 1104 :     //
; 1105 :     // Cleanup
; 1106 :     //
; 1107 :     *FileDifferenceCounter += FunctionElements->ErrorCount;

  0077f	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  00782	8b 00		mov	eax, DWORD PTR [eax]
  00784	8b 4d 14	mov	ecx, DWORD PTR _FileDifferenceCounter$[ebp]
  00787	01 01		add	DWORD PTR [ecx], eax

; 1108 :     DestroyFunctionElements( FunctionElements );

  00789	8b 45 fc	mov	eax, DWORD PTR _FunctionElements$[ebp]
  0078c	50		push	eax
  0078d	e8 00 00 00 00	call	_free
  00792	83 c4 04	add	esp, 4

; 1109 :     return TRUE;

  00795	b0 01		mov	al, 1
  00797	e9 00 00 00 00	jmp	$L8463
$L8463:

; 1110 : 
; 1111 : 
; 1112 : }

  0079c	5f		pop	edi
  0079d	5e		pop	esi
  0079e	5b		pop	ebx
  0079f	c9		leave
  007a0	c2 10 00	ret	16			; 00000010H
_CompareSections@16 ENDP
_TEXT	ENDS
EXTRN	__pctype:DWORD
EXTRN	__isctype:NEAR
EXTRN	_toupper:NEAR
EXTRN	___mb_cur_max:DWORD
;	COMDAT _GetNextLine@4
_TEXT	SEGMENT
_Section$ = 8
_i$ = -8
_j$ = -12
_Tmp$ = -4
_GetNextLine@4 PROC NEAR				; COMDAT

; 1119 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 10	sub	esp, 16			; 00000010H
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 1120 :     UINT     i,j;
; 1121 :     PCHAR    Tmp;
; 1122 : 
; 1123 :     //
; 1124 :     // Get the normal line. Read in until MAX_LINE_SIZE-1. This is done to ensure that
; 1125 :     // should the line be longer, only the first MAX_LINE_SIZE-1 bytes are read in and
; 1126 :     // the last byte is 0.
; 1127 :     //
; 1128 :     if ( fgets( Section->CurrentLine->NormalLine,
; 1129 :                 (sizeof( Section->CurrentLine->NormalLine )-1),
; 1130 :                 Section->File->FileP
; 1131 :               ) != NULL ) {

  00009	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0000c	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00012	8b 40 08	mov	eax, DWORD PTR [eax+8]
  00015	50		push	eax
  00016	68 ff 00 00 00	push	255			; 000000ffH
  0001b	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0001e	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00024	83 c0 08	add	eax, 8
  00027	50		push	eax
  00028	e8 00 00 00 00	call	_fgets
  0002d	83 c4 0c	add	esp, 12			; 0000000cH
  00030	85 c0		test	eax, eax
  00032	0f 84 24 01 00
	00		je	$L8529

; 1132 : 
; 1133 :         //
; 1134 :         // Replace the first occurence of a new line with a null
; 1135 :         //
; 1136 :         Tmp = strchr( Section->CurrentLine->NormalLine, '\n');

  00038	6a 0a		push	10			; 0000000aH
  0003a	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0003d	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00043	83 c0 08	add	eax, 8
  00046	50		push	eax
  00047	e8 00 00 00 00	call	_strchr
  0004c	83 c4 08	add	esp, 8
  0004f	89 45 fc	mov	DWORD PTR _Tmp$[ebp], eax

; 1137 :         if ( Tmp != (PCHAR)NULL ) {

  00052	83 7d fc 00	cmp	DWORD PTR _Tmp$[ebp], 0
  00056	0f 84 06 00 00
	00		je	$L8530

; 1138 : 
; 1139 :             *Tmp = '\0';

  0005c	8b 45 fc	mov	eax, DWORD PTR _Tmp$[ebp]
  0005f	c6 00 00	mov	BYTE PTR [eax], 0
$L8530:

; 1140 : 
; 1141 :         }
; 1142 : 
; 1143 :         Section->CurrentLine->NormalLineSize = strlen( Section->CurrentLine->NormalLine );

  00062	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00065	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0006b	83 c0 08	add	eax, 8
  0006e	50		push	eax
  0006f	e8 00 00 00 00	call	_strlen
  00074	83 c4 04	add	esp, 4
  00077	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  0007a	8b 89 34 01 00
	00		mov	ecx, DWORD PTR [ecx+308]
  00080	89 01		mov	DWORD PTR [ecx], eax

; 1144 : 
; 1145 : 
; 1146 :         //
; 1147 :         // Obtain a compressed uppercase version of the line
; 1148 :         //
; 1149 :         for( i = 0, j = 0 ; i < strlen( Section->CurrentLine->NormalLine ); i++ ) {

  00082	c7 45 f8 00 00
	00 00		mov	DWORD PTR _i$[ebp], 0
  00089	c7 45 f4 00 00
	00 00		mov	DWORD PTR _j$[ebp], 0
  00090	e9 03 00 00 00	jmp	$L8531
$L8532:
  00095	ff 45 f8	inc	DWORD PTR _i$[ebp]
$L8531:
  00098	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0009b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000a1	83 c0 08	add	eax, 8
  000a4	50		push	eax
  000a5	e8 00 00 00 00	call	_strlen
  000aa	83 c4 04	add	esp, 4
  000ad	3b 45 f8	cmp	eax, DWORD PTR _i$[ebp]
  000b0	0f 86 9f 00 00
	00		jbe	$L8533

; 1150 : 
; 1151 :             if ( isspace( Section->CurrentLine->NormalLine[i] ) == 0 ) {

  000b6	83 3d 00 00 00
	00 01		cmp	DWORD PTR ___mb_cur_max, 1
  000bd	0f 8e 24 00 00
	00		jle	$L8939
  000c3	6a 08		push	8
  000c5	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000c8	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000ce	8b 4d f8	mov	ecx, DWORD PTR _i$[ebp]
  000d1	0f be 44 08 08	movsx	eax, BYTE PTR [eax+ecx+8]
  000d6	50		push	eax
  000d7	e8 00 00 00 00	call	__isctype
  000dc	83 c4 08	add	esp, 8
  000df	89 45 f0	mov	DWORD PTR -16+[ebp], eax
  000e2	e9 23 00 00 00	jmp	$L8940
$L8939:
  000e7	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000ea	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000f0	8b 4d f8	mov	ecx, DWORD PTR _i$[ebp]
  000f3	0f be 44 08 08	movsx	eax, BYTE PTR [eax+ecx+8]
  000f8	8b 0d 00 00 00
	00		mov	ecx, DWORD PTR __pctype
  000fe	33 d2		xor	edx, edx
  00100	66 8b 14 41	mov	dx, WORD PTR [ecx+eax*2]
  00104	83 e2 08	and	edx, 8
  00107	89 55 f0	mov	DWORD PTR -16+[ebp], edx
$L8940:
  0010a	83 7d f0 00	cmp	DWORD PTR -16+[ebp], 0
  0010e	0f 85 3c 00 00
	00		jne	$L8534

; 1152 : 
; 1153 :                 Section->CurrentLine->CompressedLine[j] = toupper( Section->CurrentLine->NormalLine[i] );

  00114	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00117	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0011d	8b 4d f8	mov	ecx, DWORD PTR _i$[ebp]
  00120	0f be 44 08 08	movsx	eax, BYTE PTR [eax+ecx+8]
  00125	50		push	eax
  00126	e8 00 00 00 00	call	_toupper
  0012b	83 c4 04	add	esp, 4
  0012e	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00131	8b 89 34 01 00
	00		mov	ecx, DWORD PTR [ecx+308]
  00137	8b 55 f4	mov	edx, DWORD PTR _j$[ebp]
  0013a	88 84 11 08 01
	00 00		mov	BYTE PTR [ecx+edx+264], al

; 1154 : 
; 1155 :                 Section->CurrentLine->CompressedLineSize++;

  00141	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00144	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0014a	ff 40 04	inc	DWORD PTR [eax+4]

; 1156 :                 j++;

  0014d	ff 45 f4	inc	DWORD PTR _j$[ebp]
$L8534:

; 1157 : 
; 1158 :             }
; 1159 : 
; 1160 :         }

  00150	e9 40 ff ff ff	jmp	$L8532
$L8533:

; 1161 : 
; 1162 :         //
; 1163 :         // And return
; 1164 :         //
; 1165 :         return TRUE;

  00155	b0 01		mov	al, 1
  00157	e9 07 00 00 00	jmp	$L8525
$L8529:

; 1166 : 
; 1167 :     }
; 1168 : 
; 1169 :     //
; 1170 :     // This indicates an EOF has been reached
; 1171 :     //
; 1172 :     return FALSE;

  0015c	32 c0		xor	al, al
  0015e	e9 00 00 00 00	jmp	$L8525
$L8525:

; 1173 : 
; 1174 : }

  00163	5f		pop	edi
  00164	5e		pop	esi
  00165	5b		pop	ebx
  00166	c9		leave
  00167	c2 04 00	ret	4
_GetNextLine@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NEDE@MAY_DIFFER?$AA@			; `string'
EXTRN	_strstr:NEAR
;	COMDAT ??_C@_0L@NEDE@MAY_DIFFER?$AA@
CONST	SEGMENT
??_C@_0L@NEDE@MAY_DIFFER?$AA@ DB 'MAY_DIFFER', 00H	; `string'
CONST	ENDS
;	COMDAT _LineType@4
_TEXT	SEGMENT
_Section$ = 8
_LineType@4 PROC NEAR					; COMDAT

; 1181 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	53		push	ebx
  00004	56		push	esi
  00005	57		push	edi

; 1182 :     //
; 1183 :     // If while entering the line type was marked as SECTION_END
; 1184 :     // it indicates the EOF has been encountered. Since EOF is also
; 1185 :     // the end of section ID 0.0, the line is premarked
; 1186 :     // is read. This is the only special type which is premarked
; 1187 :     //
; 1188 :     if ( Section->CurrentLine->LineType == LINE_TYPE_SECTION_END ) {

  00006	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00009	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0000f	33 c9		xor	ecx, ecx
  00011	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00017	83 f9 02	cmp	ecx, 2
  0001a	0f 85 05 00 00
	00		jne	$L8537

; 1189 : 
; 1190 :         return;

  00020	e9 c2 00 00 00	jmp	$L8536
$L8537:

; 1191 : 
; 1192 :     }
; 1193 : 
; 1194 :     //
; 1195 :     // If the line contains a MAY_DIFFER, irrespective of what the control
; 1196 :     // is it is turned into a regular line
; 1197 :     //
; 1198 :     if ( strstr( Section->CurrentLine->CompressedLine, "MAY_DIFFER" ) != NULL ) {

  00025	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@NEDE@MAY_DIFFER?$AA@ ; `string'
  0002a	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0002d	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00033	05 08 01 00 00	add	eax, 264		; 00000108H
  00038	50		push	eax
  00039	e8 00 00 00 00	call	_strstr
  0003e	83 c4 08	add	esp, 8
  00041	85 c0		test	eax, eax
  00043	0f 84 15 00 00
	00		je	$L8538

; 1199 : 
; 1200 :         Section->CurrentLine->LineType = LINE_TYPE_REGULAR;

  00049	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0004c	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00052	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 1201 :         return;

  00059	e9 89 00 00 00	jmp	$L8536
$L8538:

; 1202 :     }
; 1203 : 
; 1204 :     //
; 1205 :     // Search for the special keyword -SECTION_START-
; 1206 :     //
; 1207 :     if ( strstr( Section->CurrentLine->CompressedLine, Keywords[SECTION_START] ) != NULL ) {

  0005e	a1 00 00 00 00	mov	eax, DWORD PTR _Keywords
  00063	50		push	eax
  00064	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00067	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0006d	05 08 01 00 00	add	eax, 264		; 00000108H
  00072	50		push	eax
  00073	e8 00 00 00 00	call	_strstr
  00078	83 c4 08	add	esp, 8
  0007b	85 c0		test	eax, eax
  0007d	0f 84 15 00 00
	00		je	$L8540

; 1208 : 
; 1209 :         Section->CurrentLine->LineType = LINE_TYPE_SECTION_START;

  00083	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00086	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0008c	c6 80 08 02 00
	00 01		mov	BYTE PTR [eax+520], 1

; 1210 :         return;

  00093	e9 4f 00 00 00	jmp	$L8536
$L8540:

; 1211 :     }
; 1212 : 
; 1213 :     //
; 1214 :     // Search for the special keyword -SECTION_END-
; 1215 :     //
; 1216 :     if ( strstr( Section->CurrentLine->CompressedLine, Keywords[SECTION_END] ) != NULL ) {

  00098	a1 04 00 00 00	mov	eax, DWORD PTR _Keywords+4
  0009d	50		push	eax
  0009e	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000a1	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000a7	05 08 01 00 00	add	eax, 264		; 00000108H
  000ac	50		push	eax
  000ad	e8 00 00 00 00	call	_strstr
  000b2	83 c4 08	add	esp, 8
  000b5	85 c0		test	eax, eax
  000b7	0f 84 15 00 00
	00		je	$L8541

; 1217 : 
; 1218 :         Section->CurrentLine->LineType = LINE_TYPE_SECTION_END;

  000bd	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000c0	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000c6	c6 80 08 02 00
	00 02		mov	BYTE PTR [eax+520], 2

; 1219 :         return;

  000cd	e9 15 00 00 00	jmp	$L8536
$L8541:

; 1220 :     }
; 1221 : 
; 1222 :     Section->CurrentLine->LineType = LINE_TYPE_REGULAR;

  000d2	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000d5	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000db	c6 80 08 02 00
	00 03		mov	BYTE PTR [eax+520], 3

; 1223 :     return;

  000e2	e9 00 00 00 00	jmp	$L8536
$L8536:

; 1224 : 
; 1225 : }

  000e7	5f		pop	edi
  000e8	5e		pop	esi
  000e9	5b		pop	ebx
  000ea	c9		leave
  000eb	c2 04 00	ret	4
_LineType@4 ENDP
_TEXT	ENDS
EXTRN	_strrchr:NEAR
EXTRN	_atol:NEAR
;	COMDAT _ExtractResults@4
_TEXT	SEGMENT
_Section$ = 8
_TmpBuf$ = -8
_Token$ = -20
_ExtractMoreResults$ = -4
_Seperators$ = -12
_i$ = -16
_TmpLine$ = -276
_ExtractResults@4 PROC NEAR				; COMDAT

; 1232 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	81 ec 14 01 00
	00		sub	esp, 276		; 00000114H
  00009	53		push	ebx
  0000a	56		push	esi
  0000b	57		push	edi

; 1233 :     PCHAR    TmpBuf;
; 1234 :     PCHAR    Token ;
; 1235 :     BOOLEAN  ExtractMoreResults = TRUE;

  0000c	c6 45 fc 01	mov	BYTE PTR _ExtractMoreResults$[ebp], 1

; 1236 :     CHAR     Seperators[] = " ,\t";

  00010	a1 00 00 00 00	mov	eax, DWORD PTR ??_C@_03IGFG@?5?0?7?$AA@ ; `string'
  00015	89 45 f4	mov	DWORD PTR _Seperators$[ebp], eax

; 1237 :     ULONG    i;
; 1238 :     CHAR     TmpLine[MAX_LINE_SIZE];
; 1239 : 
; 1240 :     //
; 1241 :     // First move the Current results into the Last results and clear the current results
; 1242 :     // one at a time
; 1243 :     //
; 1244 :     for( i = 0; i < Section->NumberOfCurrentResults;i++ ) {

  00018	c7 45 f0 00 00
	00 00		mov	DWORD PTR _i$[ebp], 0
  0001f	e9 03 00 00 00	jmp	$L8550
$L8551:
  00024	ff 45 f0	inc	DWORD PTR _i$[ebp]
$L8550:
  00027	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0002a	8b 4d f0	mov	ecx, DWORD PTR _i$[ebp]
  0002d	39 88 04 01 00
	00		cmp	DWORD PTR [eax+260], ecx
  00033	0f 86 2c 00 00
	00		jbe	$L8552

; 1245 : 
; 1246 :         Section->LastResults[i]    = Section->CurrentResults[i];

  00039	8b 45 f0	mov	eax, DWORD PTR _i$[ebp]
  0003c	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  0003f	8b 84 81 80 00
	00 00		mov	eax, DWORD PTR [ecx+eax*4+128]
  00046	8b 4d f0	mov	ecx, DWORD PTR _i$[ebp]
  00049	8b 55 08	mov	edx, DWORD PTR _Section$[ebp]
  0004c	89 04 8a	mov	DWORD PTR [edx+ecx*4], eax

; 1247 :         Section->CurrentResults[i] = 0                         ;

  0004f	8b 45 f0	mov	eax, DWORD PTR _i$[ebp]
  00052	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00055	c7 84 81 80 00
	00 00 00 00 00
	00		mov	DWORD PTR [ecx+eax*4+128], 0

; 1248 : 
; 1249 :     }

  00060	e9 bf ff ff ff	jmp	$L8551
$L8552:

; 1250 :     Section->NumberOfLastResults    = Section->NumberOfCurrentResults;

  00065	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00068	8b 80 04 01 00
	00		mov	eax, DWORD PTR [eax+260]
  0006e	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00071	89 81 00 01 00
	00		mov	DWORD PTR [ecx+256], eax

; 1251 :     Section->NumberOfCurrentResults = 0;

  00077	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0007a	c7 80 04 01 00
	00 00 00 00 00	mov	DWORD PTR [eax+260], 0

; 1252 : 
; 1253 :     //
; 1254 :     // Clear the tmp variable and copy the Normal Line contents into it
; 1255 :     // This is done to preserve the contents of the normal line since strtok
; 1256 :     // changes the contents.
; 1257 :     //
; 1258 :     memset( TmpLine, 0, MAX_LINE_SIZE );

  00084	68 00 01 00 00	push	256			; 00000100H
  00089	6a 00		push	0
  0008b	8d 85 ec fe ff
	ff		lea	eax, DWORD PTR _TmpLine$[ebp]
  00091	50		push	eax
  00092	e8 00 00 00 00	call	_memset
  00097	83 c4 0c	add	esp, 12			; 0000000cH

; 1259 :     strcpy( TmpLine, Section->CurrentLine->NormalLine );

  0009a	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0009d	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000a3	83 c0 08	add	eax, 8
  000a6	50		push	eax
  000a7	8d 85 ec fe ff
	ff		lea	eax, DWORD PTR _TmpLine$[ebp]
  000ad	50		push	eax
  000ae	e8 00 00 00 00	call	_strcpy
  000b3	83 c4 08	add	esp, 8

; 1260 : 
; 1261 : 
; 1262 :     //
; 1263 :     // Search for the right hand value of the expression. This is extracted
; 1264 :     // by searching for the = or the : operator.
; 1265 :     //
; 1266 :     // NOTE
; 1267 :     //
; 1268 :     //  We use strrchr to get to the last occurence of = or :
; 1269 :     //
; 1270 : 
; 1271 :     //
; 1272 :     // Locate the = operator
; 1273 :     //
; 1274 :     TmpBuf = strrchr( TmpLine, '=' );

  000b6	6a 3d		push	61			; 0000003dH
  000b8	8d 85 ec fe ff
	ff		lea	eax, DWORD PTR _TmpLine$[ebp]
  000be	50		push	eax
  000bf	e8 00 00 00 00	call	_strrchr
  000c4	83 c4 08	add	esp, 8
  000c7	89 45 f8	mov	DWORD PTR _TmpBuf$[ebp], eax

; 1275 : 
; 1276 :     if ( TmpBuf == NULL ) {

  000ca	83 7d f8 00	cmp	DWORD PTR _TmpBuf$[ebp], 0
  000ce	0f 85 25 00 00
	00		jne	$L8553

; 1277 : 
; 1278 :         //
; 1279 :         // Locate the : operator
; 1280 :         //
; 1281 :         TmpBuf = strrchr( TmpLine, ':' );

  000d4	6a 3a		push	58			; 0000003aH
  000d6	8d 85 ec fe ff
	ff		lea	eax, DWORD PTR _TmpLine$[ebp]
  000dc	50		push	eax
  000dd	e8 00 00 00 00	call	_strrchr
  000e2	83 c4 08	add	esp, 8
  000e5	89 45 f8	mov	DWORD PTR _TmpBuf$[ebp], eax

; 1282 : 
; 1283 :         if ( TmpBuf == NULL ) {

  000e8	83 7d f8 00	cmp	DWORD PTR _TmpBuf$[ebp], 0
  000ec	0f 85 07 00 00
	00		jne	$L8554

; 1284 : 
; 1285 :             return FALSE;

  000f2	32 c0		xor	al, al
  000f4	e9 c0 00 00 00	jmp	$L8543
$L8554:
$L8553:

; 1286 : 
; 1287 :         }
; 1288 : 
; 1289 :     }
; 1290 : 
; 1291 :     //
; 1292 :     // The fact that we are here indicates that one of the operator
; 1293 :     // types was located
; 1294 :     //
; 1295 :     TmpBuf++;

  000f9	ff 45 f8	inc	DWORD PTR _TmpBuf$[ebp]

; 1296 : 
; 1297 :     Token = strtok( TmpBuf, Seperators );

  000fc	8d 45 f4	lea	eax, DWORD PTR _Seperators$[ebp]
  000ff	50		push	eax
  00100	8b 45 f8	mov	eax, DWORD PTR _TmpBuf$[ebp]
  00103	50		push	eax
  00104	e8 00 00 00 00	call	_strtok
  00109	83 c4 08	add	esp, 8
  0010c	89 45 ec	mov	DWORD PTR _Token$[ebp], eax
$L8556:

; 1298 : 
; 1299 :     while ( ( Section->NumberOfCurrentResults < MAX_RESULTS_COUNT ) &&
; 1300 :             ( Token != NULL )                                       &&
; 1301 :             ( ExtractMoreResults )                                     ) {

  0010f	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00112	83 b8 04 01 00
	00 20		cmp	DWORD PTR [eax+260], 32	; 00000020H
  00119	0f 83 7c 00 00
	00		jae	$L8557
  0011f	83 7d ec 00	cmp	DWORD PTR _Token$[ebp], 0
  00123	0f 84 72 00 00
	00		je	$L8557
  00129	33 c0		xor	eax, eax
  0012b	8a 45 fc	mov	al, BYTE PTR _ExtractMoreResults$[ebp]
  0012e	85 c0		test	eax, eax
  00130	0f 84 65 00 00
	00		je	$L8557

; 1302 : 
; 1303 :         if ( (*Token >= '0') && (*Token <= '9') ) {

  00136	8b 45 ec	mov	eax, DWORD PTR _Token$[ebp]
  00139	0f be 00	movsx	eax, BYTE PTR [eax]
  0013c	83 f8 30	cmp	eax, 48			; 00000030H
  0013f	0f 8c 4d 00 00
	00		jl	$L8558
  00145	8b 45 ec	mov	eax, DWORD PTR _Token$[ebp]
  00148	0f be 00	movsx	eax, BYTE PTR [eax]
  0014b	83 f8 39	cmp	eax, 57			; 00000039H
  0014e	0f 8f 3e 00 00
	00		jg	$L8558

; 1304 : 
; 1305 :             Section->CurrentResults[Section->NumberOfCurrentResults] =  atol( Token );

  00154	8b 45 ec	mov	eax, DWORD PTR _Token$[ebp]
  00157	50		push	eax
  00158	e8 00 00 00 00	call	_atol
  0015d	83 c4 04	add	esp, 4
  00160	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00163	8b 89 04 01 00
	00		mov	ecx, DWORD PTR [ecx+260]
  00169	8b 55 08	mov	edx, DWORD PTR _Section$[ebp]
  0016c	89 84 8a 80 00
	00 00		mov	DWORD PTR [edx+ecx*4+128], eax

; 1306 :             Section->NumberOfCurrentResults++;

  00173	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00176	ff 80 04 01 00
	00		inc	DWORD PTR [eax+260]

; 1307 :             Token                   =  strtok( NULL, Seperators );

  0017c	8d 45 f4	lea	eax, DWORD PTR _Seperators$[ebp]
  0017f	50		push	eax
  00180	6a 00		push	0
  00182	e8 00 00 00 00	call	_strtok
  00187	83 c4 08	add	esp, 8
  0018a	89 45 ec	mov	DWORD PTR _Token$[ebp], eax

; 1308 : 
; 1309 :         } else {

  0018d	e9 04 00 00 00	jmp	$L8559
$L8558:

; 1310 : 
; 1311 :            ExtractMoreResults = FALSE;

  00192	c6 45 fc 00	mov	BYTE PTR _ExtractMoreResults$[ebp], 0
$L8559:

; 1312 : 
; 1313 :         }
; 1314 : 
; 1315 :     }

  00196	e9 74 ff ff ff	jmp	$L8556
$L8557:

; 1316 : 
; 1317 :     if ( Section->NumberOfCurrentResults ) {

  0019b	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0019e	83 b8 04 01 00
	00 00		cmp	DWORD PTR [eax+260], 0
  001a5	0f 84 07 00 00
	00		je	$L8560

; 1318 : 
; 1319 :         return TRUE;

  001ab	b0 01		mov	al, 1
  001ad	e9 07 00 00 00	jmp	$L8543
$L8560:

; 1320 : 
; 1321 :     }
; 1322 : 
; 1323 :     return FALSE;

  001b2	32 c0		xor	al, al
  001b4	e9 00 00 00 00	jmp	$L8543
$L8543:

; 1324 : 
; 1325 : }

  001b9	5f		pop	edi
  001ba	5e		pop	esi
  001bb	5b		pop	ebx
  001bc	c9		leave
  001bd	c2 04 00	ret	4
_ExtractResults@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@CCOH@BETWEEN_VALUES?$AA@		; `string'
PUBLIC	??_C@_01KMAE@?0?$AA@				; `string'
;	COMDAT ??_C@_0P@CCOH@BETWEEN_VALUES?$AA@
CONST	SEGMENT
??_C@_0P@CCOH@BETWEEN_VALUES?$AA@ DB 'BETWEEN_VALUES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMAE@?0?$AA@
CONST	SEGMENT
??_C@_01KMAE@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT _ExtractBetweenValues@4
_TEXT	SEGMENT
_Section$ = 8
_Tmp$ = -4
_Tmp1$ = -12
_SwapValue$ = -8
_ExtractBetweenValues@4 PROC NEAR			; COMDAT

; 1331 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 0c	sub	esp, 12			; 0000000cH
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 1332 :     PCHAR   Tmp, Tmp1;
; 1333 :     ULONG   SwapValue;
; 1334 : 
; 1335 :     //
; 1336 :     // Search for the AT_LEAST Keyword
; 1337 :     //
; 1338 :     Tmp = strstr( Section->CurrentLine->CompressedLine, "BETWEEN_VALUES" );

  00009	68 00 00 00 00	push	OFFSET FLAT:??_C@_0P@CCOH@BETWEEN_VALUES?$AA@ ; `string'
  0000e	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00011	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00017	05 08 01 00 00	add	eax, 264		; 00000108H
  0001c	50		push	eax
  0001d	e8 00 00 00 00	call	_strstr
  00022	83 c4 08	add	esp, 8
  00025	89 45 fc	mov	DWORD PTR _Tmp$[ebp], eax

; 1339 : 
; 1340 :     if ( Tmp != NULL ) {

  00028	83 7d fc 00	cmp	DWORD PTR _Tmp$[ebp], 0
  0002c	0f 84 c3 00 00
	00		je	$L8567

; 1341 : 
; 1342 :         Tmp += strlen( "BETWEEN_VALUES" );

  00032	68 00 00 00 00	push	OFFSET FLAT:??_C@_0P@CCOH@BETWEEN_VALUES?$AA@ ; `string'
  00037	e8 00 00 00 00	call	_strlen
  0003c	83 c4 04	add	esp, 4
  0003f	01 45 fc	add	DWORD PTR _Tmp$[ebp], eax

; 1343 : 
; 1344 :         //
; 1345 :         // Extract the minimum-first value
; 1346 :         //
; 1347 :         Section->MinimumValue = atol( Tmp );

  00042	8b 45 fc	mov	eax, DWORD PTR _Tmp$[ebp]
  00045	50		push	eax
  00046	e8 00 00 00 00	call	_atol
  0004b	83 c4 04	add	esp, 4
  0004e	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00051	89 81 28 01 00
	00		mov	DWORD PTR [ecx+296], eax

; 1348 : 
; 1349 :         //
; 1350 :         // Proceed to look for the maximum-second value
; 1351 :         //
; 1352 :         Tmp1 = strstr( Tmp, "," );

  00057	68 00 00 00 00	push	OFFSET FLAT:??_C@_01KMAE@?0?$AA@ ; `string'
  0005c	8b 45 fc	mov	eax, DWORD PTR _Tmp$[ebp]
  0005f	50		push	eax
  00060	e8 00 00 00 00	call	_strstr
  00065	83 c4 08	add	esp, 8
  00068	89 45 f4	mov	DWORD PTR _Tmp1$[ebp], eax

; 1353 : 
; 1354 :         if ( Tmp1 != NULL ) {

  0006b	83 7d f4 00	cmp	DWORD PTR _Tmp1$[ebp], 0
  0006f	0f 84 2a 00 00
	00		je	$L8569

; 1355 : 
; 1356 :             Tmp1 += strlen( "," );

  00075	68 00 00 00 00	push	OFFSET FLAT:??_C@_01KMAE@?0?$AA@ ; `string'
  0007a	e8 00 00 00 00	call	_strlen
  0007f	83 c4 04	add	esp, 4
  00082	01 45 f4	add	DWORD PTR _Tmp1$[ebp], eax

; 1357 : 
; 1358 :             //
; 1359 :             // Extract the minimum-first value
; 1360 :             //
; 1361 :             Section->MaximumValue = atol( Tmp1 );

  00085	8b 45 f4	mov	eax, DWORD PTR _Tmp1$[ebp]
  00088	50		push	eax
  00089	e8 00 00 00 00	call	_atol
  0008e	83 c4 04	add	esp, 4
  00091	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00094	89 81 2c 01 00
	00		mov	DWORD PTR [ecx+300], eax

; 1362 : 
; 1363 : 
; 1364 :         } else {

  0009a	e9 0d 00 00 00	jmp	$L8570
$L8569:

; 1365 : 
; 1366 :             Section->MaximumValue = 0xffffffff;

  0009f	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000a2	c7 80 2c 01 00
	00 ff ff ff ff	mov	DWORD PTR [eax+300], -1
$L8570:

; 1367 : 
; 1368 :         }
; 1369 : 
; 1370 :         if ( Section->MinimumValue > Section->MaximumValue ) {

  000ac	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000af	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  000b2	8b 89 2c 01 00
	00		mov	ecx, DWORD PTR [ecx+300]
  000b8	39 88 28 01 00
	00		cmp	DWORD PTR [eax+296], ecx
  000be	0f 86 2a 00 00
	00		jbe	$L8571

; 1371 : 
; 1372 :             SwapValue             = Section->MinimumValue;

  000c4	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000c7	8b 80 28 01 00
	00		mov	eax, DWORD PTR [eax+296]
  000cd	89 45 f8	mov	DWORD PTR _SwapValue$[ebp], eax

; 1373 :             Section->MinimumValue = Section->MaximumValue;

  000d0	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000d3	8b 80 2c 01 00
	00		mov	eax, DWORD PTR [eax+300]
  000d9	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  000dc	89 81 28 01 00
	00		mov	DWORD PTR [ecx+296], eax

; 1374 :             Section->MaximumValue = SwapValue            ;

  000e2	8b 45 f8	mov	eax, DWORD PTR _SwapValue$[ebp]
  000e5	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  000e8	89 81 2c 01 00
	00		mov	DWORD PTR [ecx+300], eax
$L8571:

; 1375 : 
; 1376 : 
; 1377 :         }
; 1378 : 
; 1379 :         return TRUE;

  000ee	b0 01		mov	al, 1
  000f0	e9 21 00 00 00	jmp	$L8562
$L8567:

; 1380 : 
; 1381 :     }
; 1382 : 
; 1383 :     //
; 1384 :     // Could not locate AT_LEAST or no associated value was recovered
; 1385 :     //
; 1386 :     Section->MinimumValue = 0;

  000f5	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000f8	c7 80 28 01 00
	00 00 00 00 00	mov	DWORD PTR [eax+296], 0

; 1387 :     Section->MaximumValue = 0xffffffff;

  00102	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00105	c7 80 2c 01 00
	00 ff ff ff ff	mov	DWORD PTR [eax+300], -1

; 1388 : 
; 1389 :     return FALSE;

  0010f	32 c0		xor	al, al
  00111	e9 00 00 00 00	jmp	$L8562
$L8562:

; 1390 : 
; 1391 : }

  00116	5f		pop	edi
  00117	5e		pop	esi
  00118	5b		pop	ebx
  00119	c9		leave
  0011a	c2 04 00	ret	4
_ExtractBetweenValues@4 ENDP
_TEXT	ENDS
;	COMDAT _CombinedVariation@12
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_CombinedLineVariation$ = 16
_CombinedVariation@12 PROC NEAR				; COMDAT

; 1399 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	53		push	ebx
  00004	56		push	esi
  00005	57		push	edi

; 1400 : 
; 1401 :     //
; 1402 :     // THERE ARE THE FOLLOWING POSSIBLE 6 COMBINATIONS
; 1403 :     //
; 1404 :     // START-START,    START-REGLINE,  START-END
; 1405 :     // END-REGLINE,    END-END
; 1406 :     // REGLINE-REGLINE
; 1407 :     //
; 1408 :     if ( ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_START ) &&
; 1409 :          ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_START ) ) {

  00006	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00009	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0000f	33 c9		xor	ecx, ecx
  00011	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00017	83 f9 01	cmp	ecx, 1
  0001a	0f 85 27 00 00
	00		jne	$L8576
  00020	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00023	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00029	33 c9		xor	ecx, ecx
  0002b	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00031	83 f9 01	cmp	ecx, 1
  00034	0f 85 0d 00 00
	00		jne	$L8576

; 1410 :         *CombinedLineVariation = SECTIONHDR_SECTIONHDR;

  0003a	8b 45 10	mov	eax, DWORD PTR _CombinedLineVariation$[ebp]
  0003d	c6 00 01	mov	BYTE PTR [eax], 1

; 1411 :         return TRUE;

  00040	b0 01		mov	al, 1
  00042	e9 e8 01 00 00	jmp	$L8575
$L8576:

; 1412 :     }
; 1413 : 
; 1414 :     if ( ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_END ) &&
; 1415 :          ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_END ) ) {

  00047	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0004a	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00050	33 c9		xor	ecx, ecx
  00052	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00058	83 f9 02	cmp	ecx, 2
  0005b	0f 85 27 00 00
	00		jne	$L8577
  00061	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00064	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0006a	33 c9		xor	ecx, ecx
  0006c	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00072	83 f9 02	cmp	ecx, 2
  00075	0f 85 0d 00 00
	00		jne	$L8577

; 1416 :         *CombinedLineVariation = SECTIONEND_SECTIONEND;

  0007b	8b 45 10	mov	eax, DWORD PTR _CombinedLineVariation$[ebp]
  0007e	c6 00 04	mov	BYTE PTR [eax], 4

; 1417 :         return TRUE;

  00081	b0 01		mov	al, 1
  00083	e9 a7 01 00 00	jmp	$L8575
$L8577:

; 1418 :     }
; 1419 : 
; 1420 : 
; 1421 :     if ( ( FirstSection->CurrentLine->LineType  == LINE_TYPE_REGULAR ) &&
; 1422 :          ( SecondSection->CurrentLine->LineType == LINE_TYPE_REGULAR ) ) {

  00088	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0008b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00091	33 c9		xor	ecx, ecx
  00093	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00099	83 f9 03	cmp	ecx, 3
  0009c	0f 85 27 00 00
	00		jne	$L8578
  000a2	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  000a5	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000ab	33 c9		xor	ecx, ecx
  000ad	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  000b3	83 f9 03	cmp	ecx, 3
  000b6	0f 85 0d 00 00
	00		jne	$L8578

; 1423 :         *CombinedLineVariation = REGLINE_REGLINE;

  000bc	8b 45 10	mov	eax, DWORD PTR _CombinedLineVariation$[ebp]
  000bf	c6 00 06	mov	BYTE PTR [eax], 6

; 1424 :         return TRUE;

  000c2	b0 01		mov	al, 1
  000c4	e9 66 01 00 00	jmp	$L8575
$L8578:

; 1425 :     }
; 1426 : 
; 1427 :     if ( (
; 1428 :              ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_START ) &&
; 1429 :              ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_END   )
; 1430 :          ) ||
; 1431 :          (
; 1432 :              ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_END   ) &&
; 1433 :              ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_START )
; 1434 :          ) ) {

  000c9	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000cc	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000d2	33 c9		xor	ecx, ecx
  000d4	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  000da	83 f9 01	cmp	ecx, 1
  000dd	0f 85 1a 00 00
	00		jne	$L8581
  000e3	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  000e6	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000ec	33 c9		xor	ecx, ecx
  000ee	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  000f4	83 f9 02	cmp	ecx, 2
  000f7	0f 84 34 00 00
	00		je	$L8580
$L8581:
  000fd	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00100	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00106	33 c9		xor	ecx, ecx
  00108	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0010e	83 f9 02	cmp	ecx, 2
  00111	0f 85 27 00 00
	00		jne	$L8579
  00117	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0011a	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00120	33 c9		xor	ecx, ecx
  00122	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00128	83 f9 01	cmp	ecx, 1
  0012b	0f 85 0d 00 00
	00		jne	$L8579
$L8580:

; 1435 :         *CombinedLineVariation = SECTIONHDR_SECTIONEND;

  00131	8b 45 10	mov	eax, DWORD PTR _CombinedLineVariation$[ebp]
  00134	c6 00 02	mov	BYTE PTR [eax], 2

; 1436 :         return TRUE;

  00137	b0 01		mov	al, 1
  00139	e9 f1 00 00 00	jmp	$L8575
$L8579:

; 1437 :     }
; 1438 : 
; 1439 :     if ( (
; 1440 :              ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_START ) &&
; 1441 :              ( SecondSection->CurrentLine->LineType == LINE_TYPE_REGULAR       )
; 1442 :          ) ||
; 1443 :          (
; 1444 :              ( FirstSection->CurrentLine->LineType  == LINE_TYPE_REGULAR       ) &&
; 1445 :              ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_START )
; 1446 :          ) ) {

  0013e	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00141	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00147	33 c9		xor	ecx, ecx
  00149	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0014f	83 f9 01	cmp	ecx, 1
  00152	0f 85 1a 00 00
	00		jne	$L8584
  00158	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0015b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00161	33 c9		xor	ecx, ecx
  00163	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00169	83 f9 03	cmp	ecx, 3
  0016c	0f 84 34 00 00
	00		je	$L8583
$L8584:
  00172	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00175	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0017b	33 c9		xor	ecx, ecx
  0017d	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00183	83 f9 03	cmp	ecx, 3
  00186	0f 85 27 00 00
	00		jne	$L8582
  0018c	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0018f	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00195	33 c9		xor	ecx, ecx
  00197	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0019d	83 f9 01	cmp	ecx, 1
  001a0	0f 85 0d 00 00
	00		jne	$L8582
$L8583:

; 1447 :         *CombinedLineVariation = SECTIONHDR_REGLINE;

  001a6	8b 45 10	mov	eax, DWORD PTR _CombinedLineVariation$[ebp]
  001a9	c6 00 03	mov	BYTE PTR [eax], 3

; 1448 :         return TRUE;

  001ac	b0 01		mov	al, 1
  001ae	e9 7c 00 00 00	jmp	$L8575
$L8582:

; 1449 :     }
; 1450 : 
; 1451 :     if ( (
; 1452 :              ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_END   ) &&
; 1453 :              ( SecondSection->CurrentLine->LineType == LINE_TYPE_REGULAR       )
; 1454 :          ) ||
; 1455 :          (
; 1456 :              ( FirstSection->CurrentLine->LineType  == LINE_TYPE_REGULAR       ) &&
; 1457 :              ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_END   )
; 1458 :          ) ) {

  001b3	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  001b6	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  001bc	33 c9		xor	ecx, ecx
  001be	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  001c4	83 f9 02	cmp	ecx, 2
  001c7	0f 85 1a 00 00
	00		jne	$L8587
  001cd	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  001d0	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  001d6	33 c9		xor	ecx, ecx
  001d8	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  001de	83 f9 03	cmp	ecx, 3
  001e1	0f 84 34 00 00
	00		je	$L8586
$L8587:
  001e7	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  001ea	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  001f0	33 c9		xor	ecx, ecx
  001f2	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  001f8	83 f9 03	cmp	ecx, 3
  001fb	0f 85 27 00 00
	00		jne	$L8585
  00201	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00204	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0020a	33 c9		xor	ecx, ecx
  0020c	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00212	83 f9 02	cmp	ecx, 2
  00215	0f 85 0d 00 00
	00		jne	$L8585
$L8586:

; 1459 :         *CombinedLineVariation = SECTIONEND_REGLINE;

  0021b	8b 45 10	mov	eax, DWORD PTR _CombinedLineVariation$[ebp]
  0021e	c6 00 05	mov	BYTE PTR [eax], 5

; 1460 :         return TRUE;

  00221	b0 01		mov	al, 1
  00223	e9 07 00 00 00	jmp	$L8575
$L8585:

; 1461 :     }
; 1462 : 
; 1463 :     return FALSE;

  00228	32 c0		xor	al, al
  0022a	e9 00 00 00 00	jmp	$L8575
$L8575:

; 1464 : }

  0022f	5f		pop	edi
  00230	5e		pop	esi
  00231	5b		pop	ebx
  00232	c9		leave
  00233	c2 0c 00	ret	12			; 0000000cH
_CombinedVariation@12 ENDP
_TEXT	ENDS
PUBLIC	_CompareLines@8
PUBLIC	_TokenInsertInSection@4
PUBLIC	_MayDifferExistsInOneOrMoreLines@8
PUBLIC	??_C@_0L@MGBK@EQUAL_LAST?$AA@			; `string'
EXTRN	_memcmp:NEAR
;	COMDAT ??_C@_0L@MGBK@EQUAL_LAST?$AA@
CONST	SEGMENT
??_C@_0L@MGBK@EQUAL_LAST?$AA@ DB 'EQUAL_LAST', 00H	; `string'
CONST	ENDS
;	COMDAT _CompareLines@8
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_ResultErrorsDiscovered$ = -4
_i$ = -8
_CompareLines@8 PROC NEAR				; COMDAT

; 1471 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 08	sub	esp, 8
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 1472 : 
; 1473 :     BOOLEAN   ResultErrorsDiscovered = FALSE;

  00009	c6 45 fc 00	mov	BYTE PTR _ResultErrorsDiscovered$[ebp], 0

; 1474 :     ULONG     i;
; 1475 : 
; 1476 :     //
; 1477 :     // THIS IS ANOTHER VERY CRITICAL PIECE OF THE CODE SINCE BASED ON THE LINE TYPES
; 1478 :     // COMPARISONS ARE MADE
; 1479 :     //
; 1480 :     // ON ENTERING THIS FUNCTION THERE ARE ONLY THREE COMBINATIONS A LINE COULD
; 1481 :     // BE IN THE FOLLOWING STATES
; 1482 :     //
; 1483 :     // REGLINE-REGLINE
; 1484 :     // REGLINE-SECTIONHDR
; 1485 :     // REGLINE-SECTIONEND
; 1486 :     //
; 1487 :     // FURTHER SINCE THE SECTIONS ARE SYNCHRONIZED WE CAN USE THE CONTROL SETTINGS
; 1488 :     // OF EITHER ONE
; 1489 :     //
; 1490 : 
; 1491 : 
; 1492 :     //
; 1493 :     // COMMON COMPARISONS BETWEEN ALL LINE TYPES
; 1494 :     //
; 1495 : 
; 1496 :     //
; 1497 :     // Possible MAY_DIFFER.
; 1498 :     //
; 1499 :     if ( MayDifferExistsInOneOrMoreLines( FirstSection, SecondSection ) ) {

  0000d	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00010	50		push	eax
  00011	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00014	50		push	eax
  00015	e8 00 00 00 00	call	_MayDifferExistsInOneOrMoreLines@8
  0001a	33 c9		xor	ecx, ecx
  0001c	8a c8		mov	cl, al
  0001e	85 c9		test	ecx, ecx
  00020	0f 84 07 00 00
	00		je	$L8593

; 1500 : 
; 1501 :         return COMPARE_SUCCESS;

  00026	33 c0		xor	eax, eax
  00028	e9 53 04 00 00	jmp	$L8590
$L8593:

; 1502 : 
; 1503 :     }
; 1504 : 
; 1505 :     //
; 1506 :     // Possible EQUAL_LAST
; 1507 :     //
; 1508 :     if ( strstr( FirstSection->CurrentLine->CompressedLine, "EQUAL_LAST" ) != NULL ) {

  0002d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@MGBK@EQUAL_LAST?$AA@ ; `string'
  00032	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00035	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0003b	05 08 01 00 00	add	eax, 264		; 00000108H
  00040	50		push	eax
  00041	e8 00 00 00 00	call	_strstr
  00046	83 c4 08	add	esp, 8
  00049	85 c0		test	eax, eax
  0004b	0f 84 bf 00 00
	00		je	$L8594

; 1509 : 
; 1510 :         if ( SecondSection->Control.OptionalMatching  == FALSE ) {

  00051	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00054	33 c9		xor	ecx, ecx
  00056	8a 88 50 01 00
	00		mov	cl, BYTE PTR [eax+336]
  0005c	85 c9		test	ecx, ecx
  0005e	0f 85 a5 00 00
	00		jne	$L8596

; 1511 : 
; 1512 : 
; 1513 :             for( i = 1; i <= FirstSection->NumberOfCurrentResults; i++ ) {

  00064	c7 45 f8 01 00
	00 00		mov	DWORD PTR _i$[ebp], 1
  0006b	e9 03 00 00 00	jmp	$L8597
$L8598:
  00070	ff 45 f8	inc	DWORD PTR _i$[ebp]
$L8597:
  00073	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00076	8b 4d f8	mov	ecx, DWORD PTR _i$[ebp]
  00079	39 88 04 01 00
	00		cmp	DWORD PTR [eax+260], ecx
  0007f	0f 82 6d 00 00
	00		jb	$L8599

; 1514 : 
; 1515 :                 if ( i > FirstSection->NumberOfLastResults ) {

  00085	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00088	8b 4d f8	mov	ecx, DWORD PTR _i$[ebp]
  0008b	39 88 00 01 00
	00		cmp	DWORD PTR [eax+256], ecx
  00091	0f 83 17 00 00
	00		jae	$L8600

; 1516 : 
; 1517 :                     FirstSection->ResultsError[i-1]      = RESULTS_NOT_PRESENT;

  00097	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  0009a	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  0009d	c6 84 08 07 01
	00 00 02	mov	BYTE PTR [eax+ecx+263], 2

; 1518 :                     ResultErrorsDiscovered = TRUE;

  000a5	c6 45 fc 01	mov	BYTE PTR _ResultErrorsDiscovered$[ebp], 1

; 1519 : 
; 1520 :                 } else {

  000a9	e9 3f 00 00 00	jmp	$L8601
$L8600:

; 1521 : 
; 1522 :                     if ( FirstSection->CurrentResults[i-1] != FirstSection->LastResults[i-1] ) {

  000ae	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  000b1	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  000b4	8b 55 f8	mov	edx, DWORD PTR _i$[ebp]
  000b7	8b 5d 08	mov	ebx, DWORD PTR _FirstSection$[ebp]
  000ba	8b 54 93 fc	mov	edx, DWORD PTR [ebx+edx*4-4]
  000be	39 54 81 7c	cmp	DWORD PTR [ecx+eax*4+124], edx
  000c2	0f 84 17 00 00
	00		je	$L8602

; 1523 : 
; 1524 :                         FirstSection->ResultsError[i-1]      = RESULTS_UNEQUAL;

  000c8	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  000cb	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  000ce	c6 84 08 07 01
	00 00 01	mov	BYTE PTR [eax+ecx+263], 1

; 1525 :                         ResultErrorsDiscovered = TRUE;

  000d6	c6 45 fc 01	mov	BYTE PTR _ResultErrorsDiscovered$[ebp], 1

; 1526 : 
; 1527 :                     } else {

  000da	e9 0e 00 00 00	jmp	$L8603
$L8602:

; 1528 : 
; 1529 :                         FirstSection->ResultsError[i-1] = RESULTS_EQUAL;

  000df	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  000e2	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  000e5	c6 84 08 07 01
	00 00 00	mov	BYTE PTR [eax+ecx+263], 0
$L8603:
$L8601:

; 1530 : 
; 1531 :                     }
; 1532 :                 }
; 1533 :             }

  000ed	e9 7e ff ff ff	jmp	$L8598
$L8599:

; 1534 : 
; 1535 :             if ( ResultErrorsDiscovered ) {

  000f2	33 c0		xor	eax, eax
  000f4	8a 45 fc	mov	al, BYTE PTR _ResultErrorsDiscovered$[ebp]
  000f7	85 c0		test	eax, eax
  000f9	0f 84 0a 00 00
	00		je	$L8604

; 1536 : 
; 1537 :                 return COMPARE_EQUAL_LAST;

  000ff	b8 01 00 00 00	mov	eax, 1
  00104	e9 77 03 00 00	jmp	$L8590
$L8604:
$L8596:

; 1538 : 
; 1539 :             }
; 1540 : 
; 1541 :         }
; 1542 : 
; 1543 :         return COMPARE_SUCCESS;

  00109	33 c0		xor	eax, eax
  0010b	e9 70 03 00 00	jmp	$L8590
$L8594:

; 1544 : 
; 1545 :     }
; 1546 : 
; 1547 :     //
; 1548 :     // Possible BETWEEN_VALUES from the Golden log file
; 1549 :     //
; 1550 :     if ( strstr( SecondSection->CurrentLine->CompressedLine, "BETWEEN_VALUES" ) != NULL ) {

  00110	68 00 00 00 00	push	OFFSET FLAT:??_C@_0P@CCOH@BETWEEN_VALUES?$AA@ ; `string'
  00115	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00118	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0011e	05 08 01 00 00	add	eax, 264		; 00000108H
  00123	50		push	eax
  00124	e8 00 00 00 00	call	_strstr
  00129	83 c4 08	add	esp, 8
  0012c	85 c0		test	eax, eax
  0012e	0f 84 ae 00 00
	00		je	$L8605

; 1551 : 
; 1552 :         if ( SecondSection->Control.OptionalMatching == FALSE ) {

  00134	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00137	33 c9		xor	ecx, ecx
  00139	8a 88 50 01 00
	00		mov	cl, BYTE PTR [eax+336]
  0013f	85 c9		test	ecx, ecx
  00141	0f 85 94 00 00
	00		jne	$L8606

; 1553 : 
; 1554 :             for( i = 1; i <= FirstSection->NumberOfCurrentResults; i++ ) {

  00147	c7 45 f8 01 00
	00 00		mov	DWORD PTR _i$[ebp], 1
  0014e	e9 03 00 00 00	jmp	$L8607
$L8608:
  00153	ff 45 f8	inc	DWORD PTR _i$[ebp]
$L8607:
  00156	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00159	8b 4d f8	mov	ecx, DWORD PTR _i$[ebp]
  0015c	39 88 04 01 00
	00		cmp	DWORD PTR [eax+260], ecx
  00162	0f 82 5c 00 00
	00		jb	$L8609

; 1555 : 
; 1556 :                 if ( ( FirstSection->CurrentResults[i-1] < SecondSection->MinimumValue ) ||
; 1557 :                      ( FirstSection->CurrentResults[i-1] > SecondSection->MaximumValue )    ) {

  00168	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  0016b	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  0016e	8b 55 0c	mov	edx, DWORD PTR _SecondSection$[ebp]
  00171	8b 92 28 01 00
	00		mov	edx, DWORD PTR [edx+296]
  00177	39 54 81 7c	cmp	DWORD PTR [ecx+eax*4+124], edx
  0017b	0f 82 19 00 00
	00		jb	$L8611
  00181	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  00184	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  00187	8b 55 0c	mov	edx, DWORD PTR _SecondSection$[ebp]
  0018a	8b 92 2c 01 00
	00		mov	edx, DWORD PTR [edx+300]
  00190	39 54 81 7c	cmp	DWORD PTR [ecx+eax*4+124], edx
  00194	0f 86 17 00 00
	00		jbe	$L8610
$L8611:

; 1558 : 
; 1559 :                     FirstSection->ResultsError[i-1]  = RESULTS_MINMAX;

  0019a	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  0019d	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  001a0	c6 84 08 07 01
	00 00 03	mov	BYTE PTR [eax+ecx+263], 3

; 1560 :                     ResultErrorsDiscovered           = TRUE;

  001a8	c6 45 fc 01	mov	BYTE PTR _ResultErrorsDiscovered$[ebp], 1

; 1561 : 
; 1562 :                 } else {

  001ac	e9 0e 00 00 00	jmp	$L8612
$L8610:

; 1563 : 
; 1564 :                     FirstSection->ResultsError[i-1] = RESULTS_EQUAL;

  001b1	8b 45 f8	mov	eax, DWORD PTR _i$[ebp]
  001b4	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  001b7	c6 84 08 07 01
	00 00 00	mov	BYTE PTR [eax+ecx+263], 0
$L8612:

; 1565 : 
; 1566 :                 }
; 1567 : 
; 1568 : 
; 1569 :             }

  001bf	e9 8f ff ff ff	jmp	$L8608
$L8609:

; 1570 : 
; 1571 :             if ( ResultErrorsDiscovered ) {

  001c4	33 c0		xor	eax, eax
  001c6	8a 45 fc	mov	al, BYTE PTR _ResultErrorsDiscovered$[ebp]
  001c9	85 c0		test	eax, eax
  001cb	0f 84 0a 00 00
	00		je	$L8613

; 1572 : 
; 1573 :                     return COMPARE_BETWEEN_VALUES;

  001d1	b8 06 00 00 00	mov	eax, 6
  001d6	e9 a5 02 00 00	jmp	$L8590
$L8613:
$L8606:

; 1574 : 
; 1575 :             }
; 1576 : 
; 1577 :         }
; 1578 : 
; 1579 :         return COMPARE_SUCCESS;

  001db	33 c0		xor	eax, eax
  001dd	e9 9e 02 00 00	jmp	$L8590
$L8605:

; 1580 : 
; 1581 :     }
; 1582 : 
; 1583 : 
; 1584 :     //
; 1585 :     // REGLINE-SECTIONHDR
; 1586 :     //
; 1587 :     if ( ( FirstSection->CurrentLine->LineType  == LINE_TYPE_REGULAR       ) &&
; 1588 :          ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_START )    ) {

  001e2	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  001e5	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  001eb	33 c9		xor	ecx, ecx
  001ed	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  001f3	83 f9 03	cmp	ecx, 3
  001f6	0f 85 63 00 00
	00		jne	$L8614
  001fc	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  001ff	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00205	33 c9		xor	ecx, ecx
  00207	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0020d	83 f9 01	cmp	ecx, 1
  00210	0f 85 49 00 00
	00		jne	$L8614

; 1589 : 
; 1590 :         if ( SecondSection->Control.OptionalMatching == TRUE ) {

  00216	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00219	33 c9		xor	ecx, ecx
  0021b	8a 88 50 01 00
	00		mov	cl, BYTE PTR [eax+336]
  00221	83 f9 01	cmp	ecx, 1
  00224	0f 85 07 00 00
	00		jne	$L8615

; 1591 : 
; 1592 :             return COMPARE_SUCCESS;

  0022a	33 c0		xor	eax, eax
  0022c	e9 4f 02 00 00	jmp	$L8590
$L8615:

; 1593 : 
; 1594 :         }
; 1595 : 
; 1596 :         if ( SecondSection->Control.TokenMatching == TRUE ) {

  00231	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00234	33 c9		xor	ecx, ecx
  00236	8a 88 51 01 00
	00		mov	cl, BYTE PTR [eax+337]
  0023c	83 f9 01	cmp	ecx, 1
  0023f	0f 85 10 00 00
	00		jne	$L8616

; 1597 : 
; 1598 :             TokenInsertInSection( FirstSection );

  00245	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00248	50		push	eax
  00249	e8 00 00 00 00	call	_TokenInsertInSection@4

; 1599 :             return COMPARE_SUCCESS;

  0024e	33 c0		xor	eax, eax
  00250	e9 2b 02 00 00	jmp	$L8590
$L8616:

; 1600 : 
; 1601 :         }
; 1602 : 
; 1603 :         return COMPARE_START;

  00255	b8 03 00 00 00	mov	eax, 3
  0025a	e9 21 02 00 00	jmp	$L8590
$L8614:

; 1604 : 
; 1605 :     }
; 1606 :     if( ( SecondSection->CurrentLine->LineType == LINE_TYPE_REGULAR       ) &&
; 1607 :         ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_START )    ) {

  0025f	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00262	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00268	33 c9		xor	ecx, ecx
  0026a	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00270	83 f9 03	cmp	ecx, 3
  00273	0f 85 63 00 00
	00		jne	$L8617
  00279	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0027c	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00282	33 c9		xor	ecx, ecx
  00284	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0028a	83 f9 01	cmp	ecx, 1
  0028d	0f 85 49 00 00
	00		jne	$L8617

; 1608 : 
; 1609 :         if ( SecondSection->Control.OptionalMatching == TRUE ) {

  00293	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00296	33 c9		xor	ecx, ecx
  00298	8a 88 50 01 00
	00		mov	cl, BYTE PTR [eax+336]
  0029e	83 f9 01	cmp	ecx, 1
  002a1	0f 85 07 00 00
	00		jne	$L8618

; 1610 : 
; 1611 :             return COMPARE_SUCCESS;

  002a7	33 c0		xor	eax, eax
  002a9	e9 d2 01 00 00	jmp	$L8590
$L8618:

; 1612 : 
; 1613 :         }
; 1614 : 
; 1615 :         if ( SecondSection->Control.TokenMatching == TRUE ) {

  002ae	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  002b1	33 c9		xor	ecx, ecx
  002b3	8a 88 51 01 00
	00		mov	cl, BYTE PTR [eax+337]
  002b9	83 f9 01	cmp	ecx, 1
  002bc	0f 85 10 00 00
	00		jne	$L8619

; 1616 : 
; 1617 :             TokenInsertInSection( SecondSection );

  002c2	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  002c5	50		push	eax
  002c6	e8 00 00 00 00	call	_TokenInsertInSection@4

; 1618 :             return COMPARE_SUCCESS;

  002cb	33 c0		xor	eax, eax
  002cd	e9 ae 01 00 00	jmp	$L8590
$L8619:

; 1619 : 
; 1620 :         }
; 1621 : 
; 1622 :         return COMPARE_START;

  002d2	b8 03 00 00 00	mov	eax, 3
  002d7	e9 a4 01 00 00	jmp	$L8590
$L8617:

; 1623 : 
; 1624 :     }
; 1625 : 
; 1626 : 
; 1627 : 
; 1628 :     //
; 1629 :     // REGLINE-SECTIONEND
; 1630 :     //
; 1631 :     if ( ( FirstSection->CurrentLine->LineType  == LINE_TYPE_REGULAR     ) &&
; 1632 :          ( SecondSection->CurrentLine->LineType == LINE_TYPE_SECTION_END )     ) {

  002dc	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  002df	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  002e5	33 c9		xor	ecx, ecx
  002e7	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  002ed	83 f9 03	cmp	ecx, 3
  002f0	0f 85 63 00 00
	00		jne	$L8620
  002f6	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  002f9	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  002ff	33 c9		xor	ecx, ecx
  00301	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00307	83 f9 02	cmp	ecx, 2
  0030a	0f 85 49 00 00
	00		jne	$L8620

; 1633 : 
; 1634 :         if ( SecondSection->Control.OptionalMatching == TRUE ) {

  00310	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00313	33 c9		xor	ecx, ecx
  00315	8a 88 50 01 00
	00		mov	cl, BYTE PTR [eax+336]
  0031b	83 f9 01	cmp	ecx, 1
  0031e	0f 85 07 00 00
	00		jne	$L8621

; 1635 : 
; 1636 :             return COMPARE_SUCCESS;

  00324	33 c0		xor	eax, eax
  00326	e9 55 01 00 00	jmp	$L8590
$L8621:

; 1637 : 
; 1638 :         }
; 1639 : 
; 1640 :         if ( SecondSection->Control.TokenMatching == TRUE ) {

  0032b	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0032e	33 c9		xor	ecx, ecx
  00330	8a 88 51 01 00
	00		mov	cl, BYTE PTR [eax+337]
  00336	83 f9 01	cmp	ecx, 1
  00339	0f 85 10 00 00
	00		jne	$L8622

; 1641 : 
; 1642 :             TokenInsertInSection( FirstSection );

  0033f	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00342	50		push	eax
  00343	e8 00 00 00 00	call	_TokenInsertInSection@4

; 1643 :             return COMPARE_SUCCESS;

  00348	33 c0		xor	eax, eax
  0034a	e9 31 01 00 00	jmp	$L8590
$L8622:

; 1644 : 
; 1645 :         }
; 1646 : 
; 1647 :         return COMPARE_END;

  0034f	b8 04 00 00 00	mov	eax, 4
  00354	e9 27 01 00 00	jmp	$L8590
$L8620:

; 1648 : 
; 1649 :     }
; 1650 :     if ( ( SecondSection->CurrentLine->LineType == LINE_TYPE_REGULAR     ) &&
; 1651 :          ( FirstSection->CurrentLine->LineType  == LINE_TYPE_SECTION_END )     ) {

  00359	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0035c	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00362	33 c9		xor	ecx, ecx
  00364	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0036a	83 f9 03	cmp	ecx, 3
  0036d	0f 85 63 00 00
	00		jne	$L8623
  00373	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00376	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0037c	33 c9		xor	ecx, ecx
  0037e	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  00384	83 f9 02	cmp	ecx, 2
  00387	0f 85 49 00 00
	00		jne	$L8623

; 1652 : 
; 1653 :         if ( SecondSection->Control.OptionalMatching == TRUE ) {

  0038d	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00390	33 c9		xor	ecx, ecx
  00392	8a 88 50 01 00
	00		mov	cl, BYTE PTR [eax+336]
  00398	83 f9 01	cmp	ecx, 1
  0039b	0f 85 07 00 00
	00		jne	$L8624

; 1654 : 
; 1655 :             return COMPARE_SUCCESS;

  003a1	33 c0		xor	eax, eax
  003a3	e9 d8 00 00 00	jmp	$L8590
$L8624:

; 1656 : 
; 1657 :         }
; 1658 : 
; 1659 :         if ( SecondSection->Control.TokenMatching == TRUE ) {

  003a8	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  003ab	33 c9		xor	ecx, ecx
  003ad	8a 88 51 01 00
	00		mov	cl, BYTE PTR [eax+337]
  003b3	83 f9 01	cmp	ecx, 1
  003b6	0f 85 10 00 00
	00		jne	$L8625

; 1660 : 
; 1661 :             TokenInsertInSection( SecondSection );

  003bc	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  003bf	50		push	eax
  003c0	e8 00 00 00 00	call	_TokenInsertInSection@4

; 1662 :             return COMPARE_SUCCESS;

  003c5	33 c0		xor	eax, eax
  003c7	e9 b4 00 00 00	jmp	$L8590
$L8625:

; 1663 : 
; 1664 :         }
; 1665 : 
; 1666 :         return COMPARE_END;

  003cc	b8 04 00 00 00	mov	eax, 4
  003d1	e9 aa 00 00 00	jmp	$L8590
$L8623:

; 1667 : 
; 1668 :     }
; 1669 : 
; 1670 : 
; 1671 : 
; 1672 : 
; 1673 :     //
; 1674 :     // REGLINE-REGLINE
; 1675 :     //
; 1676 :     if ( memcmp( FirstSection->CurrentLine->CompressedLine,
; 1677 :                  SecondSection->CurrentLine->CompressedLine,
; 1678 :                  max( FirstSection->CurrentLine->CompressedLineSize, SecondSection->CurrentLine->CompressedLineSize )
; 1679 :                )
; 1680 :          != 0 ) {

  003d6	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  003d9	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  003df	8b 40 04	mov	eax, DWORD PTR [eax+4]
  003e2	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  003e5	8b 89 34 01 00
	00		mov	ecx, DWORD PTR [ecx+308]
  003eb	8b 49 04	mov	ecx, DWORD PTR [ecx+4]
  003ee	3b c1		cmp	eax, ecx
  003f0	0f 87 02 00 00
	00		ja	$L8951
  003f6	8b c1		mov	eax, ecx
$L8951:
  003f8	50		push	eax
  003f9	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  003fc	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00402	05 08 01 00 00	add	eax, 264		; 00000108H
  00407	50		push	eax
  00408	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0040b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00411	05 08 01 00 00	add	eax, 264		; 00000108H
  00416	50		push	eax
  00417	e8 00 00 00 00	call	_memcmp
  0041c	83 c4 0c	add	esp, 12			; 0000000cH
  0041f	85 c0		test	eax, eax
  00421	0f 84 52 00 00
	00		je	$L8626

; 1681 : 
; 1682 :         //
; 1683 :         // Since we can only be at this point if the two section headers match,
; 1684 :         // either control sections can be used
; 1685 :         //
; 1686 :         if ( SecondSection->Control.OptionalMatching  == TRUE ) {

  00427	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0042a	33 c9		xor	ecx, ecx
  0042c	8a 88 50 01 00
	00		mov	cl, BYTE PTR [eax+336]
  00432	83 f9 01	cmp	ecx, 1
  00435	0f 85 07 00 00
	00		jne	$L8627

; 1687 : 
; 1688 :             return COMPARE_SUCCESS;

  0043b	33 c0		xor	eax, eax
  0043d	e9 3e 00 00 00	jmp	$L8590
$L8627:

; 1689 : 
; 1690 :         }
; 1691 : 
; 1692 :         if ( SecondSection->Control.TokenMatching == TRUE ) {

  00442	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00445	33 c9		xor	ecx, ecx
  00447	8a 88 51 01 00
	00		mov	cl, BYTE PTR [eax+337]
  0044d	83 f9 01	cmp	ecx, 1
  00450	0f 85 19 00 00
	00		jne	$L8628

; 1693 : 
; 1694 :             TokenInsertInSection( FirstSection  );

  00456	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00459	50		push	eax
  0045a	e8 00 00 00 00	call	_TokenInsertInSection@4

; 1695 :             TokenInsertInSection( SecondSection );

  0045f	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00462	50		push	eax
  00463	e8 00 00 00 00	call	_TokenInsertInSection@4

; 1696 :             return COMPARE_SUCCESS;

  00468	33 c0		xor	eax, eax
  0046a	e9 11 00 00 00	jmp	$L8590
$L8628:

; 1697 : 
; 1698 :         }
; 1699 : 
; 1700 :         return COMPARE_LINE;

  0046f	b8 02 00 00 00	mov	eax, 2
  00474	e9 07 00 00 00	jmp	$L8590
$L8626:

; 1701 : 
; 1702 :     }
; 1703 : 
; 1704 :     return COMPARE_SUCCESS;

  00479	33 c0		xor	eax, eax
  0047b	e9 00 00 00 00	jmp	$L8590
$L8590:

; 1705 : 
; 1706 : 
; 1707 : }

  00480	5f		pop	edi
  00481	5e		pop	esi
  00482	5b		pop	ebx
  00483	c9		leave
  00484	c2 08 00	ret	8
_CompareLines@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02JGGD@?0?$CJ?$AA@			; `string'
EXTRN	_getenv:NEAR
;	COMDAT ??_C@_02JGGD@?0?$CJ?$AA@
CONST	SEGMENT
??_C@_02JGGD@?0?$CJ?$AA@ DB ',)', 00H			; `string'
CONST	ENDS
;	COMDAT _InitializeSectionControl@8
_TEXT	SEGMENT
_NewSection$ = 8
_OldSection$ = 12
_TmpBuffer$ = -260
_Length$ = -264
_EnvironmentVar$ = -256
_TmpLine$ = -520
_EnvCounter1$8640 = -536
_EnvCounter2$8641 = -528
_Token$8642 = -532
_Seperators$8643 = -524
_InitializeSectionControl@8 PROC NEAR			; COMDAT

; 1715 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	81 ec 18 02 00
	00		sub	esp, 536		; 00000218H
  00009	53		push	ebx
  0000a	56		push	esi
  0000b	57		push	edi

; 1716 : 
; 1717 :     PCHAR   TmpBuffer;
; 1718 :     INT     Length   ;
; 1719 :     CHAR    EnvironmentVar[MAX_LINE_SIZE];
; 1720 :     CHAR    TmpLine[MAX_LINE_SIZE]       ;
; 1721 : 
; 1722 :     //
; 1723 :     // Initialize the file pointers
; 1724 :     //
; 1725 :     // NOTE
; 1726 :     //
; 1727 :     // If you do not specify any control for the section and the section is nested
; 1728 :     // it will inherit the options of the parent node
; 1729 :     //
; 1730 :     NewSection->File        = OldSection->File;

  0000c	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  0000f	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00015	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  00018	89 81 30 01 00
	00		mov	DWORD PTR [ecx+304], eax

; 1731 :     NewSection->CurrentLine = (PLINE)NULL;

  0001e	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  00021	c7 80 34 01 00
	00 00 00 00 00	mov	DWORD PTR [eax+308], 0

; 1732 : 
; 1733 :     NewSection->Control.BaseControlSection  = OldSection->Control.BaseControlSection;

  0002b	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  0002e	8a 80 52 01 00
	00		mov	al, BYTE PTR [eax+338]
  00034	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  00037	88 81 52 01 00
	00		mov	BYTE PTR [ecx+338], al

; 1734 :     NewSection->Control.OptionalMatching    = OldSection->Control.OptionalMatching  ;

  0003d	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  00040	8a 80 50 01 00
	00		mov	al, BYTE PTR [eax+336]
  00046	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  00049	88 81 50 01 00
	00		mov	BYTE PTR [ecx+336], al

; 1735 :     NewSection->Control.TokenMatching       = OldSection->Control.TokenMatching     ;

  0004f	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  00052	8a 80 51 01 00
	00		mov	al, BYTE PTR [eax+337]
  00058	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  0005b	88 81 51 01 00
	00		mov	BYTE PTR [ecx+337], al

; 1736 : 
; 1737 :     NewSection->Control.TokenMatchStartLine = OldSection->Control.TokenMatchStartLine;

  00061	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  00064	8b 80 3c 01 00
	00		mov	eax, DWORD PTR [eax+316]
  0006a	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  0006d	89 81 3c 01 00
	00		mov	DWORD PTR [ecx+316], eax

; 1738 :     NewSection->Control.TokenMatchStopLine  = OldSection->Control.TokenMatchStopLine ;

  00073	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  00076	8b 80 40 01 00
	00		mov	eax, DWORD PTR [eax+320]
  0007c	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  0007f	89 81 40 01 00
	00		mov	DWORD PTR [ecx+320], eax

; 1739 : 
; 1740 :     //
; 1741 :     // Since we are going to use strtok to preserve the Normal and Compressed Lines
; 1742 :     // we copy them into two local variables when required
; 1743 :     //
; 1744 :     memset( TmpLine, 0, MAX_LINE_SIZE );

  00085	68 00 01 00 00	push	256			; 00000100H
  0008a	6a 00		push	0
  0008c	8d 85 f8 fd ff
	ff		lea	eax, DWORD PTR _TmpLine$[ebp]
  00092	50		push	eax
  00093	e8 00 00 00 00	call	_memset
  00098	83 c4 0c	add	esp, 12			; 0000000cH

; 1745 : 
; 1746 :     //
; 1747 :     // Initialize the section ID
; 1748 :     //
; 1749 :     // KEYWORD : -SECTION_START-
; 1750 :     // USAGE   : -SECTION_START-( SectionId )
; 1751 :     //
; 1752 :     //
; 1753 :     NewSection->Control.SectionIdentifier = ExtractSectionIDFromLine( OldSection );

  0009b	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  0009e	50		push	eax
  0009f	e8 00 00 00 00	call	_ExtractSectionIDFromLine@4
  000a4	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  000a7	dd 98 48 01 00
	00		fstp	QWORD PTR [eax+328]

; 1754 :     if ( NewSection->Control.SectionIdentifier == (DOUBLE)0 ) {

  000ad	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  000b0	dd 80 48 01 00
	00		fld	QWORD PTR [eax+328]
  000b6	dc 1d 00 00 00
	00		fcomp	QWORD PTR $T8934
  000bc	df e0		fnstsw	ax
  000be	f6 c4 40	test	ah, 64			; 00000040H
  000c1	0f 84 07 00 00
	00		je	$L8636

; 1755 : 
; 1756 :         //
; 1757 :         // A section without a section ID has ben defined. This is not acceptable
; 1758 :         //
; 1759 :         return FALSE;

  000c7	32 c0		xor	al, al
  000c9	e9 a5 02 00 00	jmp	$L8631
$L8636:

; 1760 : 
; 1761 :     }
; 1762 : 
; 1763 : 
; 1764 :     //
; 1765 :     // Initialize the section description
; 1766 :     //
; 1767 :     // KEYWORD : -SECTION_DESC-
; 1768 :     // USAGE   : -SECTION_DESC-( "Section for MACFRAME testing only" )
; 1769 :     //
; 1770 :     //
; 1771 :     TmpBuffer  = strstr( OldSection->CurrentLine->NormalLine, Keywords[SECTION_DESC] );

  000ce	a1 10 00 00 00	mov	eax, DWORD PTR _Keywords+16
  000d3	50		push	eax
  000d4	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  000d7	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000dd	83 c0 08	add	eax, 8
  000e0	50		push	eax
  000e1	e8 00 00 00 00	call	_strstr
  000e6	83 c4 08	add	esp, 8
  000e9	89 85 fc fe ff
	ff		mov	DWORD PTR _TmpBuffer$[ebp], eax

; 1772 :     if ( TmpBuffer != NULL ) {

  000ef	83 bd fc fe ff
	ff 00		cmp	DWORD PTR _TmpBuffer$[ebp], 0
  000f6	0f 84 6b 00 00
	00		je	$L8637

; 1773 : 
; 1774 :         TmpBuffer  = strchr( TmpBuffer, '"' )+1;

  000fc	6a 22		push	34			; 00000022H
  000fe	8b 85 fc fe ff
	ff		mov	eax, DWORD PTR _TmpBuffer$[ebp]
  00104	50		push	eax
  00105	e8 00 00 00 00	call	_strchr
  0010a	83 c4 08	add	esp, 8
  0010d	40		inc	eax
  0010e	89 85 fc fe ff
	ff		mov	DWORD PTR _TmpBuffer$[ebp], eax

; 1775 :         Length     = strrchr( TmpBuffer, '"' ) - TmpBuffer;

  00114	6a 22		push	34			; 00000022H
  00116	8b 85 fc fe ff
	ff		mov	eax, DWORD PTR _TmpBuffer$[ebp]
  0011c	50		push	eax
  0011d	e8 00 00 00 00	call	_strrchr
  00122	83 c4 08	add	esp, 8
  00125	2b 85 fc fe ff
	ff		sub	eax, DWORD PTR _TmpBuffer$[ebp]
  0012b	89 85 f8 fe ff
	ff		mov	DWORD PTR _Length$[ebp], eax

; 1776 : 
; 1777 :         if ( Length < 0 ) {

  00131	83 bd f8 fe ff
	ff 00		cmp	DWORD PTR _Length$[ebp], 0
  00138	0f 8d 0a 00 00
	00		jge	$L8638

; 1778 :             Length = 0;

  0013e	c7 85 f8 fe ff
	ff 00 00 00 00	mov	DWORD PTR _Length$[ebp], 0
$L8638:

; 1779 :         }
; 1780 :         strncpy( NewSection->SectionDescription, TmpBuffer, Length );

  00148	8b 85 f8 fe ff
	ff		mov	eax, DWORD PTR _Length$[ebp]
  0014e	50		push	eax
  0014f	8b 85 fc fe ff
	ff		mov	eax, DWORD PTR _TmpBuffer$[ebp]
  00155	50		push	eax
  00156	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  00159	05 54 01 00 00	add	eax, 340		; 00000154H
  0015e	50		push	eax
  0015f	e8 00 00 00 00	call	_strncpy
  00164	83 c4 0c	add	esp, 12			; 0000000cH
$L8637:

; 1781 :     }
; 1782 : 
; 1783 :     //
; 1784 :     // Initialize any Optional control sectioning. This if detected without any
; 1785 :     // parameters suggests that the section is under optional comparison. Else
; 1786 :     // certain environment variables are checked and is found enabled, this
; 1787 :     // section is matched
; 1788 :     //
; 1789 :     // KEYWORD : -OPTIONALS-
; 1790 :     // USAGE   : -OPTIONALS-( EnvironmentVar1, EnvironmentVar2...EnvironmentVarN )
; 1791 :     //
; 1792 :     //
; 1793 : 
; 1794 :     strcpy( TmpLine, OldSection->CurrentLine->CompressedLine );

  00167	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  0016a	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00170	05 08 01 00 00	add	eax, 264		; 00000108H
  00175	50		push	eax
  00176	8d 85 f8 fd ff
	ff		lea	eax, DWORD PTR _TmpLine$[ebp]
  0017c	50		push	eax
  0017d	e8 00 00 00 00	call	_strcpy
  00182	83 c4 08	add	esp, 8

; 1795 : 
; 1796 :     TmpBuffer = strstr( TmpLine, Keywords[OPTIONALS] );

  00185	a1 08 00 00 00	mov	eax, DWORD PTR _Keywords+8
  0018a	50		push	eax
  0018b	8d 85 f8 fd ff
	ff		lea	eax, DWORD PTR _TmpLine$[ebp]
  00191	50		push	eax
  00192	e8 00 00 00 00	call	_strstr
  00197	83 c4 08	add	esp, 8
  0019a	89 85 fc fe ff
	ff		mov	DWORD PTR _TmpBuffer$[ebp], eax

; 1797 : 
; 1798 :     if ( TmpBuffer != NULL ) {

  001a0	83 bd fc fe ff
	ff 00		cmp	DWORD PTR _TmpBuffer$[ebp], 0
  001a7	0f 84 0a 01 00
	00		je	$L8639

; 1799 : 
; 1800 :         UINT     EnvCounter1 = 0 , EnvCounter2 = 0   ;

  001ad	c7 85 e8 fd ff
	ff 00 00 00 00	mov	DWORD PTR _EnvCounter1$8640[ebp], 0
  001b7	c7 85 f0 fd ff
	ff 00 00 00 00	mov	DWORD PTR _EnvCounter2$8641[ebp], 0

; 1801 :         PCHAR    Token                               ;
; 1802 :         PCHAR    Seperators = ",)"                   ;

  001c1	c7 85 f4 fd ff
	ff 00 00 00 00	mov	DWORD PTR _Seperators$8643[ebp], OFFSET FLAT:??_C@_02JGGD@?0?$CJ?$AA@ ; `string'

; 1803 : 
; 1804 :         //
; 1805 :         // Weve detected an optional section
; 1806 :         //
; 1807 :         NewSection->Control.OptionalMatching = TRUE;

  001cb	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  001ce	c6 80 50 01 00
	00 01		mov	BYTE PTR [eax+336], 1

; 1808 : 
; 1809 :         TmpBuffer += (strlen( Keywords[OPTIONALS] )+1);

  001d5	a1 08 00 00 00	mov	eax, DWORD PTR _Keywords+8
  001da	50		push	eax
  001db	e8 00 00 00 00	call	_strlen
  001e0	83 c4 04	add	esp, 4
  001e3	40		inc	eax
  001e4	01 85 fc fe ff
	ff		add	DWORD PTR _TmpBuffer$[ebp], eax

; 1810 : 
; 1811 :         //
; 1812 :         // Now detect which Environment variables are enabled.
; 1813 :         // If ALL are not enabled, the section remains an
; 1814 :         // optional section
; 1815 :         //
; 1816 :         Token = strtok( TmpBuffer, Seperators );

  001ea	8b 85 f4 fd ff
	ff		mov	eax, DWORD PTR _Seperators$8643[ebp]
  001f0	50		push	eax
  001f1	8b 85 fc fe ff
	ff		mov	eax, DWORD PTR _TmpBuffer$[ebp]
  001f7	50		push	eax
  001f8	e8 00 00 00 00	call	_strtok
  001fd	83 c4 08	add	esp, 8
  00200	89 85 ec fd ff
	ff		mov	DWORD PTR _Token$8642[ebp], eax
$L8646:

; 1817 : 
; 1818 :         while ( Token != NULL ) {

  00206	83 bd ec fd ff
	ff 00		cmp	DWORD PTR _Token$8642[ebp], 0
  0020d	0f 84 7b 00 00
	00		je	$L8647

; 1819 : 
; 1820 :             EnvCounter1++;

  00213	ff 85 e8 fd ff
	ff		inc	DWORD PTR _EnvCounter1$8640[ebp]

; 1821 : 
; 1822 :             memset( EnvironmentVar, 0, sizeof( EnvironmentVar ) );

  00219	68 00 01 00 00	push	256			; 00000100H
  0021e	6a 00		push	0
  00220	8d 85 00 ff ff
	ff		lea	eax, DWORD PTR _EnvironmentVar$[ebp]
  00226	50		push	eax
  00227	e8 00 00 00 00	call	_memset
  0022c	83 c4 0c	add	esp, 12			; 0000000cH

; 1823 :             strncpy( EnvironmentVar, Token, strlen( Token ) );

  0022f	8b 85 ec fd ff
	ff		mov	eax, DWORD PTR _Token$8642[ebp]
  00235	50		push	eax
  00236	e8 00 00 00 00	call	_strlen
  0023b	83 c4 04	add	esp, 4
  0023e	50		push	eax
  0023f	8b 85 ec fd ff
	ff		mov	eax, DWORD PTR _Token$8642[ebp]
  00245	50		push	eax
  00246	8d 85 00 ff ff
	ff		lea	eax, DWORD PTR _EnvironmentVar$[ebp]
  0024c	50		push	eax
  0024d	e8 00 00 00 00	call	_strncpy
  00252	83 c4 0c	add	esp, 12			; 0000000cH

; 1824 : 
; 1825 :             if ( getenv( EnvironmentVar ) != NULL ) {

  00255	8d 85 00 ff ff
	ff		lea	eax, DWORD PTR _EnvironmentVar$[ebp]
  0025b	50		push	eax
  0025c	e8 00 00 00 00	call	_getenv
  00261	83 c4 04	add	esp, 4
  00264	85 c0		test	eax, eax
  00266	0f 84 06 00 00
	00		je	$L8648

; 1826 : 
; 1827 :                 EnvCounter2++;

  0026c	ff 85 f0 fd ff
	ff		inc	DWORD PTR _EnvCounter2$8641[ebp]
$L8648:

; 1828 : 
; 1829 :             }
; 1830 : 
; 1831 :             Token = strtok( NULL, Seperators );

  00272	8b 85 f4 fd ff
	ff		mov	eax, DWORD PTR _Seperators$8643[ebp]
  00278	50		push	eax
  00279	6a 00		push	0
  0027b	e8 00 00 00 00	call	_strtok
  00280	83 c4 08	add	esp, 8
  00283	89 85 ec fd ff
	ff		mov	DWORD PTR _Token$8642[ebp], eax

; 1832 : 
; 1833 :         }

  00289	e9 78 ff ff ff	jmp	$L8646
$L8647:

; 1834 : 
; 1835 :         //
; 1836 :         // If all the environment variables have been enabled, this is
; 1837 :         // no longer an optional section
; 1838 :         //
; 1839 :         if ( (EnvCounter1 == EnvCounter2) && (EnvCounter1 != 0) ) {

  0028e	8b 85 e8 fd ff
	ff		mov	eax, DWORD PTR _EnvCounter1$8640[ebp]
  00294	39 85 f0 fd ff
	ff		cmp	DWORD PTR _EnvCounter2$8641[ebp], eax
  0029a	0f 85 17 00 00
	00		jne	$L8649
  002a0	83 bd e8 fd ff
	ff 00		cmp	DWORD PTR _EnvCounter1$8640[ebp], 0
  002a7	0f 84 0a 00 00
	00		je	$L8649

; 1840 : 
; 1841 :             NewSection->Control.OptionalMatching = FALSE;

  002ad	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  002b0	c6 80 50 01 00
	00 00		mov	BYTE PTR [eax+336], 0
$L8649:
$L8639:

; 1842 : 
; 1843 :         }
; 1844 : 
; 1845 :     }
; 1846 : 
; 1847 :     //
; 1848 :     // Initialize any Token matching control within the sections.
; 1849 :     //
; 1850 :     // KEYWORD : -TOKEN_MATCH-
; 1851 :     // USAGE   : -TOKEN_MATCH-( StartLine, StopLine )
; 1852 :     //
; 1853 :     // NOTE: The StopLine is expressed as a relative offset from the start line
; 1854 :     //
; 1855 :     NewSection->Control.HeadUnmatchedTokens = NULL;

  002b7	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  002ba	c7 80 44 01 00
	00 00 00 00 00	mov	DWORD PTR [eax+324], 0

; 1856 :     TmpBuffer = strstr( OldSection->CurrentLine->CompressedLine, Keywords[TOKEN_MATCH] );

  002c4	a1 0c 00 00 00	mov	eax, DWORD PTR _Keywords+12
  002c9	50		push	eax
  002ca	8b 45 0c	mov	eax, DWORD PTR _OldSection$[ebp]
  002cd	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  002d3	05 08 01 00 00	add	eax, 264		; 00000108H
  002d8	50		push	eax
  002d9	e8 00 00 00 00	call	_strstr
  002de	83 c4 08	add	esp, 8
  002e1	89 85 fc fe ff
	ff		mov	DWORD PTR _TmpBuffer$[ebp], eax

; 1857 :     if ( TmpBuffer != NULL ) {

  002e7	83 bd fc fe ff
	ff 00		cmp	DWORD PTR _TmpBuffer$[ebp], 0
  002ee	0f 84 78 00 00
	00		je	$L8650

; 1858 : 
; 1859 :         //
; 1860 :         // Weve detected an Token matching section
; 1861 :         //
; 1862 :         NewSection->Control.TokenMatching = TRUE;

  002f4	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  002f7	c6 80 51 01 00
	00 01		mov	BYTE PTR [eax+337], 1

; 1863 : 
; 1864 :         TmpBuffer += (strlen( Keywords[TOKEN_MATCH] )+1);

  002fe	a1 0c 00 00 00	mov	eax, DWORD PTR _Keywords+12
  00303	50		push	eax
  00304	e8 00 00 00 00	call	_strlen
  00309	83 c4 04	add	esp, 4
  0030c	40		inc	eax
  0030d	01 85 fc fe ff
	ff		add	DWORD PTR _TmpBuffer$[ebp], eax

; 1865 : 
; 1866 :         NewSection->Control.TokenMatchStartLine = atol( TmpBuffer );

  00313	8b 85 fc fe ff
	ff		mov	eax, DWORD PTR _TmpBuffer$[ebp]
  00319	50		push	eax
  0031a	e8 00 00 00 00	call	_atol
  0031f	83 c4 04	add	esp, 4
  00322	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  00325	89 81 3c 01 00
	00		mov	DWORD PTR [ecx+316], eax

; 1867 :         NewSection->Control.TokenMatchStopLine  = atol( (strchr(TmpBuffer, ',')+1) );

  0032b	6a 2c		push	44			; 0000002cH
  0032d	8b 85 fc fe ff
	ff		mov	eax, DWORD PTR _TmpBuffer$[ebp]
  00333	50		push	eax
  00334	e8 00 00 00 00	call	_strchr
  00339	83 c4 08	add	esp, 8
  0033c	40		inc	eax
  0033d	50		push	eax
  0033e	e8 00 00 00 00	call	_atol
  00343	83 c4 04	add	esp, 4
  00346	8b 4d 08	mov	ecx, DWORD PTR _NewSection$[ebp]
  00349	89 81 40 01 00
	00		mov	DWORD PTR [ecx+320], eax

; 1868 : 
; 1869 :         if ( NewSection->Control.TokenMatchStopLine == 0 ) {

  0034f	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  00352	83 b8 40 01 00
	00 00		cmp	DWORD PTR [eax+320], 0
  00359	0f 85 0d 00 00
	00		jne	$L8651

; 1870 : 
; 1871 :              NewSection->Control.TokenMatchStopLine = TOKEN_MATCHING_ALL;

  0035f	8b 45 08	mov	eax, DWORD PTR _NewSection$[ebp]
  00362	c7 80 40 01 00
	00 ff ff ff ff	mov	DWORD PTR [eax+320], -1
$L8651:
$L8650:

; 1872 : 
; 1873 :         }
; 1874 : 
; 1875 :     }
; 1876 : 
; 1877 :     return TRUE;

  0036c	b0 01		mov	al, 1
  0036e	e9 00 00 00 00	jmp	$L8631
$L8631:

; 1878 : 
; 1879 : }

  00373	5f		pop	edi
  00374	5e		pop	esi
  00375	5b		pop	ebx
  00376	c9		leave
  00377	c2 08 00	ret	8
_InitializeSectionControl@8 ENDP
_TEXT	ENDS
PUBLIC	_PrintComparisonResults@20
PUBLIC	??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@	; `string'
PUBLIC	??_C@_0CM@BP@?6FOUND?5?5?5?5?$CICOMP?4FILE?5LINE?5CONTEN@ ; `string'
PUBLIC	??_C@_0CL@KOJI@EXPECTED?5?$CIGOLDEN?5FILE?5LINE?5CONTE@ ; `string'
PUBLIC	??_C@_0DM@IAKH@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@ ; `string'
PUBLIC	??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@ ; `string'
PUBLIC	??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0EO@IECB@?6INDEX?5?5?5FOUND?$CICURRENT?5EXTRACTED@ ; `string'
PUBLIC	??_C@_0BD@FJJJ@?$CF5u?5?5?5?$CF32u?5?5?5?$CF32u?6?$AA@ ; `string'
PUBLIC	??_C@_0EK@IIIG@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0DL@IIIL@?6EXPECTED?5VALUES?5BETWEEN?5?$CIEXTRAC@ ; `string'
PUBLIC	??_C@_0CM@BCGB@?6FOUND?5RESULTS?5IN?5ERROR?$CIEXTRACTE@ ; `string'
PUBLIC	??_C@_0CB@BKBO@INDEX?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5RESULT?6@ ; `string'
PUBLIC	??_C@_0M@KOPJ@?$CF5u?5?5?5?$CF23u?6?$AA@	; `string'
PUBLIC	??_C@_0FN@KAEO@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0DC@BBBG@?6UNABLE?5TO?5LOCATE?5LINE?5IN?5THE?5CO@ ; `string'
PUBLIC	??_C@_0DL@GGNP@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0DO@NOPM@?6EXTRA?5LINE?5DETECTED?5?$CICOMP?4?5FILE@ ; `string'
PUBLIC	??_C@_0DN@MBC@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
PUBLIC	??_C@_0DO@ECGD@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
PUBLIC	??_C@_0DN@CEIA@LINE?5ABSENT?5IN?5COMP?4?5FILE?5?$CIGOLDE@ ; `string'
PUBLIC	??_C@_0EO@IMCE@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0EG@LNMH@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
PUBLIC	??_C@_0EH@OPAH@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
PUBLIC	??_C@_0EH@NCPN@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CB@DCBI@?6?6UNKNOWN?5COMPARISON?5RESULT?3?5?$CFu?6@ ; `string'
;	COMDAT ??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@
CONST	SEGMENT
??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@ DB 0aH, 0aH, '__ERROR__ : '
	DB	'%u', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BP@?6FOUND?5?5?5?5?$CICOMP?4FILE?5LINE?5CONTEN@
CONST	SEGMENT
??_C@_0CM@BP@?6FOUND?5?5?5?5?$CICOMP?4FILE?5LINE?5CONTEN@ DB 0aH, 'FOUND '
	DB	'   (COMP.FILE LINE CONTENTS)   : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KOJI@EXPECTED?5?$CIGOLDEN?5FILE?5LINE?5CONTE@
CONST	SEGMENT
??_C@_0CL@KOJI@EXPECTED?5?$CIGOLDEN?5FILE?5LINE?5CONTE@ DB 'EXPECTED (GOL'
	DB	'DEN FILE LINE CONTENTS) : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@IAKH@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0DM@IAKH@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	0aH, 09H, 'ERROR TYPE                     : LINE COMPARISON FA'
	DB	'ILURE', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 09H, 'C'
	DB	'URRENT SECTION ID             : %f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	09H, 'COMP. FILE                     : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@
CONST	SEGMENT
??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@ DB 09H, 'COMP. FI'
	DB	'LE SECTION LINE OFFSET : %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@ DB 09H, 'C'
	DB	'OMP. FILE LINE OFFSET         : %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	09H, 'GOLDEN FILE                    : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@
CONST	SEGMENT
??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@ DB 09H, 'GOLDEN FIL'
	DB	'E SECTION LINE OFFSET: %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@ DB 09H, 'GOL'
	DB	'DEN FILE LINE OFFSET        : %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IECB@?6INDEX?5?5?5FOUND?$CICURRENT?5EXTRACTED@
CONST	SEGMENT
??_C@_0EO@IECB@?6INDEX?5?5?5FOUND?$CICURRENT?5EXTRACTED@ DB 0aH, 'INDEX  '
	DB	' FOUND(CURRENT EXTRACTED RESULTS)   EXPECTED(LAST EXTRACTED R'
	DB	'ESULTS)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FJJJ@?$CF5u?5?5?5?$CF32u?5?5?5?$CF32u?6?$AA@
CONST	SEGMENT
??_C@_0BD@FJJJ@?$CF5u?5?5?5?$CF32u?5?5?5?$CF32u?6?$AA@ DB '%5u   %32u   %'
	DB	'32u', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@IIIG@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0EK@IIIG@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	0aH, 09H, 'ERROR TYPE                     : CURRENT VALUE(S) F'
	DB	'AILED TO EQUAL LAST', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IIIL@?6EXPECTED?5VALUES?5BETWEEN?5?$CIEXTRAC@
CONST	SEGMENT
??_C@_0DL@IIIL@?6EXPECTED?5VALUES?5BETWEEN?5?$CIEXTRAC@ DB 0aH, 'EXPECTED'
	DB	' VALUES BETWEEN (EXTRACTED FROM GOLDEN) : %u, %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BCGB@?6FOUND?5RESULTS?5IN?5ERROR?$CIEXTRACTE@
CONST	SEGMENT
??_C@_0CM@BCGB@?6FOUND?5RESULTS?5IN?5ERROR?$CIEXTRACTE@ DB 0aH, 'FOUND RE'
	DB	'SULTS IN ERROR(EXTRACTED RESULTS)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKBO@INDEX?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5RESULT?6@
CONST	SEGMENT
??_C@_0CB@BKBO@INDEX?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5RESULT?6@ DB 
	DB	'INDEX                    RESULT', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KOPJ@?$CF5u?5?5?5?$CF23u?6?$AA@
CONST	SEGMENT
??_C@_0M@KOPJ@?$CF5u?5?5?5?$CF23u?6?$AA@ DB '%5u   %23u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@KAEO@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0FN@KAEO@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	0aH, 09H, 'ERROR TYPE                     : CURRENT VALUE(S) I'
	DB	'S(ARE) NOT BETWEEN THE EXPECTED VALUES', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBBG@?6UNABLE?5TO?5LOCATE?5LINE?5IN?5THE?5CO@
CONST	SEGMENT
??_C@_0DC@BBBG@?6UNABLE?5TO?5LOCATE?5LINE?5IN?5THE?5CO@ DB 0aH, 'UNABLE T'
	DB	'O LOCATE LINE IN THE COMP. FILE    : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GGNP@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0DL@GGNP@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	0aH, 09H, 'ERROR TYPE                     : UNABLE TO LOCATE T'
	DB	'OKEN', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NOPM@?6EXTRA?5LINE?5DETECTED?5?$CICOMP?4?5FILE@
CONST	SEGMENT
??_C@_0DO@NOPM@?6EXTRA?5LINE?5DETECTED?5?$CICOMP?4?5FILE@ DB 0aH, 'EXTRA '
	DB	'LINE DETECTED (COMP. FILE LINE CONTENTS)         : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@MBC@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT
??_C@_0DN@MBC@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ DB 'GOLDEN FILE L'
	DB	'INE CONTENTS  (Expected to synchronize on): %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@ECGD@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT
??_C@_0DO@ECGD@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ DB 0aH, 'COMP.'
	DB	' FILE LINE CONTENTS  (Expected to synchronize on) : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CEIA@LINE?5ABSENT?5IN?5COMP?4?5FILE?5?$CIGOLDE@
CONST	SEGMENT
??_C@_0DN@CEIA@LINE?5ABSENT?5IN?5COMP?4?5FILE?5?$CIGOLDE@ DB 'LINE ABSENT'
	DB	' IN COMP. FILE (GOLDEN FILE LINE CONTENTS)  : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IMCE@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0EO@IMCE@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	0aH, 09H, 'ERROR TYPE                     : NEW SECTION START '
	DB	'SYNCHRONIZATION FAILURE', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@LNMH@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT
??_C@_0EG@LNMH@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ DB 'GOLDEN FILE '
	DB	'LINE CONTENTS  (Expected to synchronize on): END_OF_FILE', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@OPAH@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@
CONST	SEGMENT
??_C@_0EH@OPAH@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ DB 0aH, 'COMP.'
	DB	' FILE LINE CONTENTS  (Expected to synchronize on) : END_OF_FI'
	DB	'LE', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@NCPN@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0EH@NCPN@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 
	DB	0aH, 09H, 'ERROR TYPE                     : CURRENT SECTION EN'
	DB	'D SYNCH. FAILURE', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DCBI@?6?6UNKNOWN?5COMPARISON?5RESULT?3?5?$CFu?6@
CONST	SEGMENT
??_C@_0CB@DCBI@?6?6UNKNOWN?5COMPARISON?5RESULT?3?5?$CFu?6@ DB 0aH, 0aH, 'U'
	DB	'NKNOWN COMPARISON RESULT: %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT _PrintComparisonResults@20
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_ReturnResult$ = 16
_ErrorCount$ = 20
_DifferenceFile$ = 24
_i$ = -4
_PrintComparisonResults@20 PROC NEAR			; COMDAT

; 1890 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 08	sub	esp, 8
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 1891 : 
; 1892 :     ULONG i;
; 1893 : 
; 1894 :     switch ( ReturnResult ) {

  00009	8b 45 10	mov	eax, DWORD PTR _ReturnResult$[ebp]
  0000c	89 45 f8	mov	DWORD PTR -8+[ebp], eax
  0000f	e9 5e 08 00 00	jmp	$L8659
$L8663:

; 1895 : 
; 1896 :         case COMPARE_LINE :
; 1897 : 
; 1898 :             //
; 1899 :             // Report the difference in the difference file
; 1900 :             //
; 1901 :             fprintf( DifferenceFile, "\n\n__ERROR__ : %u\n", ErrorCount );

  00014	8b 45 14	mov	eax, DWORD PTR _ErrorCount$[ebp]
  00017	50		push	eax
  00018	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@ ; `string'
  0001d	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00020	50		push	eax
  00021	e8 00 00 00 00	call	_fprintf
  00026	83 c4 0c	add	esp, 12			; 0000000cH

; 1902 : 
; 1903 :             fprintf( DifferenceFile, "\nFOUND    (COMP.FILE LINE CONTENTS)   : %s\n",
; 1904 :                      FirstSection->CurrentLine->NormalLine );

  00029	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0002c	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00032	83 c0 08	add	eax, 8
  00035	50		push	eax
  00036	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CM@BP@?6FOUND?5?5?5?5?$CICOMP?4FILE?5LINE?5CONTEN@ ; `string'
  0003b	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0003e	50		push	eax
  0003f	e8 00 00 00 00	call	_fprintf
  00044	83 c4 0c	add	esp, 12			; 0000000cH

; 1905 :             fprintf( DifferenceFile, "EXPECTED (GOLDEN FILE LINE CONTENTS) : %s\n",
; 1906 :                      SecondSection->CurrentLine->NormalLine );

  00047	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0004a	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00050	83 c0 08	add	eax, 8
  00053	50		push	eax
  00054	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CL@KOJI@EXPECTED?5?$CIGOLDEN?5FILE?5LINE?5CONTE@ ; `string'
  00059	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0005c	50		push	eax
  0005d	e8 00 00 00 00	call	_fprintf
  00062	83 c4 0c	add	esp, 12			; 0000000cH

; 1907 : 
; 1908 :             //
; 1909 :             // Since this program is for the second file being the GOLDEN file
; 1910 :             // It prints out information with reference to the GOLDEN file
; 1911 :             //
; 1912 : 
; 1913 :             fprintf( DifferenceFile, "\n\tERROR TYPE                     : LINE COMPARISON FAILURE\n" );

  00065	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DM@IAKH@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0006a	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0006d	50		push	eax
  0006e	e8 00 00 00 00	call	_fprintf
  00073	83 c4 08	add	esp, 8

; 1914 :             fprintf( DifferenceFile, "\tCURRENT SECTION ID             : %f\n",
; 1915 :                      SecondSection->Control.SectionIdentifier );

  00076	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00079	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  0007f	51		push	ecx
  00080	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  00086	50		push	eax
  00087	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0008c	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0008f	50		push	eax
  00090	e8 00 00 00 00	call	_fprintf
  00095	83 c4 10	add	esp, 16			; 00000010H

; 1916 :             fprintf( DifferenceFile, "\tCOMP. FILE                     : %s\n",
; 1917 :                      FirstSection->File->FileName  );

  00098	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0009b	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  000a1	8b 40 04	mov	eax, DWORD PTR [eax+4]
  000a4	50		push	eax
  000a5	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  000aa	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  000ad	50		push	eax
  000ae	e8 00 00 00 00	call	_fprintf
  000b3	83 c4 0c	add	esp, 12			; 0000000cH

; 1918 :             fprintf( DifferenceFile, "\tCOMP. FILE SECTION LINE OFFSET : %u\n",
; 1919 :                      FirstSection->Control.SectionLineCount );

  000b6	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000b9	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  000bf	50		push	eax
  000c0	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@ ; `string'
  000c5	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  000c8	50		push	eax
  000c9	e8 00 00 00 00	call	_fprintf
  000ce	83 c4 0c	add	esp, 12			; 0000000cH

; 1920 :             fprintf( DifferenceFile, "\tCOMP. FILE LINE OFFSET         : %u\n",
; 1921 :                      FirstSection->File->CurrentFileLine );

  000d1	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000d4	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  000da	8b 00		mov	eax, DWORD PTR [eax]
  000dc	50		push	eax
  000dd	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@ ; `string'
  000e2	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  000e5	50		push	eax
  000e6	e8 00 00 00 00	call	_fprintf
  000eb	83 c4 0c	add	esp, 12			; 0000000cH

; 1922 :             fprintf( DifferenceFile, "\tGOLDEN FILE                    : %s\n",
; 1923 :                      SecondSection->File->FileName );

  000ee	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  000f1	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  000f7	8b 40 04	mov	eax, DWORD PTR [eax+4]
  000fa	50		push	eax
  000fb	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00100	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00103	50		push	eax
  00104	e8 00 00 00 00	call	_fprintf
  00109	83 c4 0c	add	esp, 12			; 0000000cH

; 1924 :             fprintf( DifferenceFile, "\tGOLDEN FILE SECTION LINE OFFSET: %u\n",
; 1925 :                      SecondSection->Control.SectionLineCount );

  0010c	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0010f	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  00115	50		push	eax
  00116	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@ ; `string'
  0011b	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0011e	50		push	eax
  0011f	e8 00 00 00 00	call	_fprintf
  00124	83 c4 0c	add	esp, 12			; 0000000cH

; 1926 :             fprintf( DifferenceFile, "\tGOLDEN FILE LINE OFFSET        : %u\n",
; 1927 :                      SecondSection->File->CurrentFileLine );

  00127	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0012a	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00130	8b 00		mov	eax, DWORD PTR [eax]
  00132	50		push	eax
  00133	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@ ; `string'
  00138	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0013b	50		push	eax
  0013c	e8 00 00 00 00	call	_fprintf
  00141	83 c4 0c	add	esp, 12			; 0000000cH

; 1928 : 
; 1929 :             break;

  00144	e9 58 07 00 00	jmp	$L8660
$L8675:

; 1930 : 
; 1931 :         case COMPARE_EQUAL_LAST:
; 1932 : 
; 1933 :             //
; 1934 :             // Report the difference in the difference file
; 1935 :             //
; 1936 :             fprintf( DifferenceFile, "\n\n__ERROR__ : %u\n", ErrorCount );

  00149	8b 45 14	mov	eax, DWORD PTR _ErrorCount$[ebp]
  0014c	50		push	eax
  0014d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@ ; `string'
  00152	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00155	50		push	eax
  00156	e8 00 00 00 00	call	_fprintf
  0015b	83 c4 0c	add	esp, 12			; 0000000cH

; 1937 : 
; 1938 :             fprintf( DifferenceFile, "\nINDEX   FOUND(CURRENT EXTRACTED RESULTS)   EXPECTED(LAST EXTRACTED RESULTS)\n" );

  0015e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EO@IECB@?6INDEX?5?5?5FOUND?$CICURRENT?5EXTRACTED@ ; `string'
  00163	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00166	50		push	eax
  00167	e8 00 00 00 00	call	_fprintf
  0016c	83 c4 08	add	esp, 8

; 1939 :             for( i = 0; i < FirstSection->NumberOfCurrentResults; i++ ) {

  0016f	c7 45 fc 00 00
	00 00		mov	DWORD PTR _i$[ebp], 0
  00176	e9 03 00 00 00	jmp	$L8677
$L8678:
  0017b	ff 45 fc	inc	DWORD PTR _i$[ebp]
$L8677:
  0017e	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00181	8b 4d fc	mov	ecx, DWORD PTR _i$[ebp]
  00184	39 88 04 01 00
	00		cmp	DWORD PTR [eax+260], ecx
  0018a	0f 86 4a 00 00
	00		jbe	$L8679

; 1940 : 
; 1941 :                 if ( FirstSection->ResultsError[i] != RESULTS_EQUAL ) {

  00190	8b 45 fc	mov	eax, DWORD PTR _i$[ebp]
  00193	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  00196	33 d2		xor	edx, edx
  00198	8a 94 08 08 01
	00 00		mov	dl, BYTE PTR [eax+ecx+264]
  0019f	85 d2		test	edx, edx
  001a1	0f 84 2e 00 00
	00		je	$L8680

; 1942 : 
; 1943 :                     fprintf( DifferenceFile, "%5u   %32u   %32u\n",
; 1944 :                              (i+1),
; 1945 :                              FirstSection->CurrentResults[i],
; 1946 :                              FirstSection->LastResults[i]
; 1947 : 
; 1948 :                            );

  001a7	8b 45 fc	mov	eax, DWORD PTR _i$[ebp]
  001aa	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  001ad	8b 04 81	mov	eax, DWORD PTR [ecx+eax*4]
  001b0	50		push	eax
  001b1	8b 45 fc	mov	eax, DWORD PTR _i$[ebp]
  001b4	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  001b7	8b 84 81 80 00
	00 00		mov	eax, DWORD PTR [ecx+eax*4+128]
  001be	50		push	eax
  001bf	8b 45 fc	mov	eax, DWORD PTR _i$[ebp]
  001c2	40		inc	eax
  001c3	50		push	eax
  001c4	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BD@FJJJ@?$CF5u?5?5?5?$CF32u?5?5?5?$CF32u?6?$AA@ ; `string'
  001c9	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  001cc	50		push	eax
  001cd	e8 00 00 00 00	call	_fprintf
  001d2	83 c4 14	add	esp, 20			; 00000014H
$L8680:

; 1949 : 
; 1950 :                 }
; 1951 : 
; 1952 :             }

  001d5	e9 a1 ff ff ff	jmp	$L8678
$L8679:

; 1953 : 
; 1954 :             fprintf( DifferenceFile, "\n\tERROR TYPE                     : CURRENT VALUE(S) FAILED TO EQUAL LAST\n" );

  001da	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EK@IIIG@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  001df	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  001e2	50		push	eax
  001e3	e8 00 00 00 00	call	_fprintf
  001e8	83 c4 08	add	esp, 8

; 1955 :             fprintf( DifferenceFile, "\tCURRENT SECTION ID             : %f\n",
; 1956 :                      FirstSection->Control.SectionIdentifier );

  001eb	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  001ee	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  001f4	51		push	ecx
  001f5	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  001fb	50		push	eax
  001fc	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00201	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00204	50		push	eax
  00205	e8 00 00 00 00	call	_fprintf
  0020a	83 c4 10	add	esp, 16			; 00000010H

; 1957 :             fprintf( DifferenceFile, "\tCOMP. FILE                     : %s\n", FirstSection->File->FileName );

  0020d	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00210	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00216	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00219	50		push	eax
  0021a	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0021f	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00222	50		push	eax
  00223	e8 00 00 00 00	call	_fprintf
  00228	83 c4 0c	add	esp, 12			; 0000000cH

; 1958 :             fprintf( DifferenceFile, "\tCOMP. FILE SECTION LINE OFFSET : %u\n",
; 1959 :                      FirstSection->Control.SectionLineCount );

  0022b	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0022e	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  00234	50		push	eax
  00235	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@ ; `string'
  0023a	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0023d	50		push	eax
  0023e	e8 00 00 00 00	call	_fprintf
  00243	83 c4 0c	add	esp, 12			; 0000000cH

; 1960 :             fprintf( DifferenceFile, "\tCOMP. FILE LINE OFFSET         : %u\n",
; 1961 :                      FirstSection->File->CurrentFileLine );

  00246	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00249	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  0024f	8b 00		mov	eax, DWORD PTR [eax]
  00251	50		push	eax
  00252	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@ ; `string'
  00257	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0025a	50		push	eax
  0025b	e8 00 00 00 00	call	_fprintf
  00260	83 c4 0c	add	esp, 12			; 0000000cH

; 1962 : 
; 1963 : 
; 1964 :             break;

  00263	e9 39 06 00 00	jmp	$L8660
$L8683:

; 1965 : 
; 1966 :         case COMPARE_BETWEEN_VALUES:
; 1967 : 
; 1968 :             //
; 1969 :             // Report the difference in the difference file
; 1970 :             //
; 1971 :             fprintf( DifferenceFile, "\n\n__ERROR__ : %u\n", ErrorCount );

  00268	8b 45 14	mov	eax, DWORD PTR _ErrorCount$[ebp]
  0026b	50		push	eax
  0026c	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@ ; `string'
  00271	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00274	50		push	eax
  00275	e8 00 00 00 00	call	_fprintf
  0027a	83 c4 0c	add	esp, 12			; 0000000cH

; 1972 : 
; 1973 :             fprintf( DifferenceFile, "\nEXPECTED VALUES BETWEEN (EXTRACTED FROM GOLDEN) : %u, %u\n",
; 1974 :                      SecondSection->MinimumValue, SecondSection->MaximumValue );

  0027d	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00280	8b 80 2c 01 00
	00		mov	eax, DWORD PTR [eax+300]
  00286	50		push	eax
  00287	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0028a	8b 80 28 01 00
	00		mov	eax, DWORD PTR [eax+296]
  00290	50		push	eax
  00291	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DL@IIIL@?6EXPECTED?5VALUES?5BETWEEN?5?$CIEXTRAC@ ; `string'
  00296	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00299	50		push	eax
  0029a	e8 00 00 00 00	call	_fprintf
  0029f	83 c4 10	add	esp, 16			; 00000010H

; 1975 :             fprintf( DifferenceFile, "\nFOUND RESULTS IN ERROR(EXTRACTED RESULTS)\n" );

  002a2	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CM@BCGB@?6FOUND?5RESULTS?5IN?5ERROR?$CIEXTRACTE@ ; `string'
  002a7	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  002aa	50		push	eax
  002ab	e8 00 00 00 00	call	_fprintf
  002b0	83 c4 08	add	esp, 8

; 1976 :             fprintf( DifferenceFile, "INDEX                    RESULT\n" );

  002b3	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CB@BKBO@INDEX?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5RESULT?6@ ; `string'
  002b8	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  002bb	50		push	eax
  002bc	e8 00 00 00 00	call	_fprintf
  002c1	83 c4 08	add	esp, 8

; 1977 : 
; 1978 :             for( i = 0; i < FirstSection->NumberOfCurrentResults; i++ ) {

  002c4	c7 45 fc 00 00
	00 00		mov	DWORD PTR _i$[ebp], 0
  002cb	e9 03 00 00 00	jmp	$L8687
$L8688:
  002d0	ff 45 fc	inc	DWORD PTR _i$[ebp]
$L8687:
  002d3	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  002d6	8b 4d fc	mov	ecx, DWORD PTR _i$[ebp]
  002d9	39 88 04 01 00
	00		cmp	DWORD PTR [eax+260], ecx
  002df	0f 86 40 00 00
	00		jbe	$L8689

; 1979 : 
; 1980 :                 if ( FirstSection->ResultsError[i] != RESULTS_EQUAL ) {

  002e5	8b 45 fc	mov	eax, DWORD PTR _i$[ebp]
  002e8	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  002eb	33 d2		xor	edx, edx
  002ed	8a 94 08 08 01
	00 00		mov	dl, BYTE PTR [eax+ecx+264]
  002f4	85 d2		test	edx, edx
  002f6	0f 84 24 00 00
	00		je	$L8690

; 1981 : 
; 1982 :                     fprintf( DifferenceFile, "%5u   %23u\n",
; 1983 :                              (i+1),
; 1984 :                              FirstSection->CurrentResults[i]
; 1985 :                            );

  002fc	8b 45 fc	mov	eax, DWORD PTR _i$[ebp]
  002ff	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  00302	8b 84 81 80 00
	00 00		mov	eax, DWORD PTR [ecx+eax*4+128]
  00309	50		push	eax
  0030a	8b 45 fc	mov	eax, DWORD PTR _i$[ebp]
  0030d	40		inc	eax
  0030e	50		push	eax
  0030f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0M@KOPJ@?$CF5u?5?5?5?$CF23u?6?$AA@ ; `string'
  00314	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00317	50		push	eax
  00318	e8 00 00 00 00	call	_fprintf
  0031d	83 c4 10	add	esp, 16			; 00000010H
$L8690:

; 1986 : 
; 1987 :                 }
; 1988 : 
; 1989 :             }

  00320	e9 ab ff ff ff	jmp	$L8688
$L8689:

; 1990 : 
; 1991 :             fprintf( DifferenceFile, "\n\tERROR TYPE                     : CURRENT VALUE(S) IS(ARE) NOT BETWEEN THE EXPECTED VALUES\n" );

  00325	68 00 00 00 00	push	OFFSET FLAT:??_C@_0FN@KAEO@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0032a	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0032d	50		push	eax
  0032e	e8 00 00 00 00	call	_fprintf
  00333	83 c4 08	add	esp, 8

; 1992 :             fprintf( DifferenceFile, "\tCURRENT SECTION ID             : %f\n",
; 1993 :                      FirstSection->Control.SectionIdentifier );

  00336	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00339	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  0033f	51		push	ecx
  00340	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  00346	50		push	eax
  00347	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0034c	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0034f	50		push	eax
  00350	e8 00 00 00 00	call	_fprintf
  00355	83 c4 10	add	esp, 16			; 00000010H

; 1994 :             fprintf( DifferenceFile, "\tCOMP. FILE                     : %s\n", FirstSection->File->FileName );

  00358	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0035b	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00361	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00364	50		push	eax
  00365	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0036a	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0036d	50		push	eax
  0036e	e8 00 00 00 00	call	_fprintf
  00373	83 c4 0c	add	esp, 12			; 0000000cH

; 1995 :             fprintf( DifferenceFile, "\tCOMP. FILE SECTION LINE OFFSET : %u\n",
; 1996 :                      FirstSection->Control.SectionLineCount );

  00376	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00379	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  0037f	50		push	eax
  00380	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@ ; `string'
  00385	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00388	50		push	eax
  00389	e8 00 00 00 00	call	_fprintf
  0038e	83 c4 0c	add	esp, 12			; 0000000cH

; 1997 :             fprintf( DifferenceFile, "\tCOMP. FILE LINE OFFSET         : %u\n",
; 1998 :                      FirstSection->File->CurrentFileLine );

  00391	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00394	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  0039a	8b 00		mov	eax, DWORD PTR [eax]
  0039c	50		push	eax
  0039d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@ ; `string'
  003a2	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  003a5	50		push	eax
  003a6	e8 00 00 00 00	call	_fprintf
  003ab	83 c4 0c	add	esp, 12			; 0000000cH

; 1999 : 
; 2000 :             break;

  003ae	e9 ee 04 00 00	jmp	$L8660
$L8693:

; 2001 : 
; 2002 :         case COMPARE_TOKEN :
; 2003 : 
; 2004 :             //
; 2005 :             // Report the difference in the difference file
; 2006 :             //
; 2007 :             fprintf( DifferenceFile, "\n\n__ERROR__ : %u\n", ErrorCount );

  003b3	8b 45 14	mov	eax, DWORD PTR _ErrorCount$[ebp]
  003b6	50		push	eax
  003b7	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@ ; `string'
  003bc	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  003bf	50		push	eax
  003c0	e8 00 00 00 00	call	_fprintf
  003c5	83 c4 0c	add	esp, 12			; 0000000cH

; 2008 : 
; 2009 :             fprintf( DifferenceFile, "\nUNABLE TO LOCATE LINE IN THE COMP. FILE    : %s\n",
; 2010 :                      SecondSection->Control.HeadUnmatchedTokens->NormalToken );

  003c8	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  003cb	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  003d1	83 c0 10	add	eax, 16			; 00000010H
  003d4	50		push	eax
  003d5	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DC@BBBG@?6UNABLE?5TO?5LOCATE?5LINE?5IN?5THE?5CO@ ; `string'
  003da	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  003dd	50		push	eax
  003de	e8 00 00 00 00	call	_fprintf
  003e3	83 c4 0c	add	esp, 12			; 0000000cH

; 2011 : 
; 2012 :             fprintf( DifferenceFile, "\n\tERROR TYPE                     : UNABLE TO LOCATE TOKEN\n" );

  003e6	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DL@GGNP@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  003eb	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  003ee	50		push	eax
  003ef	e8 00 00 00 00	call	_fprintf
  003f4	83 c4 08	add	esp, 8

; 2013 :             fprintf( DifferenceFile, "\tCURRENT SECTION ID             : %f\n",
; 2014 :                      SecondSection->Control.SectionIdentifier );

  003f7	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  003fa	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  00400	51		push	ecx
  00401	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  00407	50		push	eax
  00408	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0040d	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00410	50		push	eax
  00411	e8 00 00 00 00	call	_fprintf
  00416	83 c4 10	add	esp, 16			; 00000010H

; 2015 : 
; 2016 :             fprintf( DifferenceFile, "\tCOMP. FILE                     : %s\n",
; 2017 :                      FirstSection->File->FileName );

  00419	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0041c	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00422	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00425	50		push	eax
  00426	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0042b	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0042e	50		push	eax
  0042f	e8 00 00 00 00	call	_fprintf
  00434	83 c4 0c	add	esp, 12			; 0000000cH

; 2018 :             fprintf( DifferenceFile, "\tGOLDEN FILE                    : %s\n",
; 2019 :                      SecondSection->File->FileName );

  00437	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0043a	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00440	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00443	50		push	eax
  00444	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00449	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0044c	50		push	eax
  0044d	e8 00 00 00 00	call	_fprintf
  00452	83 c4 0c	add	esp, 12			; 0000000cH

; 2020 :             fprintf( DifferenceFile, "\tGOLDEN FILE SECTION LINE OFFSET: %u\n",
; 2021 :                      SecondSection->Control.HeadUnmatchedTokens->LinePosition );

  00455	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00458	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  0045e	8b 00		mov	eax, DWORD PTR [eax]
  00460	50		push	eax
  00461	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@ ; `string'
  00466	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00469	50		push	eax
  0046a	e8 00 00 00 00	call	_fprintf
  0046f	83 c4 0c	add	esp, 12			; 0000000cH

; 2022 :             fprintf( DifferenceFile, "\tGOLDEN FILE LINE OFFSET        : %u\n",
; 2023 :                      SecondSection->Control.HeadUnmatchedTokens->FileLinePosition );

  00472	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00475	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  0047b	8b 40 04	mov	eax, DWORD PTR [eax+4]
  0047e	50		push	eax
  0047f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@ ; `string'
  00484	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00487	50		push	eax
  00488	e8 00 00 00 00	call	_fprintf
  0048d	83 c4 0c	add	esp, 12			; 0000000cH

; 2024 : 
; 2025 :             break;

  00490	e9 0c 04 00 00	jmp	$L8660
$L8696:

; 2026 : 
; 2027 :         case COMPARE_START :
; 2028 : 
; 2029 :             //
; 2030 :             // Report the difference in the difference file
; 2031 :             //
; 2032 :             fprintf( DifferenceFile, "\n\n__ERROR__ : %u\n", ErrorCount );

  00495	8b 45 14	mov	eax, DWORD PTR _ErrorCount$[ebp]
  00498	50		push	eax
  00499	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@ ; `string'
  0049e	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  004a1	50		push	eax
  004a2	e8 00 00 00 00	call	_fprintf
  004a7	83 c4 0c	add	esp, 12			; 0000000cH

; 2033 : 
; 2034 :             if ( FirstSection->CurrentLine->LineType != LINE_TYPE_SECTION_START ) {

  004aa	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  004ad	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  004b3	33 c9		xor	ecx, ecx
  004b5	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  004bb	83 f9 01	cmp	ecx, 1
  004be	0f 84 41 00 00
	00		je	$L8697

; 2035 : 
; 2036 :                 fprintf( DifferenceFile, "\nEXTRA LINE DETECTED (COMP. FILE LINE CONTENTS)         : %s\n",
; 2037 :                          FirstSection->CurrentLine->NormalLine );

  004c4	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  004c7	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  004cd	83 c0 08	add	eax, 8
  004d0	50		push	eax
  004d1	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DO@NOPM@?6EXTRA?5LINE?5DETECTED?5?$CICOMP?4?5FILE@ ; `string'
  004d6	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  004d9	50		push	eax
  004da	e8 00 00 00 00	call	_fprintf
  004df	83 c4 0c	add	esp, 12			; 0000000cH

; 2038 :                 fprintf( DifferenceFile, "GOLDEN FILE LINE CONTENTS  (Expected to synchronize on): %s\n",
; 2039 :                          SecondSection->CurrentLine->NormalLine );

  004e2	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  004e5	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  004eb	83 c0 08	add	eax, 8
  004ee	50		push	eax
  004ef	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@MBC@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
  004f4	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  004f7	50		push	eax
  004f8	e8 00 00 00 00	call	_fprintf
  004fd	83 c4 0c	add	esp, 12			; 0000000cH

; 2040 : 
; 2041 :             } else {

  00500	e9 3c 00 00 00	jmp	$L8700
$L8697:

; 2042 : 
; 2043 :                 fprintf( DifferenceFile, "\nCOMP. FILE LINE CONTENTS  (Expected to synchronize on) : %s\n",
; 2044 :                          FirstSection->CurrentLine->NormalLine );

  00505	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00508	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0050e	83 c0 08	add	eax, 8
  00511	50		push	eax
  00512	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DO@ECGD@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
  00517	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0051a	50		push	eax
  0051b	e8 00 00 00 00	call	_fprintf
  00520	83 c4 0c	add	esp, 12			; 0000000cH

; 2045 :                 fprintf( DifferenceFile, "LINE ABSENT IN COMP. FILE (GOLDEN FILE LINE CONTENTS)  : %s\n",
; 2046 :                          SecondSection->CurrentLine->NormalLine );

  00523	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00526	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0052c	83 c0 08	add	eax, 8
  0052f	50		push	eax
  00530	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@CEIA@LINE?5ABSENT?5IN?5COMP?4?5FILE?5?$CIGOLDE@ ; `string'
  00535	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00538	50		push	eax
  00539	e8 00 00 00 00	call	_fprintf
  0053e	83 c4 0c	add	esp, 12			; 0000000cH
$L8700:

; 2047 : 
; 2048 :             }
; 2049 : 
; 2050 :             fprintf( DifferenceFile, "\n\tERROR TYPE                     : NEW SECTION START SYNCHRONIZATION FAILURE\n" );

  00541	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EO@IMCE@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00546	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00549	50		push	eax
  0054a	e8 00 00 00 00	call	_fprintf
  0054f	83 c4 08	add	esp, 8

; 2051 :             fprintf( DifferenceFile, "\tCURRENT SECTION ID             : %f\n",
; 2052 :                      SecondSection->Control.SectionIdentifier );

  00552	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00555	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  0055b	51		push	ecx
  0055c	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  00562	50		push	eax
  00563	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00568	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0056b	50		push	eax
  0056c	e8 00 00 00 00	call	_fprintf
  00571	83 c4 10	add	esp, 16			; 00000010H

; 2053 : 
; 2054 :             fprintf( DifferenceFile, "\tCOMP. FILE                     : %s\n",
; 2055 :                      FirstSection->File->FileName );

  00574	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00577	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  0057d	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00580	50		push	eax
  00581	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00586	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00589	50		push	eax
  0058a	e8 00 00 00 00	call	_fprintf
  0058f	83 c4 0c	add	esp, 12			; 0000000cH

; 2056 :             fprintf( DifferenceFile, "\tCOMP. FILE SECTION LINE OFFSET : %u\n",
; 2057 :                      FirstSection->Control.SectionLineCount );

  00592	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00595	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  0059b	50		push	eax
  0059c	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@ ; `string'
  005a1	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  005a4	50		push	eax
  005a5	e8 00 00 00 00	call	_fprintf
  005aa	83 c4 0c	add	esp, 12			; 0000000cH

; 2058 :             fprintf( DifferenceFile, "\tCOMP. FILE LINE OFFSET         : %u\n",
; 2059 :                      FirstSection->File->CurrentFileLine );

  005ad	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  005b0	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  005b6	8b 00		mov	eax, DWORD PTR [eax]
  005b8	50		push	eax
  005b9	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@ ; `string'
  005be	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  005c1	50		push	eax
  005c2	e8 00 00 00 00	call	_fprintf
  005c7	83 c4 0c	add	esp, 12			; 0000000cH

; 2060 : 
; 2061 :             fprintf( DifferenceFile, "\tGOLDEN FILE                    : %s\n",
; 2062 :                      SecondSection->File->FileName );

  005ca	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  005cd	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  005d3	8b 40 04	mov	eax, DWORD PTR [eax+4]
  005d6	50		push	eax
  005d7	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  005dc	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  005df	50		push	eax
  005e0	e8 00 00 00 00	call	_fprintf
  005e5	83 c4 0c	add	esp, 12			; 0000000cH

; 2063 :             fprintf( DifferenceFile, "\tGOLDEN FILE SECTION LINE OFFSET: %u\n",
; 2064 :                      SecondSection->Control.SectionLineCount );

  005e8	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  005eb	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  005f1	50		push	eax
  005f2	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@ ; `string'
  005f7	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  005fa	50		push	eax
  005fb	e8 00 00 00 00	call	_fprintf
  00600	83 c4 0c	add	esp, 12			; 0000000cH

; 2065 :             fprintf( DifferenceFile, "\tGOLDEN FILE LINE OFFSET        : %u\n",
; 2066 :                      SecondSection->File->CurrentFileLine );

  00603	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00606	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  0060c	8b 00		mov	eax, DWORD PTR [eax]
  0060e	50		push	eax
  0060f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@ ; `string'
  00614	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00617	50		push	eax
  00618	e8 00 00 00 00	call	_fprintf
  0061d	83 c4 0c	add	esp, 12			; 0000000cH

; 2067 : 
; 2068 :             break;

  00620	e9 7c 02 00 00	jmp	$L8660
$L8704:

; 2069 : 
; 2070 : 
; 2071 :         case COMPARE_END   :
; 2072 : 
; 2073 :             //
; 2074 :             // Report the difference in the difference file
; 2075 :             //
; 2076 :             fprintf( DifferenceFile, "\n\n__ERROR__ : %u\n", ErrorCount );

  00625	8b 45 14	mov	eax, DWORD PTR _ErrorCount$[ebp]
  00628	50		push	eax
  00629	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BC@MJGK@?6?6__ERROR__?5?3?5?$CFu?6?$AA@ ; `string'
  0062e	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00631	50		push	eax
  00632	e8 00 00 00 00	call	_fprintf
  00637	83 c4 0c	add	esp, 12			; 0000000cH

; 2077 : 
; 2078 :             if ( FirstSection->CurrentLine->LineType != LINE_TYPE_SECTION_END ) {

  0063a	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0063d	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00643	33 c9		xor	ecx, ecx
  00645	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  0064b	83 f9 02	cmp	ecx, 2
  0064e	0f 84 90 00 00
	00		je	$L8705

; 2079 : 
; 2080 :                 fprintf( DifferenceFile, "\nEXTRA LINE DETECTED (COMP. FILE LINE CONTENTS)         : %s\n",
; 2081 :                          FirstSection->CurrentLine->NormalLine );

  00654	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00657	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0065d	83 c0 08	add	eax, 8
  00660	50		push	eax
  00661	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DO@NOPM@?6EXTRA?5LINE?5DETECTED?5?$CICOMP?4?5FILE@ ; `string'
  00666	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00669	50		push	eax
  0066a	e8 00 00 00 00	call	_fprintf
  0066f	83 c4 0c	add	esp, 12			; 0000000cH

; 2082 : 
; 2083 :                 if ( ( SecondSection->Control.SectionIdentifier == (DOUBLE)0 ) &&
; 2084 :                      ( strlen( SecondSection->CurrentLine->CompressedLine ) == 0 ) ) {

  00672	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00675	dd 80 48 01 00
	00		fld	QWORD PTR [eax+328]
  0067b	dc 1d 00 00 00
	00		fcomp	QWORD PTR $T8934
  00681	df e0		fnstsw	ax
  00683	f6 c4 40	test	ah, 64			; 00000040H
  00686	0f 84 35 00 00
	00		je	$L8706
  0068c	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0068f	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00695	05 08 01 00 00	add	eax, 264		; 00000108H
  0069a	50		push	eax
  0069b	e8 00 00 00 00	call	_strlen
  006a0	83 c4 04	add	esp, 4
  006a3	85 c0		test	eax, eax
  006a5	0f 85 16 00 00
	00		jne	$L8706

; 2085 : 
; 2086 :                     fprintf( DifferenceFile, "GOLDEN FILE LINE CONTENTS  (Expected to synchronize on): END_OF_FILE\n" );

  006ab	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EG@LNMH@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
  006b0	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  006b3	50		push	eax
  006b4	e8 00 00 00 00	call	_fprintf
  006b9	83 c4 08	add	esp, 8

; 2087 : 
; 2088 :                 } else {

  006bc	e9 1e 00 00 00	jmp	$L8708
$L8706:

; 2089 : 
; 2090 :                     fprintf( DifferenceFile, "GOLDEN FILE LINE CONTENTS  (Expected to synchronize on): %s\n",
; 2091 :                              SecondSection->CurrentLine->NormalLine );

  006c1	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  006c4	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  006ca	83 c0 08	add	eax, 8
  006cd	50		push	eax
  006ce	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@MBC@GOLDEN?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
  006d3	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  006d6	50		push	eax
  006d7	e8 00 00 00 00	call	_fprintf
  006dc	83 c4 0c	add	esp, 12			; 0000000cH
$L8708:

; 2092 :                 }
; 2093 : 
; 2094 :             } else {

  006df	e9 8b 00 00 00	jmp	$L8709
$L8705:

; 2095 : 
; 2096 :                 if ( ( FirstSection->Control.SectionIdentifier == (DOUBLE)0 ) &&
; 2097 :                      ( strlen( FirstSection->CurrentLine->CompressedLine ) == 0 ) ) {

  006e4	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  006e7	dd 80 48 01 00
	00		fld	QWORD PTR [eax+328]
  006ed	dc 1d 00 00 00
	00		fcomp	QWORD PTR $T8934
  006f3	df e0		fnstsw	ax
  006f5	f6 c4 40	test	ah, 64			; 00000040H
  006f8	0f 84 35 00 00
	00		je	$L8710
  006fe	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00701	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00707	05 08 01 00 00	add	eax, 264		; 00000108H
  0070c	50		push	eax
  0070d	e8 00 00 00 00	call	_strlen
  00712	83 c4 04	add	esp, 4
  00715	85 c0		test	eax, eax
  00717	0f 85 16 00 00
	00		jne	$L8710

; 2098 : 
; 2099 :                     fprintf( DifferenceFile, "\nCOMP. FILE LINE CONTENTS  (Expected to synchronize on) : END_OF_FILE\n" );

  0071d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EH@OPAH@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
  00722	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00725	50		push	eax
  00726	e8 00 00 00 00	call	_fprintf
  0072b	83 c4 08	add	esp, 8

; 2100 : 
; 2101 :                 } else {

  0072e	e9 1e 00 00 00	jmp	$L8712
$L8710:

; 2102 : 
; 2103 :                     fprintf( DifferenceFile, "\nCOMP. FILE LINE CONTENTS  (Expected to synchronize on) : %s\n",
; 2104 :                              FirstSection->CurrentLine->NormalLine );

  00733	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00736	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0073c	83 c0 08	add	eax, 8
  0073f	50		push	eax
  00740	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DO@ECGD@?6COMP?4?5FILE?5LINE?5CONTENTS?5?5?$CIExpe@ ; `string'
  00745	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00748	50		push	eax
  00749	e8 00 00 00 00	call	_fprintf
  0074e	83 c4 0c	add	esp, 12			; 0000000cH
$L8712:

; 2105 : 
; 2106 :                 }
; 2107 : 
; 2108 :                 fprintf( DifferenceFile, "LINE ABSENT IN COMP. FILE (GOLDEN FILE LINE CONTENTS)  : %s\n",
; 2109 :                          SecondSection->CurrentLine->NormalLine );

  00751	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00754	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0075a	83 c0 08	add	eax, 8
  0075d	50		push	eax
  0075e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0DN@CEIA@LINE?5ABSENT?5IN?5COMP?4?5FILE?5?$CIGOLDE@ ; `string'
  00763	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00766	50		push	eax
  00767	e8 00 00 00 00	call	_fprintf
  0076c	83 c4 0c	add	esp, 12			; 0000000cH
$L8709:

; 2110 : 
; 2111 :             }
; 2112 : 
; 2113 :             fprintf( DifferenceFile, "\n\tERROR TYPE                     : CURRENT SECTION END SYNCH. FAILURE\n" );

  0076f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0EH@NCPN@?6?7ERROR?5TYPE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00774	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00777	50		push	eax
  00778	e8 00 00 00 00	call	_fprintf
  0077d	83 c4 08	add	esp, 8

; 2114 :             fprintf( DifferenceFile, "\tCURRENT SECTION ID             : %f\n",
; 2115 :                      SecondSection->Control.SectionIdentifier );

  00780	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00783	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  00789	51		push	ecx
  0078a	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  00790	50		push	eax
  00791	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LDF@?7CURRENT?5SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  00796	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00799	50		push	eax
  0079a	e8 00 00 00 00	call	_fprintf
  0079f	83 c4 10	add	esp, 16			; 00000010H

; 2116 : 
; 2117 :             fprintf( DifferenceFile, "\tCOMP. FILE                     : %s\n",
; 2118 :                      FirstSection->File->FileName );

  007a2	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  007a5	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  007ab	8b 40 04	mov	eax, DWORD PTR [eax+4]
  007ae	50		push	eax
  007af	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@MEHF@?7COMP?4?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  007b4	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  007b7	50		push	eax
  007b8	e8 00 00 00 00	call	_fprintf
  007bd	83 c4 0c	add	esp, 12			; 0000000cH

; 2119 :             fprintf( DifferenceFile, "\tCOMP. FILE SECTION LINE OFFSET : %u\n",
; 2120 :                      FirstSection->Control.SectionLineCount );

  007c0	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  007c3	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  007c9	50		push	eax
  007ca	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@LHCM@?7COMP?4?5FILE?5SECTION?5LINE?5OFFSET?5@ ; `string'
  007cf	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  007d2	50		push	eax
  007d3	e8 00 00 00 00	call	_fprintf
  007d8	83 c4 0c	add	esp, 12			; 0000000cH

; 2121 :             fprintf( DifferenceFile, "\tCOMP. FILE LINE OFFSET         : %u\n",
; 2122 :                      FirstSection->File->CurrentFileLine );

  007db	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  007de	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  007e4	8b 00		mov	eax, DWORD PTR [eax]
  007e6	50		push	eax
  007e7	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@HPCI@?7COMP?4?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5?5@ ; `string'
  007ec	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  007ef	50		push	eax
  007f0	e8 00 00 00 00	call	_fprintf
  007f5	83 c4 0c	add	esp, 12			; 0000000cH

; 2123 : 
; 2124 :             fprintf( DifferenceFile, "\tGOLDEN FILE                    : %s\n",
; 2125 :                      SecondSection->File->FileName );

  007f8	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  007fb	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00801	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00804	50		push	eax
  00805	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@ILDH@?7GOLDEN?5FILE?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
  0080a	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0080d	50		push	eax
  0080e	e8 00 00 00 00	call	_fprintf
  00813	83 c4 0c	add	esp, 12			; 0000000cH

; 2126 :             fprintf( DifferenceFile, "\tGOLDEN FILE SECTION LINE OFFSET: %u\n",
; 2127 :                      SecondSection->Control.SectionLineCount );

  00816	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00819	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  0081f	50		push	eax
  00820	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FKEP@?7GOLDEN?5FILE?5SECTION?5LINE?5OFFSET@ ; `string'
  00825	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00828	50		push	eax
  00829	e8 00 00 00 00	call	_fprintf
  0082e	83 c4 0c	add	esp, 12			; 0000000cH

; 2128 :             fprintf( DifferenceFile, "\tGOLDEN FILE LINE OFFSET        : %u\n",
; 2129 :                      SecondSection->File->CurrentFileLine );

  00831	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00834	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  0083a	8b 00		mov	eax, DWORD PTR [eax]
  0083c	50		push	eax
  0083d	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CG@FOKN@?7GOLDEN?5FILE?5LINE?5OFFSET?5?5?5?5?5?5?5?5@ ; `string'
  00842	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00845	50		push	eax
  00846	e8 00 00 00 00	call	_fprintf
  0084b	83 c4 0c	add	esp, 12			; 0000000cH

; 2130 : 
; 2131 :             break;

  0084e	e9 4e 00 00 00	jmp	$L8660
$L8714:

; 2132 : 
; 2133 : 
; 2134 :         default                :
; 2135 : 
; 2136 :             fprintf( DifferenceFile, "\n\nUNKNOWN COMPARISON RESULT: %u\n", ReturnResult );

  00853	8b 45 10	mov	eax, DWORD PTR _ReturnResult$[ebp]
  00856	50		push	eax
  00857	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CB@DCBI@?6?6UNKNOWN?5COMPARISON?5RESULT?3?5?$CFu?6@ ; `string'
  0085c	8b 45 18	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0085f	50		push	eax
  00860	e8 00 00 00 00	call	_fprintf
  00865	83 c4 0c	add	esp, 12			; 0000000cH

; 2137 :             break;

  00868	e9 34 00 00 00	jmp	$L8660

; 2138 : 
; 2139 :     }

  0086d	e9 2f 00 00 00	jmp	$L8660
$L8659:
  00872	ff 4d f8	dec	DWORD PTR -8+[ebp]
  00875	83 7d f8 05	cmp	DWORD PTR -8+[ebp], 5
  00879	0f 87 d4 ff ff
	ff		ja	$L8714
  0087f	8b 45 f8	mov	eax, DWORD PTR -8+[ebp]
  00882	ff 24 85 00 00
	00 00		jmp	DWORD PTR $L8956[eax*4]
$L8956:
  00889	00 00 00 00	DD	OFFSET FLAT:$L8675
  0088d	00 00 00 00	DD	OFFSET FLAT:$L8663
  00891	00 00 00 00	DD	OFFSET FLAT:$L8696
  00895	00 00 00 00	DD	OFFSET FLAT:$L8704
  00899	00 00 00 00	DD	OFFSET FLAT:$L8693
  0089d	00 00 00 00	DD	OFFSET FLAT:$L8683
$L8660:
$L8657:

; 2140 : 
; 2141 : }

  008a1	5f		pop	edi
  008a2	5e		pop	esi
  008a3	5b		pop	ebx
  008a4	c9		leave
  008a5	c2 14 00	ret	20			; 00000014H
_PrintComparisonResults@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@BCAI@FILE?5NAME?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@DLKF@SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@FNCM@SECTION?5OFFSET?5LINE?$CD?5?3?5?$CFu?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@KBIG@SECTION?5LINE?5CONTENTS?3?5?$CFs?6?$AA@ ; `string'
;	COMDAT ??_C@_0BL@BCAI@FILE?5NAME?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@BCAI@FILE?5NAME?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFs?6?$AA@ DB 'FIL'
	DB	'E NAME            : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DLKF@SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BL@DLKF@SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFf?6?$AA@ DB 'SECT'
	DB	'ION ID           : %f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FNCM@SECTION?5OFFSET?5LINE?$CD?5?3?5?$CFu?6?$AA@
CONST	SEGMENT
??_C@_0BL@FNCM@SECTION?5OFFSET?5LINE?$CD?5?3?5?$CFu?6?$AA@ DB 'SECTION OF'
	DB	'FSET LINE# : %u', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KBIG@SECTION?5LINE?5CONTENTS?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@KBIG@SECTION?5LINE?5CONTENTS?3?5?$CFs?6?$AA@ DB 'SECTION LINE C'
	DB	'ONTENTS: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT _PrintSectionInformation@8
_TEXT	SEGMENT
_Section$ = 8
_DifferenceFile$ = 12
_PrintSectionInformation@8 PROC NEAR			; COMDAT

; 2149 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	53		push	ebx
  00004	56		push	esi
  00005	57		push	edi

; 2150 : 
; 2151 :     fprintf( DifferenceFile, "FILE NAME            : %s\n" , Section->File->FileName );

  00006	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00009	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  0000f	8b 40 04	mov	eax, DWORD PTR [eax+4]
  00012	50		push	eax
  00013	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BL@BCAI@FILE?5NAME?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFs?6?$AA@ ; `string'
  00018	8b 45 0c	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0001b	50		push	eax
  0001c	e8 00 00 00 00	call	_fprintf
  00021	83 c4 0c	add	esp, 12			; 0000000cH

; 2152 :     fprintf( DifferenceFile, "SECTION ID           : %f\n" , Section->Control.SectionIdentifier );

  00024	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00027	8b 88 4c 01 00
	00		mov	ecx, DWORD PTR [eax+332]
  0002d	51		push	ecx
  0002e	8b 80 48 01 00
	00		mov	eax, DWORD PTR [eax+328]
  00034	50		push	eax
  00035	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BL@DLKF@SECTION?5ID?5?5?5?5?5?5?5?5?5?5?5?3?5?$CFf?6?$AA@ ; `string'
  0003a	8b 45 0c	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0003d	50		push	eax
  0003e	e8 00 00 00 00	call	_fprintf
  00043	83 c4 10	add	esp, 16			; 00000010H

; 2153 :     fprintf( DifferenceFile, "SECTION OFFSET LINE# : %u\n", Section->Control.SectionLineCount );

  00046	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00049	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  0004f	50		push	eax
  00050	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BL@FNCM@SECTION?5OFFSET?5LINE?$CD?5?3?5?$CFu?6?$AA@ ; `string'
  00055	8b 45 0c	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00058	50		push	eax
  00059	e8 00 00 00 00	call	_fprintf
  0005e	83 c4 0c	add	esp, 12			; 0000000cH

; 2154 :     fprintf( DifferenceFile, "SECTION LINE CONTENTS: %s\n" , Section->CurrentLine->NormalLine );

  00061	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00064	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0006a	83 c0 08	add	eax, 8
  0006d	50		push	eax
  0006e	68 00 00 00 00	push	OFFSET FLAT:??_C@_0BL@KBIG@SECTION?5LINE?5CONTENTS?3?5?$CFs?6?$AA@ ; `string'
  00073	8b 45 0c	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00076	50		push	eax
  00077	e8 00 00 00 00	call	_fprintf
  0007c	83 c4 0c	add	esp, 12			; 0000000cH
$L8718:

; 2155 : 
; 2156 : }

  0007f	5f		pop	edi
  00080	5e		pop	esi
  00081	5b		pop	ebx
  00082	c9		leave
  00083	c2 08 00	ret	8
_PrintSectionInformation@8 ENDP
_TEXT	ENDS
EXTRN	_atof:NEAR
;	COMDAT _ExtractSectionIDFromLine@4
_TEXT	SEGMENT
_Section$ = 8
_TmpBuffer$ = -4
_ExtractSectionIDFromLine@4 PROC NEAR			; COMDAT

; 2164 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 04	sub	esp, 4
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 2165 :     PCHAR TmpBuffer;
; 2166 : 
; 2167 :     //
; 2168 :     // Examine for -SECTION_START-
; 2169 :     //
; 2170 :     TmpBuffer  = strstr( Section->CurrentLine->CompressedLine, Keywords[SECTION_START] );

  00009	a1 00 00 00 00	mov	eax, DWORD PTR _Keywords
  0000e	50		push	eax
  0000f	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00012	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00018	05 08 01 00 00	add	eax, 264		; 00000108H
  0001d	50		push	eax
  0001e	e8 00 00 00 00	call	_strstr
  00023	83 c4 08	add	esp, 8
  00026	89 45 fc	mov	DWORD PTR _TmpBuffer$[ebp], eax

; 2171 : 
; 2172 :     if ( TmpBuffer != (PCHAR)NULL ) {

  00029	83 7d fc 00	cmp	DWORD PTR _TmpBuffer$[ebp], 0
  0002d	0f 84 23 00 00
	00		je	$L8726

; 2173 : 
; 2174 :         TmpBuffer += (strlen( Keywords[SECTION_START] )+1);

  00033	a1 00 00 00 00	mov	eax, DWORD PTR _Keywords
  00038	50		push	eax
  00039	e8 00 00 00 00	call	_strlen
  0003e	83 c4 04	add	esp, 4
  00041	40		inc	eax
  00042	01 45 fc	add	DWORD PTR _TmpBuffer$[ebp], eax

; 2175 :         return (DOUBLE)(atof( TmpBuffer ));

  00045	8b 45 fc	mov	eax, DWORD PTR _TmpBuffer$[ebp]
  00048	50		push	eax
  00049	e8 00 00 00 00	call	_atof
  0004e	83 c4 04	add	esp, 4
  00051	e9 58 00 00 00	jmp	$L8724
$L8726:

; 2176 : 
; 2177 :     }
; 2178 : 
; 2179 :     //
; 2180 :     // Examine for -SECTION_END-
; 2181 :     //
; 2182 :     TmpBuffer  = strstr( Section->CurrentLine->CompressedLine, Keywords[SECTION_END] );

  00056	a1 04 00 00 00	mov	eax, DWORD PTR _Keywords+4
  0005b	50		push	eax
  0005c	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0005f	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00065	05 08 01 00 00	add	eax, 264		; 00000108H
  0006a	50		push	eax
  0006b	e8 00 00 00 00	call	_strstr
  00070	83 c4 08	add	esp, 8
  00073	89 45 fc	mov	DWORD PTR _TmpBuffer$[ebp], eax

; 2183 : 
; 2184 :     if ( TmpBuffer != (PCHAR)NULL ) {

  00076	83 7d fc 00	cmp	DWORD PTR _TmpBuffer$[ebp], 0
  0007a	0f 84 23 00 00
	00		je	$L8727

; 2185 : 
; 2186 :         TmpBuffer += (strlen( Keywords[SECTION_END] )+1);

  00080	a1 04 00 00 00	mov	eax, DWORD PTR _Keywords+4
  00085	50		push	eax
  00086	e8 00 00 00 00	call	_strlen
  0008b	83 c4 04	add	esp, 4
  0008e	40		inc	eax
  0008f	01 45 fc	add	DWORD PTR _TmpBuffer$[ebp], eax

; 2187 :         return (DOUBLE)(atof( TmpBuffer ));

  00092	8b 45 fc	mov	eax, DWORD PTR _TmpBuffer$[ebp]
  00095	50		push	eax
  00096	e8 00 00 00 00	call	_atof
  0009b	83 c4 04	add	esp, 4
  0009e	e9 0b 00 00 00	jmp	$L8724
$L8727:

; 2188 : 
; 2189 :     }
; 2190 : 
; 2191 :     return (DOUBLE)0;

  000a3	dd 05 00 00 00
	00		fld	QWORD PTR $T8934
  000a9	e9 00 00 00 00	jmp	$L8724
$L8724:

; 2192 : 
; 2193 : }

  000ae	5f		pop	edi
  000af	5e		pop	esi
  000b0	5b		pop	ebx
  000b1	c9		leave
  000b2	c2 04 00	ret	4
_ExtractSectionIDFromLine@4 ENDP
_TEXT	ENDS
;	COMDAT _CheckSectionIDFromCurrentLines@8
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_SectionID_1$ = -16
_SectionID_2$ = -8
_CheckSectionIDFromCurrentLines@8 PROC NEAR		; COMDAT

; 2201 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 10	sub	esp, 16			; 00000010H
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 2202 : 
; 2203 :     DOUBLE SectionID_1, SectionID_2;
; 2204 : 
; 2205 :     SectionID_1 = ExtractSectionIDFromLine( FirstSection  );

  00009	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0000c	50		push	eax
  0000d	e8 00 00 00 00	call	_ExtractSectionIDFromLine@4
  00012	dd 5d f0	fstp	QWORD PTR _SectionID_1$[ebp]

; 2206 :     SectionID_2 = ExtractSectionIDFromLine( SecondSection );

  00015	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00018	50		push	eax
  00019	e8 00 00 00 00	call	_ExtractSectionIDFromLine@4

; 2207 : 
; 2208 :     if ( ( SectionID_1 != SectionID_2 ) ||
; 2209 :          ( SectionID_1 == (DOUBLE)0    ) ||
; 2210 :          ( SectionID_2 == (DOUBLE)0    ) ) {

  0001e	dc 55 f0	fcom	QWORD PTR _SectionID_1$[ebp]
  00021	dd 5d f8	fstp	QWORD PTR _SectionID_2$[ebp]
  00024	df e0		fnstsw	ax
  00026	f6 c4 40	test	ah, 64			; 00000040H
  00029	0f 84 28 00 00
	00		je	$L8734
  0002f	dd 45 f0	fld	QWORD PTR _SectionID_1$[ebp]
  00032	dc 1d 00 00 00
	00		fcomp	QWORD PTR $T8934
  00038	df e0		fnstsw	ax
  0003a	f6 c4 40	test	ah, 64			; 00000040H
  0003d	0f 85 14 00 00
	00		jne	$L8734
  00043	dd 45 f8	fld	QWORD PTR _SectionID_2$[ebp]
  00046	dc 1d 00 00 00
	00		fcomp	QWORD PTR $T8934
  0004c	df e0		fnstsw	ax
  0004e	f6 c4 40	test	ah, 64			; 00000040H
  00051	0f 84 07 00 00
	00		je	$L8733
$L8734:

; 2211 : 
; 2212 :         return FALSE;

  00057	32 c0		xor	al, al
  00059	e9 07 00 00 00	jmp	$L8730
$L8733:

; 2213 : 
; 2214 :     }
; 2215 : 
; 2216 :     return TRUE;

  0005e	b0 01		mov	al, 1
  00060	e9 00 00 00 00	jmp	$L8730
$L8730:

; 2217 : 
; 2218 : }

  00065	5f		pop	edi
  00066	5e		pop	esi
  00067	5b		pop	ebx
  00068	c9		leave
  00069	c2 08 00	ret	8
_CheckSectionIDFromCurrentLines@8 ENDP
_TEXT	ENDS
;	COMDAT _CompareLinesAndPrintResults@16
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_ErrorCount$ = 16
_DifferenceFile$ = 20
_ComparisonResult$ = -4
_CompareLinesAndPrintResults@16 PROC NEAR		; COMDAT

; 2228 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 04	sub	esp, 4
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 2229 : 
; 2230 :     RESULT ComparisonResult;
; 2231 : 
; 2232 :     ComparisonResult = CompareLines( FirstSection, SecondSection );

  00009	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0000c	50		push	eax
  0000d	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00010	50		push	eax
  00011	e8 00 00 00 00	call	_CompareLines@8
  00016	89 45 fc	mov	DWORD PTR _ComparisonResult$[ebp], eax

; 2233 : 
; 2234 :     if ( ComparisonResult != COMPARE_SUCCESS ) {

  00019	83 7d fc 00	cmp	DWORD PTR _ComparisonResult$[ebp], 0
  0001d	0f 84 20 00 00
	00		je	$L8741

; 2235 :         //
; 2236 :         // Increment the section error count
; 2237 :         //
; 2238 :         (*ErrorCount)++ ;

  00023	8b 45 10	mov	eax, DWORD PTR _ErrorCount$[ebp]
  00026	ff 00		inc	DWORD PTR [eax]

; 2239 : 
; 2240 :         PrintComparisonResults( FirstSection,
; 2241 :                                 SecondSection,
; 2242 :                                 ComparisonResult,
; 2243 :                                 *ErrorCount,
; 2244 :                                 DifferenceFile );

  00028	8b 45 14	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  0002b	50		push	eax
  0002c	8b 45 10	mov	eax, DWORD PTR _ErrorCount$[ebp]
  0002f	8b 00		mov	eax, DWORD PTR [eax]
  00031	50		push	eax
  00032	8b 45 fc	mov	eax, DWORD PTR _ComparisonResult$[ebp]
  00035	50		push	eax
  00036	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00039	50		push	eax
  0003a	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0003d	50		push	eax
  0003e	e8 00 00 00 00	call	_PrintComparisonResults@20
$L8741:

; 2245 : 
; 2246 :     }
; 2247 : 
; 2248 :     return TRUE;

  00043	b0 01		mov	al, 1
  00045	e9 00 00 00 00	jmp	$L8739
$L8739:

; 2249 : 
; 2250 : }

  0004a	5f		pop	edi
  0004b	5e		pop	esi
  0004c	5b		pop	ebx
  0004d	c9		leave
  0004e	c2 10 00	ret	16			; 00000010H
_CompareLinesAndPrintResults@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@GHGD@The?5system?5has?5run?5out?5of?5memory@ ; `string'
;	COMDAT ??_C@_0CM@GHGD@The?5system?5has?5run?5out?5of?5memory@
CONST	SEGMENT
??_C@_0CM@GHGD@The?5system?5has?5run?5out?5of?5memory@ DB 'The system has'
	DB	' run out of memory resources', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT _TokenInsertInSection@4
_TEXT	SEGMENT
_Section$ = 8
_Token$ = -12
_MaxLineCount$ = -8
_MinLineCount$ = -4
_TokenInsertInSection@4 PROC NEAR			; COMDAT

; 2258 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 0c	sub	esp, 12			; 0000000cH
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 2259 :     PTOKEN_LIST   Token;
; 2260 :     ULONG         MaxLineCount;
; 2261 :     ULONG         MinLineCount;
; 2262 : 
; 2263 :     //
; 2264 :     // A safe way of determining if the maximum line which will generate a valid token
; 2265 :     // is <= 0xfffffff
; 2266 :     //
; 2267 :     if( Section->Control.TokenMatchStartLine > (TOKEN_MATCHING_ALL - Section->Control.TokenMatchStopLine ) ) {

  00009	b8 ff ff ff ff	mov	eax, -1
  0000e	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00011	2b 81 40 01 00
	00		sub	eax, DWORD PTR [ecx+320]
  00017	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  0001a	3b 81 3c 01 00
	00		cmp	eax, DWORD PTR [ecx+316]
  00020	0f 83 0c 00 00
	00		jae	$L8747

; 2268 : 
; 2269 :         MaxLineCount = TOKEN_MATCHING_ALL;

  00026	c7 45 f8 ff ff
	ff ff		mov	DWORD PTR _MaxLineCount$[ebp], -1

; 2270 : 
; 2271 :     } else {

  0002d	e9 15 00 00 00	jmp	$L8748
$L8747:

; 2272 : 
; 2273 :         MaxLineCount = Section->Control.TokenMatchStartLine +
; 2274 :                        Section->Control.TokenMatchStopLine ;

  00032	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00035	8b 80 40 01 00
	00		mov	eax, DWORD PTR [eax+320]
  0003b	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  0003e	03 81 3c 01 00
	00		add	eax, DWORD PTR [ecx+316]
  00044	89 45 f8	mov	DWORD PTR _MaxLineCount$[ebp], eax
$L8748:

; 2275 : 
; 2276 :     }
; 2277 :     MinLineCount = Section->Control.TokenMatchStartLine;

  00047	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0004a	8b 80 3c 01 00
	00		mov	eax, DWORD PTR [eax+316]
  00050	89 45 fc	mov	DWORD PTR _MinLineCount$[ebp], eax

; 2278 : 
; 2279 : 
; 2280 :     //
; 2281 :     // First examine if the current line has not exceeded the Maximum StopLine AND is also greater
; 2282 :     // than the minimum line count. Because of this condition, it becomes a valid token
; 2283 :     //
; 2284 :     if( ( Section->Control.SectionLineCount <= MaxLineCount ) &&
; 2285 :         ( Section->Control.SectionLineCount >= MinLineCount ) ) {

  00053	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00056	8b 4d f8	mov	ecx, DWORD PTR _MaxLineCount$[ebp]
  00059	39 88 38 01 00
	00		cmp	DWORD PTR [eax+312], ecx
  0005f	0f 87 e8 00 00
	00		ja	$L8749
  00065	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00068	8b 4d fc	mov	ecx, DWORD PTR _MinLineCount$[ebp]
  0006b	39 88 38 01 00
	00		cmp	DWORD PTR [eax+312], ecx
  00071	0f 82 d6 00 00
	00		jb	$L8749

; 2286 : 
; 2287 :         //
; 2288 :         // Create a TOKEN and link it into the section control
; 2289 :         //
; 2290 :         Token = (PTOKEN_LIST)calloc( 1, sizeof( TOKEN_LIST ) );

  00077	68 10 02 00 00	push	528			; 00000210H
  0007c	6a 01		push	1
  0007e	e8 00 00 00 00	call	_calloc
  00083	83 c4 08	add	esp, 8
  00086	89 45 f4	mov	DWORD PTR _Token$[ebp], eax

; 2291 : 
; 2292 :         if ( Token == (PTOKEN_LIST)NULL ) {

  00089	83 7d f4 00	cmp	DWORD PTR _Token$[ebp], 0
  0008d	0f 85 17 00 00
	00		jne	$L8750

; 2293 : 
; 2294 :             printf( "The system has run out of memory resources\n" );

  00093	68 00 00 00 00	push	OFFSET FLAT:??_C@_0CM@GHGD@The?5system?5has?5run?5out?5of?5memory@ ; `string'
  00098	e8 00 00 00 00	call	_printf
  0009d	83 c4 04	add	esp, 4

; 2295 :             exit( -1 );

  000a0	6a ff		push	-1
  000a2	e8 00 00 00 00	call	_exit
  000a7	83 c4 04	add	esp, 4
$L8750:

; 2296 : 
; 2297 :         }
; 2298 : 
; 2299 :         //
; 2300 :         // Initialize this token and insert it into the unmatched list
; 2301 :         //
; 2302 :         strncpy( Token->NormalToken,
; 2303 :                  Section->CurrentLine->NormalLine,
; 2304 :                  Section->CurrentLine->NormalLineSize );

  000aa	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000ad	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000b3	8b 00		mov	eax, DWORD PTR [eax]
  000b5	50		push	eax
  000b6	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000b9	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000bf	83 c0 08	add	eax, 8
  000c2	50		push	eax
  000c3	8b 45 f4	mov	eax, DWORD PTR _Token$[ebp]
  000c6	83 c0 10	add	eax, 16			; 00000010H
  000c9	50		push	eax
  000ca	e8 00 00 00 00	call	_strncpy
  000cf	83 c4 0c	add	esp, 12			; 0000000cH

; 2305 :         strncpy( Token->CompressedToken,
; 2306 :                  Section->CurrentLine->CompressedLine,
; 2307 :                  Section->CurrentLine->CompressedLineSize );

  000d2	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000d5	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000db	8b 40 04	mov	eax, DWORD PTR [eax+4]
  000de	50		push	eax
  000df	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  000e2	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000e8	05 08 01 00 00	add	eax, 264		; 00000108H
  000ed	50		push	eax
  000ee	8b 45 f4	mov	eax, DWORD PTR _Token$[ebp]
  000f1	05 10 01 00 00	add	eax, 272		; 00000110H
  000f6	50		push	eax
  000f7	e8 00 00 00 00	call	_strncpy
  000fc	83 c4 0c	add	esp, 12			; 0000000cH

; 2308 : 
; 2309 :         Token->LinePosition     = Section->Control.SectionLineCount;

  000ff	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00102	8b 80 38 01 00
	00		mov	eax, DWORD PTR [eax+312]
  00108	8b 4d f4	mov	ecx, DWORD PTR _Token$[ebp]
  0010b	89 01		mov	DWORD PTR [ecx], eax

; 2310 :         Token->FileLinePosition = Section->File->CurrentFileLine   ;

  0010d	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00110	8b 80 30 01 00
	00		mov	eax, DWORD PTR [eax+304]
  00116	8b 00		mov	eax, DWORD PTR [eax]
  00118	8b 4d f4	mov	ecx, DWORD PTR _Token$[ebp]
  0011b	89 41 04	mov	DWORD PTR [ecx+4], eax

; 2311 :         Token->TokenState       = TOKEN_UNMATCHED;

  0011e	8b 45 f4	mov	eax, DWORD PTR _Token$[ebp]
  00121	c7 40 08 00 00
	00 00		mov	DWORD PTR [eax+8], 0

; 2312 :         Token->NextToken        = NULL;

  00128	8b 45 f4	mov	eax, DWORD PTR _Token$[ebp]
  0012b	c7 40 0c 00 00
	00 00		mov	DWORD PTR [eax+12], 0

; 2313 : 
; 2314 :         InsertToken( Token, Section->Control.HeadUnmatchedTokens );

  00132	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00135	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  0013b	8b 4d f4	mov	ecx, DWORD PTR _Token$[ebp]
  0013e	89 41 0c	mov	DWORD PTR [ecx+12], eax
  00141	8b 45 f4	mov	eax, DWORD PTR _Token$[ebp]
  00144	8b 4d 08	mov	ecx, DWORD PTR _Section$[ebp]
  00147	89 81 44 01 00
	00		mov	DWORD PTR [ecx+324], eax
$L8749:
$L8743:

; 2315 : 
; 2316 :     }
; 2317 : 
; 2318 : }

  0014d	5f		pop	edi
  0014e	5e		pop	esi
  0014f	5b		pop	ebx
  00150	c9		leave
  00151	c2 04 00	ret	4
_TokenInsertInSection@4 ENDP
_TEXT	ENDS
PUBLIC	_MatchTopToken@8
;	COMDAT _MatchTopToken@8
_TEXT	SEGMENT
_BaseList$ = 8
_ComparisonList$ = 12
_CurrentToken$ = -4
_Length$ = -8
_MatchTopToken@8 PROC NEAR				; COMDAT

; 2326 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 08	sub	esp, 8
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 2327 :     PTOKEN_LIST   CurrentToken ;
; 2328 :     INT           Length       ;
; 2329 : 
; 2330 :     CurrentToken = ComparisonList;

  00009	8b 45 0c	mov	eax, DWORD PTR _ComparisonList$[ebp]
  0000c	89 45 fc	mov	DWORD PTR _CurrentToken$[ebp], eax

; 2331 : 
; 2332 :     //
; 2333 :     // Check if the Base Token under comparison is a possible MAY_DIFFER
; 2334 :     //
; 2335 :     if ( strstr( BaseList->CompressedToken, "MAY_DIFFER" ) != NULL ) {

  0000f	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@NEDE@MAY_DIFFER?$AA@ ; `string'
  00014	8b 45 08	mov	eax, DWORD PTR _BaseList$[ebp]
  00017	05 10 01 00 00	add	eax, 272		; 00000110H
  0001c	50		push	eax
  0001d	e8 00 00 00 00	call	_strstr
  00022	83 c4 08	add	esp, 8
  00025	85 c0		test	eax, eax
  00027	0f 84 07 00 00
	00		je	$L8757

; 2336 : 
; 2337 :         return COMPARE_SUCCESS;

  0002d	33 c0		xor	eax, eax
  0002f	e9 7a 00 00 00	jmp	$L8754
$L8757:

; 2338 : 
; 2339 :     }
; 2340 : 
; 2341 :     //
; 2342 :     // Walk down the token chain list looking for a match. Note if the token has been
; 2343 :     // matched before, it is marked so and hence cannot be reused
; 2344 :     //
; 2345 :     Length = strlen( BaseList->CompressedToken );

  00034	8b 45 08	mov	eax, DWORD PTR _BaseList$[ebp]
  00037	05 10 01 00 00	add	eax, 272		; 00000110H
  0003c	50		push	eax
  0003d	e8 00 00 00 00	call	_strlen
  00042	83 c4 04	add	esp, 4
  00045	89 45 f8	mov	DWORD PTR _Length$[ebp], eax
$L8759:

; 2346 : 
; 2347 :     while ( CurrentToken != (PTOKEN_LIST )NULL ) {

  00048	83 7d fc 00	cmp	DWORD PTR _CurrentToken$[ebp], 0
  0004c	0f 84 52 00 00
	00		je	$L8760

; 2348 : 
; 2349 :         if ( ( CurrentToken->TokenState == TOKEN_UNMATCHED ) &&
; 2350 :              ( strncmp( BaseList->CompressedToken, CurrentToken->CompressedToken, Length ) == 0 )
; 2351 :            ) {

  00052	8b 45 fc	mov	eax, DWORD PTR _CurrentToken$[ebp]
  00055	83 78 08 00	cmp	DWORD PTR [eax+8], 0
  00059	0f 85 37 00 00
	00		jne	$L8761
  0005f	8b 45 f8	mov	eax, DWORD PTR _Length$[ebp]
  00062	50		push	eax
  00063	8b 45 fc	mov	eax, DWORD PTR _CurrentToken$[ebp]
  00066	05 10 01 00 00	add	eax, 272		; 00000110H
  0006b	50		push	eax
  0006c	8b 45 08	mov	eax, DWORD PTR _BaseList$[ebp]
  0006f	05 10 01 00 00	add	eax, 272		; 00000110H
  00074	50		push	eax
  00075	e8 00 00 00 00	call	_strncmp
  0007a	83 c4 0c	add	esp, 12			; 0000000cH
  0007d	85 c0		test	eax, eax
  0007f	0f 85 11 00 00
	00		jne	$L8761

; 2352 : 
; 2353 :             //
; 2354 :             // Found a match
; 2355 :             //
; 2356 : 
; 2357 :             CurrentToken->TokenState = TOKEN_MATCHED;

  00085	8b 45 fc	mov	eax, DWORD PTR _CurrentToken$[ebp]
  00088	c7 40 08 01 00
	00 00		mov	DWORD PTR [eax+8], 1

; 2358 :             return COMPARE_SUCCESS;

  0008f	33 c0		xor	eax, eax
  00091	e9 18 00 00 00	jmp	$L8754
$L8761:

; 2359 : 
; 2360 :         }
; 2361 : 
; 2362 :         CurrentToken = CurrentToken->NextToken;

  00096	8b 45 fc	mov	eax, DWORD PTR _CurrentToken$[ebp]
  00099	8b 40 0c	mov	eax, DWORD PTR [eax+12]
  0009c	89 45 fc	mov	DWORD PTR _CurrentToken$[ebp], eax

; 2363 : 
; 2364 :     }

  0009f	e9 a4 ff ff ff	jmp	$L8759
$L8760:

; 2365 : 
; 2366 :     return COMPARE_TOKEN;

  000a4	b8 05 00 00 00	mov	eax, 5
  000a9	e9 00 00 00 00	jmp	$L8754
$L8754:

; 2367 : 
; 2368 : }

  000ae	5f		pop	edi
  000af	5e		pop	esi
  000b0	5b		pop	ebx
  000b1	c9		leave
  000b2	c2 08 00	ret	8
_MatchTopToken@8 ENDP
_TEXT	ENDS
;	COMDAT _CompareTokensAndPrintResults@16
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_ErrorCount$ = 16
_DifferenceFile$ = 20
_ComparisonResult$ = -8
_Tmp$ = -4
_CompareTokensAndPrintResults@16 PROC NEAR		; COMDAT

; 2378 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 08	sub	esp, 8
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi
$L8770:

; 2379 :     RESULT         ComparisonResult;
; 2380 :     PTOKEN_LIST    Tmp;
; 2381 : 
; 2382 :     //
; 2383 :     // The base set for comparison will always come from the second file(golden file)
; 2384 :     //
; 2385 : 
; 2386 :     //
; 2387 :     // And now search for matches for the individual tokens from the base set
; 2388 :     //
; 2389 :     while ( SecondSection->Control.HeadUnmatchedTokens != (PTOKEN_LIST)NULL ) {

  00009	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0000c	83 b8 44 01 00
	00 00		cmp	DWORD PTR [eax+324], 0
  00013	0f 84 78 00 00
	00		je	$L8771

; 2390 : 
; 2391 :         ComparisonResult = MatchTopToken( SecondSection->Control.HeadUnmatchedTokens,
; 2392 :                                           FirstSection->Control.HeadUnmatchedTokens );

  00019	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0001c	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  00022	50		push	eax
  00023	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00026	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  0002c	50		push	eax
  0002d	e8 00 00 00 00	call	_MatchTopToken@8
  00032	89 45 f8	mov	DWORD PTR _ComparisonResult$[ebp], eax

; 2393 : 
; 2394 : 
; 2395 :         if ( ComparisonResult != COMPARE_SUCCESS ) {

  00035	83 7d f8 00	cmp	DWORD PTR _ComparisonResult$[ebp], 0
  00039	0f 84 20 00 00
	00		je	$L8772

; 2396 : 
; 2397 :             (*ErrorCount)++ ;

  0003f	8b 45 10	mov	eax, DWORD PTR _ErrorCount$[ebp]
  00042	ff 00		inc	DWORD PTR [eax]

; 2398 : 
; 2399 :             PrintComparisonResults( FirstSection,
; 2400 :                                     SecondSection,
; 2401 :                                     ComparisonResult,
; 2402 :                                     *ErrorCount,
; 2403 :                                     DifferenceFile );

  00044	8b 45 14	mov	eax, DWORD PTR _DifferenceFile$[ebp]
  00047	50		push	eax
  00048	8b 45 10	mov	eax, DWORD PTR _ErrorCount$[ebp]
  0004b	8b 00		mov	eax, DWORD PTR [eax]
  0004d	50		push	eax
  0004e	8b 45 f8	mov	eax, DWORD PTR _ComparisonResult$[ebp]
  00051	50		push	eax
  00052	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00055	50		push	eax
  00056	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00059	50		push	eax
  0005a	e8 00 00 00 00	call	_PrintComparisonResults@20
$L8772:

; 2404 :         }
; 2405 : 
; 2406 :         //
; 2407 :         // And now destroy this token from the base list
; 2408 :         //
; 2409 :         Tmp =
; 2410 :           SecondSection->Control.HeadUnmatchedTokens;

  0005f	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00062	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  00068	89 45 fc	mov	DWORD PTR _Tmp$[ebp], eax

; 2411 : 
; 2412 :         SecondSection->Control.HeadUnmatchedTokens =
; 2413 :           SecondSection->Control.HeadUnmatchedTokens->NextToken;

  0006b	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0006e	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  00074	8b 40 0c	mov	eax, DWORD PTR [eax+12]
  00077	8b 4d 0c	mov	ecx, DWORD PTR _SecondSection$[ebp]
  0007a	89 81 44 01 00
	00		mov	DWORD PTR [ecx+324], eax

; 2414 : 
; 2415 :         DestroyToken( Tmp );

  00080	8b 45 fc	mov	eax, DWORD PTR _Tmp$[ebp]
  00083	50		push	eax
  00084	e8 00 00 00 00	call	_free
  00089	83 c4 04	add	esp, 4

; 2416 : 
; 2417 :     }

  0008c	e9 78 ff ff ff	jmp	$L8770
$L8771:
$L8774:

; 2418 : 
; 2419 :     //
; 2420 :     // Finally cleanup the tokens on the compared section
; 2421 :     //
; 2422 :     while ( FirstSection->Control.HeadUnmatchedTokens != (PTOKEN_LIST)NULL ) {

  00091	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00094	83 b8 44 01 00
	00 00		cmp	DWORD PTR [eax+324], 0
  0009b	0f 84 32 00 00
	00		je	$L8775

; 2423 : 
; 2424 :         Tmp                 =
; 2425 :           FirstSection->Control.HeadUnmatchedTokens;

  000a1	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000a4	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  000aa	89 45 fc	mov	DWORD PTR _Tmp$[ebp], eax

; 2426 : 
; 2427 :         FirstSection->Control.HeadUnmatchedTokens =
; 2428 :           FirstSection->Control.HeadUnmatchedTokens->NextToken;

  000ad	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000b0	8b 80 44 01 00
	00		mov	eax, DWORD PTR [eax+324]
  000b6	8b 40 0c	mov	eax, DWORD PTR [eax+12]
  000b9	8b 4d 08	mov	ecx, DWORD PTR _FirstSection$[ebp]
  000bc	89 81 44 01 00
	00		mov	DWORD PTR [ecx+324], eax

; 2429 : 
; 2430 :         DestroyToken( Tmp );

  000c2	8b 45 fc	mov	eax, DWORD PTR _Tmp$[ebp]
  000c5	50		push	eax
  000c6	e8 00 00 00 00	call	_free
  000cb	83 c4 04	add	esp, 4

; 2431 : 
; 2432 :     }

  000ce	e9 be ff ff ff	jmp	$L8774
$L8775:
$L8766:

; 2433 : 
; 2434 : }

  000d3	5f		pop	edi
  000d4	5e		pop	esi
  000d5	5b		pop	ebx
  000d6	c9		leave
  000d7	c2 10 00	ret	16			; 00000010H
_CompareTokensAndPrintResults@16 ENDP
_TEXT	ENDS
;	COMDAT _MayDifferExistsInOneOrMoreLines@8
_TEXT	SEGMENT
_FirstSection$ = 8
_SecondSection$ = 12
_MayDifferExistsInOneOrMoreLines@8 PROC NEAR		; COMDAT

; 2442 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	53		push	ebx
  00004	56		push	esi
  00005	57		push	edi

; 2443 : 
; 2444 :     if ( ( strstr( FirstSection->CurrentLine->CompressedLine, "MAY_DIFFER"  ) != NULL ) ||
; 2445 :          ( strstr( SecondSection->CurrentLine->CompressedLine, "MAY_DIFFER" ) != NULL ) ) {

  00006	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@NEDE@MAY_DIFFER?$AA@ ; `string'
  0000b	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0000e	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00014	05 08 01 00 00	add	eax, 264		; 00000108H
  00019	50		push	eax
  0001a	e8 00 00 00 00	call	_strstr
  0001f	83 c4 08	add	esp, 8
  00022	85 c0		test	eax, eax
  00024	0f 85 24 00 00
	00		jne	$L8780
  0002a	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@NEDE@MAY_DIFFER?$AA@ ; `string'
  0002f	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00032	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00038	05 08 01 00 00	add	eax, 264		; 00000108H
  0003d	50		push	eax
  0003e	e8 00 00 00 00	call	_strstr
  00043	83 c4 08	add	esp, 8
  00046	85 c0		test	eax, eax
  00048	0f 84 ce 00 00
	00		je	$L8779
$L8780:

; 2446 : 
; 2447 :         //
; 2448 :         // Token matching is a special case. Since we care only about the second
; 2449 :         // section since that is the golden section, we make another exception
; 2450 :         // and not check for the first section
; 2451 :         //
; 2452 :         if ( SecondSection->Control.TokenMatching == TRUE ) {

  0004e	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00051	33 c9		xor	ecx, ecx
  00053	8a 88 51 01 00
	00		mov	cl, BYTE PTR [eax+337]
  00059	83 f9 01	cmp	ecx, 1
  0005c	0f 85 b3 00 00
	00		jne	$L8781

; 2453 : 
; 2454 :             if ( strstr( SecondSection->CurrentLine->CompressedLine, "MAY_DIFFER" ) == NULL ) {

  00062	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@NEDE@MAY_DIFFER?$AA@ ; `string'
  00067	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  0006a	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00070	05 08 01 00 00	add	eax, 264		; 00000108H
  00075	50		push	eax
  00076	e8 00 00 00 00	call	_strstr
  0007b	83 c4 08	add	esp, 8
  0007e	85 c0		test	eax, eax
  00080	0f 85 31 00 00
	00		jne	$L8782

; 2455 :                 //
; 2456 :                 // This implies that the firstsection line had a MAY_DIFFER in it and the second
; 2457 :                 // section did not
; 2458 :                 //
; 2459 :                 // Now check the line  type
; 2460 :                 //
; 2461 :                 TokenInsertInSection( FirstSection  );

  00086	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00089	50		push	eax
  0008a	e8 00 00 00 00	call	_TokenInsertInSection@4

; 2462 : 
; 2463 :                 if ( SecondSection->CurrentLine->LineType == LINE_TYPE_REGULAR ) {

  0008f	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  00092	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00098	33 c9		xor	ecx, ecx
  0009a	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  000a0	83 f9 03	cmp	ecx, 3
  000a3	0f 85 09 00 00
	00		jne	$L8783

; 2464 : 
; 2465 :                     TokenInsertInSection( SecondSection );

  000a9	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  000ac	50		push	eax
  000ad	e8 00 00 00 00	call	_TokenInsertInSection@4
$L8783:

; 2466 : 
; 2467 :                 }
; 2468 : 
; 2469 :             } else {

  000b2	e9 5e 00 00 00	jmp	$L8784
$L8782:

; 2470 : 
; 2471 :                 //
; 2472 :                 // The secondsection had a MAY_DIFFER in it
; 2473 :                 //
; 2474 :                 TokenInsertInSection( SecondSection );

  000b7	8b 45 0c	mov	eax, DWORD PTR _SecondSection$[ebp]
  000ba	50		push	eax
  000bb	e8 00 00 00 00	call	_TokenInsertInSection@4

; 2475 : 
; 2476 :                 if ( strstr( FirstSection->CurrentLine->CompressedLine, "MAY_DIFFER" ) == NULL ) {

  000c0	68 00 00 00 00	push	OFFSET FLAT:??_C@_0L@NEDE@MAY_DIFFER?$AA@ ; `string'
  000c5	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000c8	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000ce	05 08 01 00 00	add	eax, 264		; 00000108H
  000d3	50		push	eax
  000d4	e8 00 00 00 00	call	_strstr
  000d9	83 c4 08	add	esp, 8
  000dc	85 c0		test	eax, eax
  000de	0f 85 28 00 00
	00		jne	$L8785

; 2477 :                     //
; 2478 :                     // The FirstSection did not have a MAY_DIFFER in it
; 2479 :                     //
; 2480 :                     if ( FirstSection->CurrentLine->LineType == LINE_TYPE_REGULAR ) {

  000e4	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  000e7	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  000ed	33 c9		xor	ecx, ecx
  000ef	8a 88 08 02 00
	00		mov	cl, BYTE PTR [eax+520]
  000f5	83 f9 03	cmp	ecx, 3
  000f8	0f 85 09 00 00
	00		jne	$L8786

; 2481 : 
; 2482 :                         TokenInsertInSection( FirstSection );

  000fe	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  00101	50		push	eax
  00102	e8 00 00 00 00	call	_TokenInsertInSection@4
$L8786:

; 2483 : 
; 2484 :                     }
; 2485 : 
; 2486 :                 } else {

  00107	e9 09 00 00 00	jmp	$L8787
$L8785:

; 2487 :                     //
; 2488 :                     // At this point we have determined that both lines contained MAY_DIFFER
; 2489 :                     // in them
; 2490 :                     //
; 2491 :                     TokenInsertInSection( FirstSection  );

  0010c	8b 45 08	mov	eax, DWORD PTR _FirstSection$[ebp]
  0010f	50		push	eax
  00110	e8 00 00 00 00	call	_TokenInsertInSection@4
$L8787:
$L8784:
$L8781:

; 2492 :                 }
; 2493 :             }
; 2494 :         }
; 2495 : 
; 2496 :         return TRUE;

  00115	b0 01		mov	al, 1
  00117	e9 07 00 00 00	jmp	$L8778
$L8779:

; 2497 : 
; 2498 :     }
; 2499 : 
; 2500 :     return FALSE;

  0011c	32 c0		xor	al, al
  0011e	e9 00 00 00 00	jmp	$L8778
$L8778:

; 2501 : 
; 2502 : }

  00123	5f		pop	edi
  00124	5e		pop	esi
  00125	5b		pop	ebx
  00126	c9		leave
  00127	c2 08 00	ret	8
_MayDifferExistsInOneOrMoreLines@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_08ILIP@?$FLTPCTL?3?$FN?$AA@		; `string'
PUBLIC	??_C@_09KECI@SKIP_LINE?$AA@			; `string'
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_08ILIP@?$FLTPCTL?3?$FN?$AA@
CONST	SEGMENT
??_C@_08ILIP@?$FLTPCTL?3?$FN?$AA@ DB '[TPCTL:]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KECI@SKIP_LINE?$AA@
CONST	SEGMENT
??_C@_09KECI@SKIP_LINE?$AA@ DB 'SKIP_LINE', 00H		; `string'
CONST	ENDS
;	COMDAT _DoNotSkipThisLine@4
_TEXT	SEGMENT
_Section$ = 8
_SpecialLine$ = -4
_DoNotSkipThisLine@4 PROC NEAR				; COMDAT

; 2509 : {

  00000	55		push	ebp
  00001	8b ec		mov	ebp, esp
  00003	83 ec 04	sub	esp, 4
  00006	53		push	ebx
  00007	56		push	esi
  00008	57		push	edi

; 2510 :     CHAR *SpecialLine = "[TPCTL:]";

  00009	c7 45 fc 00 00
	00 00		mov	DWORD PTR _SpecialLine$[ebp], OFFSET FLAT:??_C@_08ILIP@?$FLTPCTL?3?$FN?$AA@ ; `string'

; 2511 : 
; 2512 :     //
; 2513 :     // This function is responsible for informing the calling function to skip lines
; 2514 :     // should it detect the presence of the keyword SKIP_LINE or match the compressed
; 2515 :     // line with the special line. This can be later extented to cover special lines
; 2516 :     //
; 2517 :     if ( ( strstr( Section->CurrentLine->CompressedLine, "SKIP_LINE" ) == NULL ) &&
; 2518 :          ( strcmp( Section->CurrentLine->CompressedLine, SpecialLine ) != 0    ) &&
; 2519 :          ( strlen( Section->CurrentLine->CompressedLine              ) != 0    )     ) {

  00010	68 00 00 00 00	push	OFFSET FLAT:??_C@_09KECI@SKIP_LINE?$AA@ ; `string'
  00015	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  00018	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  0001e	05 08 01 00 00	add	eax, 264		; 00000108H
  00023	50		push	eax
  00024	e8 00 00 00 00	call	_strstr
  00029	83 c4 08	add	esp, 8
  0002c	85 c0		test	eax, eax
  0002e	0f 85 49 00 00
	00		jne	$L8792
  00034	8b 45 fc	mov	eax, DWORD PTR _SpecialLine$[ebp]
  00037	50		push	eax
  00038	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0003b	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00041	05 08 01 00 00	add	eax, 264		; 00000108H
  00046	50		push	eax
  00047	e8 00 00 00 00	call	_strcmp
  0004c	83 c4 08	add	esp, 8
  0004f	85 c0		test	eax, eax
  00051	0f 84 26 00 00
	00		je	$L8792
  00057	8b 45 08	mov	eax, DWORD PTR _Section$[ebp]
  0005a	8b 80 34 01 00
	00		mov	eax, DWORD PTR [eax+308]
  00060	05 08 01 00 00	add	eax, 264		; 00000108H
  00065	50		push	eax
  00066	e8 00 00 00 00	call	_strlen
  0006b	83 c4 04	add	esp, 4
  0006e	85 c0		test	eax, eax
  00070	0f 84 07 00 00
	00		je	$L8792

; 2520 : 
; 2521 :         return TRUE;

  00076	b0 01		mov	al, 1
  00078	e9 07 00 00 00	jmp	$L8789
$L8792:

; 2522 : 
; 2523 :     }
; 2524 : 
; 2525 :     return FALSE;

  0007d	32 c0		xor	al, al
  0007f	e9 00 00 00 00	jmp	$L8789
$L8789:

; 2526 : 
; 2527 : }

  00084	5f		pop	edi
  00085	5e		pop	esi
  00086	5b		pop	ebx
  00087	c9		leave
  00088	c2 04 00	ret	4
_DoNotSkipThisLine@4 ENDP
_TEXT	ENDS
END
